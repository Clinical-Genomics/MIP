#!/usr/bin/env perl

### Will test perl modules and some selected funtions as well as vcf keys both in header and body. Adjusts dynamically according to supplied config file.

use 5.026;
use Carp;
use charnames qw{ :full :short };
use Cwd qw{ abs_path };
use English qw{ -no_match_vars };
use FindBin qw{ $Bin };
use File::Basename qw{ dirname basename };
use File::Spec::Functions qw{ catdir catfile devnull };
use Getopt::Long;
use open qw{ :encoding(UTF-8) :std };
use Params::Check qw{ check allow last_error };
use Test::More;
use warnings qw{ FATAL utf8 };
use utf8;

## CPANM
use autodie qw{ open close :all };
use Modern::Perl qw{ 2018 };
use List::Util qw{ any };
use Readonly;

##MIPs lib/
use lib catdir( dirname($Bin), q{lib} );
use MIP::Constants qw{ $COMMA $NEWLINE $SEMICOLON $SPACE $TAB };
use MIP::Check::Modules qw{ check_perl_modules };
use MIP::Io::Read qw{ read_from_file };
use MIP::Log::MIP_log4perl qw{ initiate_logger };
use MIP::Script::Utils qw{ help };

our $USAGE = build_usage( {} );

BEGIN {

    require MIP::Check::Modules;
    use MIP::Check::Modules qw{ parse_cpan_file };

    my @modules =
      parse_cpan_file { cpanfile_path => catfile( dirname($Bin), q{cpanfile} ), };

    ## Evaluate that all modules required throughout entire analysis are installed
    check_perl_modules(
        {
            modules_ref  => \@modules,
            program_name => $PROGRAM_NAME,
        }
    );
}

my ( $config_file, $infile );
my ( %active_parameter, %parameter, %pedigree, %vcfparser_data, );

our $VERSION = 2.07;

if ( scalar @ARGV == 0 ) {

    say {*STDOUT} $USAGE;
    exit;
}

############
####MAIN####
############

$infile      = $ARGV[0];
$config_file = $ARGV[1];

### User Options
GetOptions(

    # Display help text
    q{h|help} => sub { say {*STDOUT} $USAGE; exit; },

    # Display version number
    q{v|version} => sub {
        say {*STDOUT} $NEWLINE . basename($PROGRAM_NAME) . $SPACE . $VERSION, $NEWLINE;
        exit;
    },
  )
  or help(
    {
        USAGE     => $USAGE,
        exit_code => 1,
    }
  );

if ( not defined $infile ) {

    say {*STDERR} q{Please supply an infile};
    exit 1;
}

if ( not defined $config_file ) {

    say {*STDERR} q{Please supply a config file};
    exit 1;
}

## Test perl modules and functions
test_modules();

## Loads a YAML file into an arbitrary hash and returns it.
%active_parameter = read_from_file(
    {
        format => q{yaml},
        path   => $config_file,
    }
);

if ( exists $active_parameter{pedigree_file} ) {

    ## Loads a YAML file into an arbitrary hash and returns it.
    %pedigree = read_from_file(
        {
            format => q{yaml},
            path   => $active_parameter{pedigree_file},
        }
    );

    ### Sample level info

  PEDIGREE_HREF:
    foreach my $pedigree_sample_href ( @{ $pedigree{samples} } ) {

        ## Sample_id
        my $sample_id = $pedigree_sample_href->{sample_id};

        ## Phenotype
        push @{ $parameter{cache}{ $pedigree_sample_href->{phenotype} } }, $sample_id;

        ## Sex
        push @{ $parameter{cache}{ $pedigree_sample_href->{sex} } }, $sample_id;
    }
}

if ( $infile =~ /.selected.vcf/sxm ) {

    if ( exists $active_parameter{vcfparser_select_file}
        && $active_parameter{vcfparser_select_file} )
    {

        ## Reads a file containg features to be annotated using range queries
        read_range_file(
            {
                infile_path => catfile( $active_parameter{vcfparser_select_file} ),
                range_coulumns_ref =>
                  \@{ $active_parameter{vcfparser_select_feature_annotation_columns} },
                range_file_key      => q{select_file},
                vcfparser_data_href => \%vcfparser_data,
            }
        );
    }
}
else {
    # Range file

    if ( exists $active_parameter{vcfparser_range_feature_file}
        && $active_parameter{vcfparser_range_feature_file} )
    {

        ## Reads a file containg features to be annotated using range queries
        read_range_file(
            {
                infile_path => catfile( $active_parameter{vcfparser_range_feature_file} ),
                range_coulumns_ref =>
                  \@{ $active_parameter{vcfparser_range_feature_annotation_columns} },
                range_file_key      => q{range_file},
                vcfparser_data_href => \%vcfparser_data,
            }
        );
    }
}

## SV files
if ( $infile =~ /\/sv_\w+\//sxm ) {

## Reads infile in vcf format and parses annotations
    read_sv_infile_vcf(
        {
            active_parameter_href => \%active_parameter,
            infile_vcf            => $infile,
            parameter_href        => \%parameter,
            vcfparser_data_href   => \%vcfparser_data,
        }
    );
}
else {

## Snv/indel files

## Reads infile in vcf format and parses annotations
    read_infile_vcf(
        {
            active_parameter_href => \%active_parameter,
            infile_vcf            => $infile,
            parameter_href        => \%parameter,
            vcfparser_data_href   => \%vcfparser_data,
        }
    );
}

# Reached the end safely
done_testing();

######################
####SubRoutines#######
######################

sub build_usage {

## Function : Build the USAGE instructions
## Returns  :
## Arguments: $program_name => Name of the script

    my ($arg_href) = @_;

    ## Default(s)
    my $program_name;

    my $tmpl = {
        program_name => {
            default     => basename($PROGRAM_NAME),
            store       => \$program_name,
            strict_type => 1,
        },
    };

    check( $tmpl, $arg_href, 1 ) or croak q{Could not parse arguments!};

    return <<"END_USAGE";
 $program_name infile.vcf [VCF] config_file [YAML] [options]
    -h/--help    Display this help message
    -v/--version Display version
END_USAGE
}

sub test_modules {

## Function : Test perl modules and functions
## Returns  :
## Arguments:

    say {*STDOUT} $NEWLINE . q{Testing perl modules and selected functions}, $NEWLINE;

    # Find directory of script
    use FindBin qw{ $Bin };

    ok( defined $Bin, q{FindBin: Locate directory of script} );

    ## Strip the last part of directory
    use File::Basename qw{ dirname };

    ok( dirname($Bin),
        q{File::Basename qw{ dirname }: Strip the last part of directory} );

    use File::Spec::Functions qw{ catdir };

    ok( catdir( dirname($Bin), q{t} ),
        q{File::Spec::Functions qw{ catdir }: Concatenate directories} );

    use YAML;

    my $yaml_file = catdir( dirname($Bin), qw{ definitions mip_parameters.yaml } );
    ok( -f $yaml_file, q{YAML: File=} . $yaml_file . q{in MIP directory} );

    ## Create an object
    my $yaml = YAML::LoadFile($yaml_file);

    ## Check that we got something
    ok( defined $yaml, q{YAML: Load File} );
    ok( Dump($yaml),   q{YAML: Dump file} );

    use Log::Log4perl;
    ## Creates log
    my $log_file = catdir( dirname($Bin), qw{ templates mip_rd_dna_config.yaml } );
    ok( -f $log_file, q{Log::Log4perl: File=} . $log_file . q{in MIP directory} );

    ## Creates log object
    my $log = initiate_logger(
        {
            categories_ref => [qw{ TRACE ScreenApp }],
            file_path      => $log_file,
            log_name       => q{Test},
        }
    );

    ok( $log->info(1),  q{Log::Log4perl: info} );
    ok( $log->warn(1),  q{Log::Log4perl: warn} );
    ok( $log->error(1), q{Log::Log4perl: error} );
    ok( $log->fatal(1), q{Log::Log4perl: fatal} );

    use Getopt::Long;
    push @ARGV, qw{ -verbose 2 };
    my $verbose = 1;
    ok( GetOptions( q{verbose:n} => \$verbose ), q{Getopt::Long: Get options call} );
    ok( $verbose == 2,                           q{Getopt::Long: Get options modified} );

    return;
}

sub read_infile_vcf {

## Function : Reads infile in vcf format and adds and parses annotations
## Returns  :
## Arguments: $active_parameter_href => The active parameters for this analysis hash {REF}
##          : $infile_vcf            => Infile
##          : $parameter_href        => The parameter hash {REF}
##          : $vcfparser_data_href   => The keys from vcfParser i.e. range file and select file

    my ($arg_href) = @_;

    ## Flatten argument(s)
    my $active_parameter_href;
    my $infile_vcf;
    my $parameter_href;
    my $vcfparser_data_href;

    my $tmpl = {
        active_parameter_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$active_parameter_href,
            strict_type => 1,
        },
        infile_vcf => {
            defined     => 1,
            required    => 1,
            store       => \$infile_vcf,
            strict_type => 1,
        },
        parameter_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$parameter_href,
            strict_type => 1,
        },
        vcfparser_data_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$vcfparser_data_href,
            strict_type => 1,
        },
    };

    check( $tmpl, $arg_href, 1 ) or croak q{Could not parse arguments!};

    ## Constants
    Readonly my $MAX_LINE_TO_READ => 100_00;

    ## Retrieve logger object now that log_file has been set
    my $log = Log::Log4perl->get_logger(q{Test});

    my $is_csq_found;
    my @vep_format_fields;
    my %vep_format_field;

    # Catch vcf header #CHROM line
    my %meta_data;
    my @vcf_format_columns;
    my %vcf_header;
    my %vcf_info_key;
    my %vcf_info_csq_key;

    $log->info( q{Testing vcf header in file: } . $infile_vcf, $NEWLINE x 2 );

    ## Read file
    open my $filehandle, q{<}, $infile_vcf
      or
      $log->logdie( q{Cannot open} . $SPACE . $infile_vcf . q{:} . $OS_ERROR, $NEWLINE );

  LINE:
    while (<$filehandle>) {

        chomp;

        ## Quit reading
        last LINE if ( $INPUT_LINE_NUMBER > $MAX_LINE_TO_READ );

        ## Unpack line
        my $line = $_;

        ## Skip blank lines
        next LINE if ( $line =~ /^\s+$/sxm );

        # If meta data
        if ( $line =~ /\A [#]{2}/sxm ) {

            parse_meta_data(
                {
                    meta_data_href   => \%meta_data,
                    meta_data_string => $line,
                }
            );

            if (/ INFO\=\<ID\=([^,]+) /sxm) {

                $vcf_header{INFO}{$1} = $1;
            }

            $is_csq_found = check_if_vep_csq_in_line(
                {
                    vep_format_field_href => \%vep_format_field,
                    header_line           => $line,
                }
            );

            if ($is_csq_found) {

                ok(
                    $active_parameter_href->{varianteffectpredictor},
                    q{VEP: CSQ in header and VEP should have been executed}
                );
            }
            next LINE;
        }
        if ( $line =~ /\A [#]{1}CHROM/sxm ) {

            # Split vcf format line
            @vcf_format_columns = split $TAB;

            ### Check Header now that we read all

            ## Test Vt
            _test_vt_in_vcf_header(
                {
                    vcf_header_href   => \%vcf_header,
                    vt_mode           => $active_parameter_href->{vt_ar},
                    vt_decompose_mode => $active_parameter_href->{vt_decompose},
                    vt_normalize_mode => $active_parameter_href->{vt_normalize},
                }
            );

            ## Test Frequency filter
            _test_frequency_filter_in_vcf_header(
                {
                    fqf_annotations_ref => $active_parameter_href->{fqf_annotations},
                    recipe_mode         => $active_parameter_href->{frequency_filter},
                    toml_file_path      => $active_parameter_href->{fqa_vcfanno_config},
                    vcf_header_href     => \%vcf_header,
                }
            );

            ## Test vcfparser
            _test_vcfparser_in_vcf_header(
                {
                    vcf_header_href     => \%vcf_header,
                    vcfparser_data_href => $vcfparser_data_href,
                    vcfparser_mode      => $active_parameter_href->{vcfparser_ar},
                }
            );

            ## Test Rankvariants
            _test_rankvariants_in_vcf_header(
                {
                    genmod_annotate_cadd_files_ref =>
                      \@{ $active_parameter_href->{genmod_annotate_cadd_files} },
                    rankvariant_mode       => $active_parameter_href->{rankvariant},
                    sample_ids_ref         => \@{ $active_parameter_href->{sample_ids} },
                    spidex_file            => $active_parameter_href->{spidex_file},
                    unaffected_samples_ref => \@{ $parameter_href->{cache}{unaffected} },
                    vcf_header_href        => \%vcf_header,
                }
            );

            next LINE;
        }

        ## VCF body lines
        my %vcf_record =
          parse_vcf_line( { vcf_format_columns_ref => \@vcf_format_columns, } );

        ## Count incedence of keys
      INFO_KEY:
        foreach my $info_key ( keys %{ $vcf_record{INFO_key_value} } ) {

            ## Increment
            $vcf_info_key{$info_key}++;
        }

        my %csq_transcript_effect = parse_vep_csq_info(
            {
                vcf_record_href       => \%vcf_record,
                vcf_info_csq_key_href => \%vcf_info_csq_key,
                vep_format_field_href => \%vep_format_field,
            }
        );

        ## Sum all CSQ vcf transcript effect keys
      TRANSCRIPT_ID:
        foreach my $transcript_id ( keys %csq_transcript_effect ) {

          CSQ_TRANSCRIPT_EFFECTS:
            while ( my ( $effect_key, $effect_value ) = each %vep_format_field ) {

                if ( exists $csq_transcript_effect{$transcript_id}{$effect_key}
                    && $csq_transcript_effect{$transcript_id}{$effect_key} )
                {

                    ## Increment
                    $vcf_info_csq_key{$effect_key}++;
                }
            }
        }
    }
    close $filehandle;

    ## Check keys found in INFO field
    $log->info( q{Testing vcf INFO fields and presence in header: } . $infile_vcf,
        $NEWLINE x 2 );

  INFO_KEY:
    foreach my $info_key ( keys %vcf_info_key ) {

        ok(
            exists $vcf_header{INFO}{$info_key},
            q{Found both header and line field key for: }
              . $info_key
              . q{ with key count: }
              . $vcf_info_key{$info_key}
        );
    }

  VEP_KEY:
    foreach my $vep_key ( keys %vep_format_field ) {

        ## Alias
        my $vep_key_value = $vcf_info_csq_key{$vep_key};

        if ( not $vep_key_value ) {

            $vep_key_value = 0;
        }

        my @todo_keys = qw{ APPRIS Existing_variation
          HIGH_INF_POS LoF_flags LoF_filter MOTIF_NAME MOTIF_POS
          MOTIF_SCORE_CHANGE REFSEQ_MATCH SOURCE TSL };

        if ( any { $_ eq $vep_key } @todo_keys ) {

            ## This will fail for Appris tcl etc which is only available in Grch38
          TODO: {

                local $TODO = q{Check VEP CSQ currently not produced};

                ok( $vep_key_value, q{Found entry for CSQ field key for: } . $vep_key );
            }
        }
        else {

            ok( $vep_key_value,
                    q{Found entry for CSQ field key for: }
                  . $vep_key
                  . q{ with key count: }
                  . $vep_key_value );
        }
    }
    return;
}

sub read_sv_infile_vcf {

## Function : Reads SV infile in vcf format and adds and parses annotations
## Returns  :
## Arguments: $active_parameter_href => The active parameters for this analysis hash {REF}
##          : $infile_vcf            => Infile
##          : $parameter_href        => The parameter hash {REF}
##          : $vcfparser_data_href   => The keys from vcfParser i.e. range file and select file

    my ($arg_href) = @_;

    ## Flatten argument(s)
    my $active_parameter_href;
    my $infile_vcf;
    my $parameter_href;
    my $vcfparser_data_href;

    my $tmpl = {
        active_parameter_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$active_parameter_href,
            strict_type => 1,
        },
        infile_vcf => {
            defined     => 1,
            required    => 1,
            store       => \$infile_vcf,
            strict_type => 1,
        },
        parameter_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$parameter_href,
            strict_type => 1,
        },
        vcfparser_data_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$vcfparser_data_href,
            strict_type => 1,
        },
    };

    check( $tmpl, $arg_href, 1 ) or croak q{Could not parse arguments!};

    ## Constants
    Readonly my $MAX_LINE_TO_READ => 100_00;

    ## Retrieve logger object now that log_file has been set
    my $log = Log::Log4perl->get_logger(q{Test});

    my $is_csq_found;
    my @vep_format_fields;
    my %vep_format_field;

    # Catch vcf header #CHROM line
    my @vcf_format_columns;
    my %meta_data;
    my %vcf_header;
    my %vcf_info_key;
    my %vcf_info_csq_key;

    $log->info( q{Testing vcf header in file: } . $infile_vcf, $NEWLINE x 2 );

    # Create anonymous filehandle
    my $filehandle = IO::Handle->new();

    ## Read file
    open $filehandle, q{<}, $infile_vcf
      or
      $log->logdie( q{Cannot open} . $SPACE . $infile_vcf . q{:} . $OS_ERROR, $NEWLINE );
  LINE:
    while (<$filehandle>) {

        chomp;

        ## Quit reading
        last LINE if ( $INPUT_LINE_NUMBER > $MAX_LINE_TO_READ );

        # Avoid blank lines
        next LINE if (m/ ^\s+$ /sxm);

        # If meta data
        if (/ ^\#\#\S+= /sxm) {

            my $line = $_;
            parse_meta_data(
                {
                    meta_data_href   => \%meta_data,
                    meta_data_string => $line,
                }
            );

            if (/ INFO\=\<ID\=([^,]+) /sxm) {

                $vcf_header{INFO}{$1} = $1;
            }

            $is_csq_found = check_if_vep_csq_in_line(
                {
                    vep_format_field_href => \%vep_format_field,
                    header_line           => $line,
                }
            );

            if ($is_csq_found) {

                ok(
                    $active_parameter_href->{sv_varianteffectpredictor},
                    q{VEP: CSQ in header and VEP should have been executed}
                );
            }
            next LINE;
        }
        if (/ ^\#CHROM /xsm) {

            # Split vcf format line
            @vcf_format_columns = split $TAB;

            ### Check Header now that we read all

            ## Test vt
            _test_sv_combinevariantcallsets_in_vcf_header(
                {
                    sv_combinevariantcallsets_mode =>
                      $active_parameter_href->{sv_combinevariantcallsets},
                    sv_vt_decompose_mode => $active_parameter_href->{sv_vt_decompose},
                    vcf_header_href      => \%vcf_header,
                }
            );

            ## Test sv_annotate vcf keys
            _test_sv_annotate_in_vcf_header(
                {
                    sv_annotate_mode    => $active_parameter_href->{sv_annotate},
                    sv_frequency_filter => $active_parameter_href->{sv_frequency_filter},
                    vcf_header_href     => \%vcf_header,
                }
            );

            ## Test Frequency filter
            _test_frequency_filter_in_vcf_header(
                {
                    fqf_annotations_ref => $active_parameter_href->{sv_fqa_annotations},
                    recipe_mode         => $active_parameter_href->{sv_annotate},
                    toml_file_path  => $active_parameter_href->{sv_fqa_vcfanno_config},
                    vcf_header_href => \%vcf_header,
                }
            );

            ## Test vcfparser
            _test_vcfparser_in_vcf_header(
                {
                    vcf_header_href     => \%vcf_header,
                    vcfparser_data_href => $vcfparser_data_href,
                    vcfparser_mode      => $active_parameter_href->{sv_vcfparser},
                }
            );

            ## Test Rankvariants
            _test_rankvariants_in_vcf_header(
                {
                    rankvariant_mode       => $active_parameter_href->{sv_rankvariant},
                    sample_ids_ref         => \@{ $active_parameter_href->{sample_ids} },
                    unaffected_samples_ref => \@{ $parameter_href->{cache}{unaffected} },
                    vcf_header_href        => \%vcf_header,
                }
            );

            next LINE;
        }

        ## VCF body lines
        my %vcf_record =
          parse_vcf_line( { vcf_format_columns_ref => \@vcf_format_columns, } );

        ## Count incedence of keys
      INFO_KEY:
        foreach my $info_key ( keys %{ $vcf_record{INFO_key_value} } ) {

            ## Increment
            $vcf_info_key{$info_key}++;
        }

        my %csq_transcript_effect = parse_vep_csq_info(
            {
                vcf_record_href       => \%vcf_record,
                vcf_info_csq_key_href => \%vcf_info_csq_key,
                vep_format_field_href => \%vep_format_field,
            }
        );

        ## Sum all CSQ vcf transcript effect keys
      TRANSCRIPT_ID:
        foreach my $transcript_id ( keys %csq_transcript_effect ) {

          CSQ_TRANSCRIPT_EFFECTS:
            while ( my ( $effect_key, $effect_value ) = each %vep_format_field ) {

                if ( exists $csq_transcript_effect{$transcript_id}{$effect_key}
                    && $csq_transcript_effect{$transcript_id}{$effect_key} )
                {

                    ## Increment
                    $vcf_info_csq_key{$effect_key}++;
                }
            }
        }
    }
    close $filehandle;

    ## Check keys found in INFO field
    $log->info( q{Testing vcf INFO fields and presence in header: } . $infile_vcf,
        $NEWLINE x 2 );

  INFO_KEY:
    foreach my $info_key ( keys %vcf_info_key ) {

        ok(
            exists $vcf_header{INFO}{$info_key},
            q{Found both header and line field key for: }
              . $info_key
              . q{ with key count: }
              . $vcf_info_key{$info_key}
        );
    }

  VEP_KEY:
    foreach my $vep_key ( keys %vep_format_field ) {

        ## Alias
        my $vep_key_value = $vcf_info_csq_key{$vep_key};

        if ( not $vep_key_value ) {

            $vep_key_value = 0;
        }

        my @todo_keys = qw{ APPRIS Codons DOMAINS Existing_variation HIGH_INF_POS
          HGVSp Amino_acids LoF_flags LoF_filter MOTIF_NAME MOTIF_POS
          MOTIF_SCORE_CHANGE REFSEQ_MATCH SOURCE TSL };

        if ( any { $_ eq $vep_key } @todo_keys ) {

            ## This will fail for Appris tcl etc which is only available in Grch38
          TODO: {

                local $TODO = q{Check VEP CSQ currently not produced};

                ok( $vep_key_value, q{Found entry for CSQ field key for: } . $vep_key );
            }
        }
        else {

            ok( $vep_key_value,
                    q{Found entry for CSQ field key for: }
                  . $vep_key
                  . q{ with key count: }
                  . $vep_key_value );
        }
    }
    return;
}

sub parse_vcf_line {

## Function : Add each element to a key in vcf_record hash
## Returns  :
## Arguments: $vcf_format_columns_ref => Array ref description {REF}

    my ($arg_href) = @_;

    ## Flatten argument(s)
    my $vcf_format_columns_ref;

    my $tmpl = {
        vcf_format_columns_ref => {
            default     => [],
            defined     => 1,
            required    => 1,
            store       => \$vcf_format_columns_ref,
            strict_type => 1,
        },
    };

    check( $tmpl, $arg_href, 1 ) or croak q{Could not parse arguments!};

    ## VCF body lines
    my %vcf_record;

    # Loads vcf elements
    my @line_elements = split $TAB;

    ##Add line elements to vcf_record hash
  LINE:
    while ( my ( $element_index, $element ) = each @line_elements ) {

        ## Link vcf format headers to the line elements
        $vcf_record{ $vcf_format_columns_ref->[$element_index] } = $element;
    }

    # Split INFO field to key=value items
    my @info_elements = split $SEMICOLON, $vcf_record{INFO};

    ## Add INFO to vcf_record hash as separate key
  INFO:
    for my $element (@info_elements) {

        ## key index = 0 and value index = 1
        my @key_value_pairs = split /=/xsm, $element;

        $vcf_record{INFO_key_value}{ $key_value_pairs[0] } =
          $key_value_pairs[1];
    }
    return %vcf_record;
}

sub read_range_file {

## Function : Reads a file containg features to be annotated using range queries e.g. EnsemblGeneID.
## Returns  :
## Arguments: $infile_path                    => Infile path
##          : $range_file_key                 => Range file key used to seperate range file(s) i.e., select and range
##          : $range_coulumns_ref             => Range columns to include {REF}
##          : $vcfparser_data_href            => Range file hash {REF}

    my ($arg_href) = @_;

    ## Flatten argument(s)
    my $infile_path;
    my $range_coulumns_ref;
    my $range_file_key;
    my $vcfparser_data_href;

    my $tmpl = {
        infile_path => {
            defined     => 1,
            required    => 1,
            store       => \$infile_path,
            strict_type => 1,
        },
        range_coulumns_ref => {
            default     => [],
            defined     => 1,
            required    => 1,
            store       => \$range_coulumns_ref,
            strict_type => 1,
        },
        range_file_key => {
            defined     => 1,
            required    => 1,
            store       => \$range_file_key,
            strict_type => 1,
        },
        vcfparser_data_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$vcfparser_data_href,
            strict_type => 1,
        },
    };

    check( $tmpl, $arg_href, 1 ) or croak q{Could not parse arguments!};

    ## Constants
    Readonly my $MAX_RANGE_COLUMNS => scalar @{$range_coulumns_ref} - 1;

    ## Retrieve logger object now that log_file has been set
    my $log = Log::Log4perl->get_logger(q{Test});

    ## Save headers from rangeFile
    my @headers;

    ## Create anonymous filehandle
    my $filehandle = IO::Handle->new();

    ## Read file
    open $filehandle, q{<}, $infile_path
      or
      $log->logdie( q{Cannot open} . $SPACE . $infile_path . q{:} . $OS_ERROR, $NEWLINE );

  LINE:
    while (<$filehandle>) {

        chomp;

        ## Unpack line
        my $line = $_;

        ## Skip blank lines
        next LINE if ( $line =~ /^\s+$/sxm );

        ## Header meta data
        next LINE if ( $line =~ /\A [#]{2}/sxm );

        if ( $line =~ /\A [#]{1}CHROM/sxm ) {

            @headers = split $TAB;

            ## Defines what scalar to store
          COLUMNS:
            for my $extract_columns_counter ( 0 .. $MAX_RANGE_COLUMNS ) {

                my $header_key_ref =
                  \$headers[ $range_coulumns_ref->[$extract_columns_counter] ];

                ## Column position in supplied range input file
                $vcfparser_data_href->{ ${$header_key_ref} } = $extract_columns_counter;
            }
            next LINE;
        }
    }
    close $filehandle;
    $log->info( q{Finished reading } . $range_file_key . q{ file: } . $infile_path,
        $NEWLINE );
    return;
}

sub parse_meta_data {

## Function : Writes metadata to filehandle specified by order in meta_data_orders.
## Returns  :
## Arguments: $meta_data_href   => Hash for meta_data {REF}
##          : $meta_data_string => The meta_data string from vcf header

    my ($arg_href) = @_;

    ## Flatten argument(s)
    my $meta_data_href;
    my $meta_data_string;

    my $tmpl = {
        meta_data_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$meta_data_href,
            strict_type => 1,
        },
        meta_data_string => {
            defined     => 1,
            required    => 1,
            store       => \$meta_data_string,
            strict_type => 1,
        },
    };

    check( $tmpl, $arg_href, 1 ) or croak q{Could not parse arguments!};

    ## Catch fileformat as it has to be at the top of header
    if ( $meta_data_string =~ / ^\#\#fileformat /sxm ) {

        ## Save metadata string
        push
          @{ $meta_data_href->{fileformat}{fileformat} },
          $meta_data_string;
    }
    elsif ( $meta_data_string =~ / ^\#\#contig /sxm ) {
        ## Catch contigs to not sort them later

        ## Save metadata string
        push @{ $meta_data_href->{contig}{contig} }, $meta_data_string;
    }
    elsif ( $meta_data_string =~ / ^\#\#(\w+)=(\S+) /sxm ) {
        ## FILTER, FORMAT, INFO etc and more custom records

        ## Save metadata string
        push @{ $meta_data_href->{$1}{$2} }, $meta_data_string;
    }
    else {
        #All oddities

        ## Save metadata string
        push @{ $meta_data_href->{other}{other} }, $meta_data_string;
    }
    return;
}

sub check_if_vep_csq_in_line {

## Function : Check if the header line contains VEPs CSQ field
## Returns  :

## Arguments: $header_line           => Header line
##          : $vep_format_field_href => Hash ref description {REF}

    my ($arg_href) = @_;

    ## Flatten argument(s)
    my $header_line;
    my $vep_format_field_href;

    my $tmpl = {
        header_line => {
            defined     => 1,
            required    => 1,
            store       => \$header_line,
            strict_type => 1,
        },
        vep_format_field_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$vep_format_field_href,
            strict_type => 1,
        },
    };

    check( $tmpl, $arg_href, 1 ) or croak q{Could not parse arguments!};

    # Find VEP CSQ INFO field
    if ( $header_line =~ / INFO\=\<ID\=CSQ /sxm ) {

        # Locate Format within VEP INFO meta line
        if (/ Format:\s(\S+)"\> /sxm) {

            my $vep_format_string = $1;
            my @vep_format_fields = split /[|]/sxm, $vep_format_string;

            while ( my ( $field_index, $field ) = each @vep_format_fields ) {

                # Save the order of VEP features key => index
                $vep_format_field_href->{$field} = $field_index;
            }
        }
        ## Found CSQ line
        return 1;
    }
    return;
}

sub _test_sv_annotate_in_vcf_header {

## Function : Test if sv_annotate info keys are present in vcf header
## Returns  :
## Arguments: $sv_annotate_mode    => sv_annotate has been used or not
##          : $sv_frequency_filter => Frequency filter has been used or not
##          : $vcf_header_href     => Vcf header info

    my ($arg_href) = @_;

    ## Flatten argument(s)
    my $sv_annotate_mode;
    my $sv_frequency_filter;
    my $vcf_header_href;

    my $tmpl = {
        sv_annotate_mode => {
            allow       => qr{ \A\d+\z }sxm,
            required    => 1,
            store       => \$sv_annotate_mode,
            strict_type => 1,
        },
        sv_frequency_filter => {
            allow       => qr{ \A\d+\z }sxm,
            defined     => 1,
            required    => 1,
            store       => \$sv_frequency_filter,
            strict_type => 1,
        },
        vcf_header_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$vcf_header_href,
            strict_type => 1,
        },
    };

    check( $tmpl, $arg_href, 1 ) or croak q{Could not parse arguments!};

    ## sv_annotate has been used
    return if ( not $sv_annotate_mode );

    return if ( not $sv_frequency_filter );

    ok( defined $vcf_header_href->{INFO}{q{clinical_genomics_mipAF}},
        q{Svdb filter: clinical_genomics_mipAF key} );
    return;
}

sub _test_sv_combinevariantcallsets_in_vcf_header {

## Function : Test if sv_combinevariantcallsets info keys are present in vcf header
## Returns  :
## Arguments: $sv_combinevariantcallsets_mode => sv_combinevariantcallsets has been used or not
##          : $vcf_header_href                => Vcf header info
##          : $sv_vt_decompose_mode           => Vt decompose has been used or not

    my ($arg_href) = @_;

    ## Flatten argument(s)
    my $sv_vt_decompose_mode;
    my $vcf_header_href;
    my $sv_combinevariantcallsets_mode;

    my $tmpl = {
        vcf_header_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$vcf_header_href,
            strict_type => 1,
        },
        sv_combinevariantcallsets_mode => {
            allow       => [ undef, qr{ \A\d+\z }sxm, ],
            required    => 1,
            store       => \$sv_combinevariantcallsets_mode,
            strict_type => 1,
        },
        sv_vt_decompose_mode => {
            allow       => [ undef, qr{ \A\d+\z }sxm, ],
            required    => 1,
            store       => \$sv_vt_decompose_mode,
            strict_type => 1,
        },
    };

    check( $tmpl, $arg_href, 1 ) or croak q{Could not parse arguments!};

    ## sv_combinevariantcallset has been used
    return if ( not $sv_combinevariantcallsets_mode );

    return if ( not $sv_vt_decompose_mode );

    ok( exists $vcf_header_href->{INFO}{OLD_MULTIALLELIC},
        q{VTDecompose key: OLD_MULTIALLELIC} );

    return;
}

sub _test_vt_in_vcf_header {

## Function : Test if vt info keys are present in vcf header
## Returns  :
## Arguments: $vt_decompose_mode => Vt decompose has been used or not
##          : $vcf_header_href   => Vcf header info
##          : $vt_mode           => Vt has been used or not
##          : $vt_normalize_mode => Vt normalize has been used or not

    my ($arg_href) = @_;

    ## Flatten argument(s)
    my $vt_decompose_mode;
    my $vcf_header_href;
    my $vt_mode;
    my $vt_normalize_mode;

    my $tmpl = {
        vcf_header_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$vcf_header_href,
            strict_type => 1,
        },
        vt_mode => {
            allow       => qr{ \A\d+\z }sxm,
            defined     => 1,
            required    => 1,
            store       => \$vt_mode,
            strict_type => 1,
        },
        vt_decompose_mode => {
            allow       => qr{ \A\d+\z }sxm,
            defined     => 1,
            required    => 1,
            store       => \$vt_decompose_mode,
            strict_type => 1,
        },
        vt_normalize_mode => {
            allow       => qr{ \A\d+\z }sxm,
            defined     => 1,
            required    => 1,
            store       => \$vt_normalize_mode,
            strict_type => 1,
        },
    };

    check( $tmpl, $arg_href, 1 ) or croak q{Could not parse arguments!};

    ## VT has been used
    return if ( not $vt_mode );

    if ($vt_decompose_mode) {

        ok( exists $vcf_header_href->{INFO}{OLD_MULTIALLELIC},
            q{VTDecompose key: OLD_MULTIALLELIC} );
    }
    if ($vt_normalize_mode) {

        ok( exists $vcf_header_href->{INFO}{OLD_VARIANT},
            q{VTNormalize key: OLD_VARIANT} );
    }
    return;
}

sub _test_frequency_filter_in_vcf_header {

## Function : Test if freuqency filter info keys are present in vcf header
## Returns  :
## Arguments: $fqf_annotations_ref => Frequency annotation to use in filtering
##          : $recipe_mode         => Frequency filter has been used or not for recipe
##          : $toml_file_path      => Toml config file path
##          : $vcf_header_href     => Vcf header info

    my ($arg_href) = @_;

    ## Flatten argument(s)
    my $fqf_annotations_ref;
    my $recipe_mode;
    my $toml_file_path;
    my $vcf_header_href;

    my $tmpl = {
        fqf_annotations_ref => {
            default     => [],
            defined     => 1,
            required    => 1,
            store       => \$fqf_annotations_ref,
            strict_type => 1,
        },
        recipe_mode => {
            allow       => qr{ \A\d+\z }sxm,
            defined     => 1,
            required    => 1,
            store       => \$recipe_mode,
            strict_type => 1,
        },
        toml_file_path => {
            default     => 1,
            store       => \$toml_file_path,
            strict_type => 1,
        },
        vcf_header_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$vcf_header_href,
            strict_type => 1,
        },
    };

    check( $tmpl, $arg_href, 1 ) or croak q{Could not parse arguments!};

    use Array::Utils qw{ intersect };
    use MIP::Io::Read qw{ read_from_file };

    my %vcfanno_config = read_from_file(
        {
            format => q{toml},
            path   => $toml_file_path,
        }
    );

    ## Frequency filter has been used for recipe
    return if ( not $recipe_mode );

  ANNOTATION:
    foreach my $annotation_href ( @{ $vcfanno_config{annotation} } ) {

        ## Limit to requested frequency annotations
        my @frequency_annotations =
          intersect( @{$fqf_annotations_ref}, @{ $annotation_href->{names} } );

        next ANNOTATION if ( not @frequency_annotations );

      VCF_KEY:
        foreach my $vcf_annotation (@frequency_annotations) {

            ok(
                defined $vcf_header_href->{INFO}{$vcf_annotation},
                q{Frequency filter: } . $vcf_annotation . q{ key}
            );
        }
    }
    return;
}

sub _test_vcfparser_in_vcf_header {

## Function : Test if vcfparser info keys are present in vcf header
## Returns  :
## Arguments: $vcfparser_data_href => Vcfparser keys hash {REF}
##          : $vcfparser_mode      => Vcfparser_Mode description
##          : $vcf_header_href     => Vcf header info {REF}

    my ($arg_href) = @_;

    ## Flatten argument(s)
    my $vcfparser_data_href;
    my $vcfparser_mode;
    my $vcf_header_href;

    my $tmpl = {
        vcfparser_data_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$vcfparser_data_href,
            strict_type => 1,
        },
        vcfparser_mode => {
            allow       => qr{ \A\d+\z }sxm,
            defined     => 1,
            required    => 1,
            store       => \$vcfparser_mode,
            strict_type => 1,
        },
        vcf_header_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$vcf_header_href,
            strict_type => 1,
        },
    };

    check( $tmpl, $arg_href, 1 ) or croak q{Could not parse arguments!};

    return if ( not $vcfparser_mode );

  VCFPARSER_KEY:
    for my $vcfparser_key ( keys %{$vcfparser_data_href} ) {

        ok( defined $vcf_header_href->{INFO}{$vcfparser_key},
            q{Vcfparser key: } . $vcfparser_key );
    }

    ## Keys from vcfparser.pl that are dynamically created from parsing the data
    my @vcfparser_dynamic_keys = qw{ most_severe_consequence };

  DYNAMIC_KEY:
    foreach my $dynamic_key (@vcfparser_dynamic_keys) {

        ok(
            defined $vcf_header_href->{INFO}{$dynamic_key},
            q{Vcfparser dynamic keys: } . $dynamic_key
        );
    }
    return;
}

sub _test_rankvariants_in_vcf_header {

## Function : Test if rankvariants info keys are present in vcf header
## Returns  :
## Arguments: $genmod_annotate_cadd_files_ref => Cadd files annotate via genmod
##          : $rankvariant_mode               => Rankvariant_Mode description
##          : $sample_ids_ref                 => Array ref description {REF}
##          : $spidex_file                    => Spidex file
##          : $unaffected_samples_ref         => Number of unaffected individuals in analysis
##          : $vcf_header_href                => Vcf header info {REF}

    my ($arg_href) = @_;

    ## Flatten argument(s)
    my $genmod_annotate_cadd_files_ref;
    my $rankvariant_mode;
    my $sample_ids_ref;
    my $spidex_file;
    my $unaffected_samples_ref;
    my $vcf_header_href;

    my $tmpl = {
        genmod_annotate_cadd_files_ref => {
            default     => [],
            store       => \$genmod_annotate_cadd_files_ref,
            strict_type => 1,
        },
        rankvariant_mode => {
            allow       => qr{ \A\d+\z }sxm,
            defined     => 1,
            required    => 1,
            store       => \$rankvariant_mode,
            strict_type => 1,
        },
        sample_ids_ref => {
            default     => [],
            defined     => 1,
            required    => 1,
            store       => \$sample_ids_ref,
            strict_type => 1,
        },
        spidex_file => {
            store       => \$spidex_file,
            strict_type => 1,
        },
        vcf_header_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$vcf_header_href,
            strict_type => 1,
        },
        unaffected_samples_ref => {
            default     => [],
            defined     => 1,
            required    => 1,
            store       => \$unaffected_samples_ref,
            strict_type => 1,
        },
    };

    check( $tmpl, $arg_href, 1 ) or croak q{Could not parse arguments!};

    return if ( not $rankvariant_mode );

    ## Keys from genmod
    my @genmod_keys = qw{ Compounds RankScore ModelScore
      GeneticModels };

    ## Only unaffected - undef genmod keys
    if (   @{$unaffected_samples_ref}
        && @{$unaffected_samples_ref} eq @{$sample_ids_ref} )
    {
        undef @genmod_keys;
    }

  GENMOD_KEY:
    foreach my $genmod_key (@genmod_keys) {

        ok( defined $vcf_header_href->{INFO}{$genmod_key}, q{Genmod: } . $genmod_key );
    }

    ## Spidex key from genmodAnnotate
    if ($spidex_file) {

        ok( defined $vcf_header_href->{INFO}{SPIDEX}, q{Genmod annotate: SPIDEX key} );
    }
    ## CADD key from genmodAnnotate
    if ( @{$genmod_annotate_cadd_files_ref} ) {

        ok( defined $vcf_header_href->{INFO}{CADD}, q{Genmod annotate: CADD key} );
    }
    return;
}

sub parse_vep_csq_info {

## Function : Parse the VEP CSQ field
## Returns  :
## Arguments: $vep_format_field_href => VEP format field column {REF}
##          : $vcf_info_csq_key_href => Vcf info csq key hash {REF}
##          : $vcf_record_href       => Hash ref description {REF}

    my ($arg_href) = @_;

    ## Flatten argument(s)
    my $vep_format_field_href;
    my $vcf_info_csq_key_href;
    my $vcf_record_href;

    my $tmpl = {
        vep_format_field_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$vep_format_field_href,
            strict_type => 1,
        },
        vcf_info_csq_key_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$vcf_info_csq_key_href,
            strict_type => 1,
        },
        vcf_record_href => {
            default     => {},
            defined     => 1,
            required    => 1,
            store       => \$vcf_record_href,
            strict_type => 1,
        },
    };

    check( $tmpl, $arg_href, 1 ) or croak q{Could not parse arguments!};

    return if ( not exists $vcf_record_href->{INFO_key_value}{CSQ} );

    my %csq_transcript_effect;

    ## VEP map
    my %vep_format_field_index = reverse %{$vep_format_field_href};

    ## Split into transcripts
    my @transcripts = split $COMMA, $vcf_record_href->{INFO_key_value}{CSQ};

  CSQ_TRANSCRIPT:
    while ( my ( $transcript_index, $transcript ) = each @transcripts ) {

        my @transcript_effects = split /[|]/sxm, $transcript;

      TRANCRIP_EFFECT:
        while ( my ( $effect_index, $effect ) = each @transcript_effects ) {

            if ( exists $vep_format_field_index{$effect_index} ) {

                ## Alias
                my $vep_format_key_ref = \$vep_format_field_index{$effect_index};
                $csq_transcript_effect{$transcript_index}{ ${$vep_format_key_ref} } =
                  $effect;
            }
        }
    }
    return %csq_transcript_effect;
}

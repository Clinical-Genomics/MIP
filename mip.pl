#!/usr/bin/env perl

###Master script for analysing paired end reads from the Illumina plattform in fastq(.gz) format to annotated ranked disease causing variants. The program performs QC, aligns reads using Mosaik or BWA, performs variant discovery and annotation as well as ranking the found variants according to disease potential.
 
###Copyright 2011 Henrik Stranneheim

use v5.18;  #Require at least perl 5.18
use Modern::Perl '2014';
use autodie qw(open close :all);

##Unicode boilerplate
use warnings qw( FATAL utf8 );
use utf8;  #Allow unicode characters in this script
use open qw( :encoding(UTF-8) :std );
use charnames qw( :full :short );


use Getopt::Long;
use POSIX;
use Params::Check qw[check allow last_error];
$Params::Check::PRESERVE_CASE = 1;  #Do not convert to lower case
use Cwd 'abs_path';  #Export absolute path function
use FindBin qw($Bin);  #Find directory of script
use File::Basename qw(dirname);
use File::Spec::Functions qw(catdir catfile devnull);
use File::Path qw(make_path);
use File::Copy qw(copy);
use Cwd;
use IPC::Cmd qw[can_run run];
use IPC::System::Simple;  #Required for autodie :all
use vars qw($USAGE);
use List::Util qw(any);
use Time::Piece;

## Third party module(s)
use YAML;
use Log::Log4perl;
use Path::Iterator::Rule;


BEGIN {


    my @modules = ("YAML", "Log::Log4perl", "Path::Iterator::Rule");	

    ## Evaluate that all modules required are installed
    &EvalModules({modulesArrayRef => \@modules,
		 });
    
    $USAGE =
	qq{
mip.pl  -ifd [inFilesDirs,.,.,.,n] -isd [inScriptDir,.,.,.,n] -rd [refdir] -p [project ID] -s [sample ID,.,.,.,n] -em [e-mail] -osd [outdirscripts] -odd [outDataDir] -f [familyID] -p[program]
               ####MIP
               -ifd/--inFilesDirs Infile directory(s) (comma sep; mandatory)
               -isd/--inScriptDir The pipeline custom script in directory (mandatory)
               -rd/--referencesDir Reference(s) directory (mandatory)
               -p/--projectID The project ID  (mandatory)
               -s/--sampleIDs The sample ID(s)(comma sep; mandatory)
               -em/--email E-mail (defaults to "")
               -emt/--emailType E-mail type (defaults to F (=FAIL);Options: B (=BEGIN) and/or F (=FAIL) and/or E=(END))
               -odd/--outDataDir The data files output directory (mandatory)
               -osd/--outScriptDir The script files (.sh) output directory (mandatory)
               -f/--familyID Group id of samples to be compared (defaults to "", (Ex: 1 for IDN 1-1-1A))
               -ped/--pedigreeFile (defaults to "")
               -hgr/--humanGenomeReference Fasta file for the human genome reference (defaults to "Homo_sapiens.GRCh37.d5.fasta;1000G decoy version 5")
               -ald/--alignerOutDir Setting which aligner out directory was used for alignment in previous analysis (defaults to "{outDataDir}{ {aligner}{outDirectoryName} }")
               -at/--analysisType Type of analysis to perform (defaults to "genomes";Valid entries: "genomes", "exomes", "rapid")
               -pl/--platForm Platform/technology used to produce the reads (defaults to "ILLUMINA")
               -mc/--maximumCores The maximum number of cores per node used in the analysis (defaults to "8")
               -c/--configFile YAML config file for script parameters (defaults to "")
               -ccp/--clusterConstantPath Set the cluster constant path (defaults to "")
               -acp/--analysisConstantPath Set the analysis constant path (defaults to "analysis")
               -wc/--writeConfigFile Write YAML configuration file for script parameters (defaults to "")
               -int/--instanceTag Tag family with instance association in sampleInfo file (comma sep; defaults to "")
               -rea/--researchEthicalApproval Tag for displaying research candidates in Scout (defaults to "notApproved")
               -sif/--sampleInfoFile YAML file for sample info used in the analysis (defaults to "{outDataDir}/{familyID}/{familyID}_qc_sampleInfo.yaml")
               -dra/--dryRunAll Sets all programs to dry run mode i.e. no sbatch submission (defaults to "0" (=no))
               -tmd/--tempDirectory Set the temporary directory for all programs (defaults to "/scratch/SLURM_JOB_ID";supply whole path)
               -jul/--javaUseLargePages Use large page memory. (defaults to "0" (=no))
               -nrm/--nodeRamMemory The RAM memory size of the node(s) in GigaBytes (Defaults to 24)
               -sen/--sourceEnvironmentCommand Source environment command in sbatch scripts (defaults to "")

               -ges/--genomicSet Selection of relevant regions post alignment (Format=sorted BED; defaults to "")
               -rio/--reduceIO Run consecutive models at nodes (defaults to "0" (=no))
               -riu/--replaceIUPAC Replace IUPAC code in alternative alleles with N (defaults to "0" (=no))
               -pp/--printProgram Print all programs that are supported
               -ppm/--printProgramMode Print all programs that are supported in: 0 (off mode), 1 (on mode), 2 (dry run mode; defaults to "2")
               -l/--logFile Mip log file (defaults to "{outDataDir}/{familyID}/mip_log/{date}/{scriptname}_{timestamp}.log")
               -h/--help Display this help message    
               -v/--version Display version of MIP            
               
               ####Programs
               -pGZ/--pGZipFastq GZip fastq files (defaults to "1" (=yes))
               -pFqC/--pFastQC Sequence quality analysis using FastQC (defaults to "1" (=yes))
               -pMaD/--pMadeline Pedigree drawing engine (defaults to "0" (=no))

               ##Mosaik
               -pMoB/--pMosaikBuild  Convert reads to Mosaik format using MosaikBuild (defaults to "1" (=yes))
                -mobmfl/--mosaikBuildMedianFragLength Flag for setting the mean fragment length, mfl, (defaults to (=375) bp)
               -pMoA/--pMosaikAlign Align reads using MosaikAlign (defaults to "1" (=yes))
                 -moaref/--mosaikAlignReference MosaikAlign reference (defaults to "{humanGenomeReference}")
                 -moaape/--mosaikAlignNeuralNetworkPeFile MosaikAlign Neural Network PE File (defaults to "2.1.78.pe.ann")
                 -moaase/--mosaikAlignNeuralNetworkSeFile MosaikAlign Neural Network SE File (defaults to "2.1.78.se.ann")
                 -mojdb/--mosaikJumpDbStub MosaikJump stub (defaults to "{humanGenomeReference}")
               
               ##BWA
               -pMem/--pBwaMem Align reads using BWA Mem (defaults to "0" (=no))
                 -memhla/--bwaMemHLA Apply HLA typing (defaults to "1" (=yes))
                 -memrdb/--bwaMemRapidDb Selection of relevant regions post alignment (defaults to "")
                 -memcrm/--bwaMemCram Use CRAM-format for output (defaults to "1" (=yes))
                 -memsts/--bwaMembamStats Collect statistics from BAM files (defaults to "1" (=yes))
                 -memssm/--bwaSambambaSortMemoryLimit Set the memory limit for Sambamba sort after bwa alignment (defaults to "32G")
               -pAln/--pBwaAln Index reads using BWA Aln (defaults to "0" (=no))
                 -alnq/--bwaAlnQualityTrimming BWA Aln quality threshold for read trimming (defaults to "20")
               -pSap/--pBwaSampe Align reads using BWA Sampe (defaults to "0" (=no))
               
               ##PicardTools
               -ptp/--picardToolsPath Path to PicardTools. Mandatory for use of PicardTools (defaults to "")
               -pPtM/--pPicardToolsMergeSamFiles Merge (BAM file(s) ) using PicardTools MergeSamFiles or rename single samples for downstream processing (Mandatory)
                 -ptmp/--picardToolsMergeSamFilesPrevious PicardTools MergeSamFiles on merged current files and previous BAM-file(s) (supply whole path and name, name must contain sample id, and lanes_Xn info)
               -pPtMR/--pPicardToolsMergeRapidReads Merge Read batch processed (BAM file(s)) using PicardTools MergeSamFiles (Only relevant in rapid mode;defaults to "0" (=no))

               ##MarkDuplicates
               -pPmD/--pPicardToolsMarkduplicates Markduplicates using PicardTools Markduplicates (defaults to "1" (=yes))
               -pSmD/--pSambambaMarkduplicates Markduplicates using Sambamba Markduplicates (defaults to "0" (=yes))
                 -smdhts/--sambambaMarkDupHashTableSize Sambamba size of hash table for finding read pairs (defaults to "500000")
                 -smdols/--sambambaMarkDupOverflowListSize Sambamba size of the overflow list (defaults to "500000")
                 -smdibs/--sambambaMarkDupIoBufferSize Sambamba size of the io buffer for reading and writing BAM during the second pass (defaults to "2048")

               ###CoverageCalculations
               -pChS/--pChanjoSexCheck Predicts gender from sex chromosome coverage (defaults to "1")
               -pSdT/--pSambambaDepth Sambamba depth coverage analysis (defaults to "1" (=yes))
                 -sdtcut/--sambambaDepthCutOffs Read depth cutoff (comma sep; defaults to "10", "20", "30", "50", "100")
                 -sdtbed/--sambambaDepthBed Reference database (defaults to "CCDS.current.bed")
                 -sdtbaq/--sambambaDepthBaseQuality Do not count bases with lower base quality (defaults to "10")
                 -stdmaq/--sambambaDepthMappingQuality  Do not count reads with lower mapping quality (defaults to "10")
                 -stdndu/--sambambaDepthNoDuplicates Do not include duplicates in coverage calculation (defaults to "1" (=yes))
                 -stdfqc/--sambambaDepthNoFailedQualityControl Do not include reads with failed quality control (defaults to "1" (=yes))
               -pGcB/--pGenomeCoverageBED Genome coverage calculation using genomeCoverageBED (defaults to "0" (=no))
                -gcbcov/--GenomeCoverageBEDMaxCoverage Max coverage depth when using '-pGenomeCoverageBED' (defaults to "30")
               -pPtCMM/--pPicardToolsCollectMultipleMetrics Metrics calculation using PicardTools collectMultipleMetrics (defaults to "1" (=yes))
               -pPtCHS/--pPicardToolsCalculateHSMetrics Capture calculation using PicardTools CalculateHSmetrics (defaults to "1" (=yes))
                 -extb/--exomeTargetBed Exome target bed file per sampleID (defaults to "latest_supported_capturekit.bed"; -extb file.bed=SampleIDX,SampleIDY -extb file.bed=SampleIDZ) 
               -pRcP/--pRCovPlots Plots of genome coverage using rCovPlots (defaults to "1" (=yes))

               ###Structural Variant Callers
               -pCnv/--pCNVnator Structural variant calling using CNVnator (defaults to "1" (=yes))
                 -cnvhbs/--cnvBinSize CNVnator bin size (defaults to "1000")
               -pDel/--pDelly Structural variant calling using Delly (defaults to "1" (=yes))
                 -deltyp/--dellyType Type of SV to call (defaults to "DEL,DUP,INV,TRA"; comma sep)
               -pMna/--pManta Structural variant calling using Manta (defaults to "1" (=yes))
               -pFit/--pFindTranslocations Structural variant calling using FT (defaults to "0" (=no))
                 -fitmsp/--findTranslocationsMinimumSuppotingPairs The minimum number of supporting reads (defaults to "6")
               -pSvC/--pSVCombineVariantCallSets Combine variant call sets (defaults to "1" (=yes))
                 -svcvtd/--svVTDecompose Split multi allelic records into single records (defaults to "1" (=yes))
                 -svcbtv/--svBcfToolsViewFilter Include structural variants with PASS in FILTER column (defaults to "1" (=yes))
                 -svcvan/--svVCFAnno Annotate structural variants (defaults to "1" (=yes)
                 -svcval/--svVCFAnnoLua vcfAnno lua postscripting file (defaults to "")
                 -svcvac/--svVCFAnnoConfig vcfAnno toml config (defaults to "")
                 -svcvah/--svVCFAnnotationHeaderLinesFile Adjust for postscript by adding required header lines to vcf (defaults to "")
                 -svcgmf/--svGenmodFilter Remove common structural variants from vcf (defaults to "1" (=yes))
                 -svcgfr/--svGenmodFilter1000G Genmod annotate structural variants from 1000G reference (defaults to "ALL.wgs.phase3_shapeit2_mvncall_integrated_v5b.20130502.sites.vcf.gz")
                 -svcgft/--svGenmodFilterThreshold Threshold for filtering structural variants (defaults to "0.10")
                 -svcbcf/--svCombineVariantCallSetsBCFFile Produce a bcf from the combineStructuralVariantCallSet vcf (defaults to "1" (=yes))
               -pSvv/--pSVVariantEffectPredictor Annotate SV variants using VEP (defaults to "1" (=yes))
               -svvepf/--svVepFeatures VEP features (defaults to ("hgvs","symbol","numbers","sift","polyphen","humdiv","domains","protein","ccds","uniprot","biotype","regulatory", "tsl", "canonical", "per_gene", "appris"); comma sep)
               -svveppl/--svVepPlugins VEP plugins (defaults to ("UpDownDistance, LoFtool, LoF"); comma sep)
               -pSVVcP/--pSVVCFParser Parse structural variants using vcfParser.pl (defaults to "1" (=yes))
                 -svvcpvt/--svVcfParserVepTranscripts Parse VEP transcript specific entries (defaults to "0" (=no))
                 -svvcprff/--svVcfParserRangeFeatureFile Range annotations file (defaults to ""; tab-sep)
                 -svvcprfa/--svVcfParserRangeFeatureAnnotationColumns Range annotations feature columns (defaults to ""; comma sep)
                 -svvcpsf/--svVcfParserSelectFile File containging list of genes to analyse seperately (defaults to "";tab-sep file and HGNC Symbol required)
                 -svvcpsfm/--svVcfParserSelectFileMatchingColumn Position of HGNC Symbol column in SelectFile (defaults to "")
                 -svvcpsfa/--svVcfParserSelectFeatureAnnotationColumns Feature columns to use in annotation (defaults to ""; comma sep)
               -pSvR/--pSVRankVariants Ranking of annotated SV variants (defaults to "1" (=yes))
                 -svravgft/--svGenmodModelsFamilyType Use one of the known setups (defaults to "mip")
                 -svravwg/--svWholeGene Allow compound pairs in intronic regions (defaults to "0" (=yes))
                 -svravrpf/--svGenmodModelsReducedPenetranceFile File containg genes with reduced penetrance (defaults to "")
                 -svravrm/--svRankModelFile Rank model config file (defaults to "")
                 -svravbcf/--svRankVariantsBCFFile Produce bcfs from the Rank variants vcfs (defaults to "1" (=yes))
               
               ##Samtools
               -pSmp/--pSamToolsMpileUp Variant calling using samTools mpileup and bcfTools (defaults to "1" (=yes))

               ##Freebayes
               -pFrb/--pFreebayes Variant calling using Freebayes and bcfTools (defaults to "1" (=yes))

               ##GATK              
               -gtp/--genomeAnalysisToolKitPath  Path to GATK. Mandatory for use of GATK (defaults to "")
               -gbdv/--GATKBundleDownLoadVersion  GATK FTP bundle download version.(defaults to "2.8")
               -gdco/--GATKDownSampleToCoverage Coverage to downsample to at any given locus (defaults to "1000")
               -pGrA/--pGATKRealigner Realignments of reads using GATK realign (defaults to "1" (=yes))
                 -graks/--GATKReAlignerINDELKnownSite GATK ReAlignerTargetCreator/IndelRealigner known INDEL site (defaults to "1000G_phase1.indels.b37.vcf", "Mills_and_1000G_gold_standard.indels.b37.vcf")
               -pGbR/--pGATKBaseRecalibration Recalibration of bases using GATK BaseRecalibrator/PrintReads (defaults to "1" (=yes))
                 -gbrcov/--GATKBaseReCalibrationCovariate GATK BaseReCalibration covariates (defaults to "ReadGroupCovariate", "ContextCovariate", "CycleCovariate", "QualityScoreCovariate")
                 -gbrkst/--GATKBaseReCalibrationKnownSite GATK BaseReCalibration known SNV and INDEL sites (defaults to "dbsnp_138.b37.vcf", "1000G_phase1.indels.b37.vcf", "Mills_and_1000G_gold_standard.indels.b37.vcf")
                 -gbrocr/--GATKBaseReCalibrationOverClippedRead Filter out reads that are over-soft-clipped (defaults to "1" (=yes))             
                 -gbrdiq/--GATKBaseReCalibrationDisableIndelQual Disable indel quality scores (defaults to "1" (=yes))
                 -gbrsqq/--GATKBaseReCalibrationStaticQuantizedQuals Static binning of base quality scores (defaults to "10,20,30,40"; comma sep)
               -pGhC/--pGATKHaploTypeCaller Variant discovery using GATK HaplotypeCaller (defaults to "1" (=yes))
                 -ghcann/--GATKHaploTypeCallerAnnotation GATK HaploTypeCaller annotations (defaults to "BaseQualityRankSumTest", "ChromosomeCounts", "Coverage", "DepthPerAlleleBySample", "FisherStrand", "MappingQualityRankSumTest", "QualByDepth", "RMSMappingQuality", "ReadPosRankSumTest", "StrandOddsRatio")
                 -ghckse/--GATKHaploTypeCallerSNPKnownSet GATK HaplotypeCaller dbSNP set for annotating ID columns (defaults to "dbsnp_138.b37.vcf")
                 -ghcscb/--GATKHaploTypeCallerSoftClippedBases Do not include soft clipped bases in the variant calling (defaults to "1" (=yes))
                 -ghcpim/--GATKHaploTypeCallerPcrIndelModel The PCR indel model to use (defaults to "None"; Set to "0" to disable)
               -pGgT/--pGATKGenoTypeGVCFs Merge gVCF records using GATK GenotypeGVCFs (defaults to "1" (=yes))
                 -ggtgrl/--GATKGenoTypeGVCFsRefGVCF GATK GenoTypeGVCFs gVCF reference infile list for joint genotyping (defaults to "")
                 -ggtals/--GATKGenoTypeGVCFsAllSites Emit non-variant sites to the output VCF
               -pGvR/--pGATKVariantRecalibration Variant recalibration using GATK VariantRecalibrator/ApplyRecalibration (defaults to "1" (=yes))
                 -gvrtsh/--GATKVariantReCalibrationTrainingSetHapMap GATK VariantRecalibrator HapMap training set (defaults to "hapmap_3.3.b37.sites.vcf")
                 -gvrtss/--GATKVariantReCalibrationTrainingSetDbSNP GATK VariantRecalibrator dbSNP training set (defaults to "dbsnp_138.b37.vcf")
                 -gvrtsg/--GATKVariantReCalibrationTrainingSet1000GSNP GATK VariantRecalibrator 1000G high confidence SNP training set (defaults to "1000G_phase1.snps.high_confidence.b37.vcf")
                 -gvrtso/--GATKVariantReCalibrationTrainingSet1000GOmni GATK VariantRecalibrator 1000G_omni training set (defaults to "1000G_omni2.5.b37.sites.vcf")
                 -gvrtsm/--GATKVariantReCalibrationTrainingSetMills GATK VariantRecalibrator Mills training set (defaults to "Mills_and_1000G_gold_standard.indels.b37.vcf")
                 -gvrstf/--GATKVariantReCalibrationSnvTSFilterLevel The truth sensitivity level for snvs at which to start filtering used in GATK VariantRecalibrator (defaults to "99.9")
                 -gvritf/--GATKVariantReCalibrationIndelTSFilterLevel The truth sensitivity level for indels at which to start filtering used in GATK VariantRecalibrator (defaults to "99.9")
                 -gvrdpa/--GATKVariantReCalibrationDPAnnotation Use the DP annotation in variant recalibration. (defaults to "1" (=yes))
                 -gvrsmg/--GATKVariantReCalibrationSnvMaxGaussians Use hard filtering for snvs (defaults to "0" (=no))
                 -gvrimg/--GATKVariantReCalibrationIndelMaxGaussians Use hard filtering for indels (defaults to "1" (=yes))
                 -gvrevf/--GATKVariantReCalibrationexcludeNonVariantsFile Produce a vcf containing non-variant loci alongside the vcf only containing non-variant loci after GATK VariantRecalibrator (defaults to "0" (=no))
                 -gvrbcf/--GATKVariantReCalibrationBCFFile Produce a bcf from the GATK VariantRecalibrator vcf (defaults to "1" (=yes))
                 -gcgpss/--GATKCalculateGenotypePosteriorsSupportSet GATK CalculateGenotypePosteriors support set (defaults to "1000G_phase3_v4_20130502.sites.vcf")
               -pGcv/--pGATKCombineVariantCallSets Combine variant call sets (defaults to "1" (=yes))
                 -gcvbcf/--GATKCombineVariantCallSetsBCFFile Produce a bcf from the GATK CombineVariantCallSet vcf (defaults to "1" (=yes))
                 -gcvpc/GATKCombineVariantsPrioritizeCaller The prioritization order of variant callers.(defaults to ""; comma sep; Options: gatk|samtools|freebayes)
               -pGpT/--pGATKPhaseByTransmission Computes the most likely genotype and phases calls were unamibigous using GATK PhaseByTransmission (defaults to "0" (=yes))
               -pGrP/--pGATKReadBackedPhasing Performs physical phasing of SNP calls, based on sequencing reads using GATK ReadBackedPhasing (defaults to "0" (=yes))
                 -grpqth/--GATKReadBackedPhasingPhaseQualityThreshold The minimum phasing quality score required to output phasing (defaults to "20")
               -pGvEA/--pGATKVariantEvalAll Variant evaluation using GATK VariantEval for all variants  (defaults to "1" (=yes))
               -pGvEE/--pGATKVariantEvalExome Variant evaluation using GATK VariantEval for exonic variants  (defaults to "1" (=yes))
                 -gveedbs/--GATKVariantEvalDbSNP DbSNP file used in GATK VariantEval (defaults to "dbsnp_138.b37.excluding_sites_after_129.vcf")
                 -gveedbg/--GATKVariantEvalGold Gold Indel file used in GATK VariantEval (defaults to "Mills_and_1000G_gold_standard.indels.b37.vcf")
               
               ###Annotation
               -pPvab/--pPrepareForVariantAnnotationBlock Prepare for variant annotation block by copying and splitting files per contig (Mandatory)
               -pVT/--pVT VT decompose and normalize (defaults to "1" (=yes))
                 -vtdec/--VTDecompose Split multi allelic records into single records (defaults to "1" (=yes))
                 -vtnor/--VTNormalize Normalize variants (defaults to "1" (=yes))
                 -vtmaa/--VTmissingAltAllele Remove missing alternative alleles '*' (defaults to "1" (=yes))
                 -vtgmf/--VTgenmodFilter Remove common variants from vcf (defaults to "1" (=yes))
                 -vtgfr/--VTgenmodFilter1000G Genmod annotate 1000G reference (defaults to "ALL.wgs.phase3_shapeit2_mvncall_integrated_v5b.20130502.sites.vcf.gz")
                 -vtmaf/--VTgenmodFilterMaxAf Annotate MAX_AF from reference (defaults to "")
                 -vtgft/--VTgenmodFilterThreshold Threshold for filtering variants (defaults to "0.10")
               -pVeP/--pVariantEffectPredictor Annotate variants using VEP (defaults to "1" (=yes))
                 -vepp/--vepDirectoryPath Path to VEP script directory (defaults to "")
                 -vepc/--vepDirectoryCache Specify the cache directory to use (defaults to "") 
                 -vepr/--vepReference Use Human reference file with VEP (defaults to "0" (=no))
                 -vepf/--vepFeatures VEP features (defaults to ("hgvs","symbol","numbers","sift","polyphen","humdiv","domains","protein","ccds","uniprot","biotype","regulatory", "tsl", "canonical", "appris"); comma sep)
                 -veppl/--vepPlugins VEP plugins (defaults to ("UpDownDistance, LoFtool, LoF"); comma sep)
               -pVcP/--pVCFParser Parse variants using vcfParser.pl (defaults to "1" (=yes))
                 -vcpvt/--vcfParserVepTranscripts Parse VEP transcript specific entries (defaults to "0" (=no))
                 -vcprff/--vcfParserRangeFeatureFile Range annotations file (defaults to ""; tab-sep)
                 -vcprfa/--vcfParserRangeFeatureAnnotationColumns Range annotations feature columns (defaults to ""; comma sep)
                 -vcpsf/--vcfParserSelectFile File containging list of genes to analyse seperately (defaults to "";tab-sep file and HGNC Symbol required)
                 -vcpsfm/--vcfParserSelectFileMatchingColumn Position of HGNC Symbol column in SelectFile (defaults to "")
                 -vcpsfa/--vcfParserSelectFeatureAnnotationColumns Feature columns to use in annotation (defaults to ""; comma sep)
               -pAnV/--pAnnovar Annotate variants using Annovar (defaults to "0" (=no))
                 -anvp/--annovarPath  Path to Annovar script directory (defaults to "". NOTE: Assumes that the annovar db files are located in annovar/humandb)
                 -anvgbv/--annovarGenomeBuildVersion Annovar genome build version (defaults to "hg19")
                 -anvtn/--annovarTableNames Annovar table names (defaults to ("refGene","mce46way","gerp++elem","segdup","tfbs","mirna","snp137NonFlagged","1000g2012apr_all","esp6500si_all","ljb2_sift","ljb2_pp2hdiv","ljb2_pp2hvar","ljb2_mt","ljb2_lrt","ljb2_gerp++","ljb2_phylop"); comma sep)
                 -anvstn/--annovarSupportedTableNames Print Annovar MIP supported table names
                 -anvarmafth/--annovarMAFThreshold Sets the minor allele frequency threshold in annovar (defaults to "0")
               -pSnE/--pSnpEff Variant annotation using snpEFF (defaults to "1" (=yes))
#snpEffAnn
                 -snep/--snpEffPath Path to snpEff. Mandatory for use of snpEff (defaults to "")
                 -sneann/--snpEffAnn Annotate variants using SnpEff (defaults to "1" (=yes))
                 -snegbv/--snpEffGenomeBuildVersion SnpEff genome build version (defaults to "GRCh37.75")
                 -snesaf/--snpSiftAnnotationFiles Annotation files to use with snpSift (default to (dbsnp_138.b37.excluding_sites_after_129.vcf.gz=CAF ALL.wgs.phase3_shapeit2_mvncall_integrated_v5b.20130502.sites.vcf.gz=AF ExAC.r0.3.sites.vep.vcf=AF); Hash flag i.e. --Flag key=value)
                 -snesaoi/--snpSiftAnnotationOutInfoKey snpSift output INFO key (default to (ALL.wgs.phase3_shapeit2_mvncall_integrated_v5b.20130502.sites.vcf.gz=1000GAF ExAC.r0.3.sites.vep.vcf=EXACAF); Hash flag i.e. --Flag key=value)
                 -snesdbnsfp/--snpSiftDbNSFPFile DbNSFP File (defaults to "dbNSFP2.6.txt.gz")
                 -snesdbnsfpa/--snpSiftDbNSFPAnnotations DbNSFP annotations to use with snpSift (defaults to ("SIFT_pred","Polyphen2_HDIV_pred","Polyphen2_HVAR_pred","LRT_pred","MutationTaster_pred","GERP++_NR","GERP++_RS","phastCons100way_vertebrate","1000Gp1_AF","ESP6500_AA_AF"); comma sep)

               ##RankVariants
               -pRaV/--pRankVariants Ranking of annotated variants (defaults to "1" (=yes))
                 -ravgft/--genmodModelsFamilyType Use one of the known setups (defaults to "mip")
                 -ravcad/--genmodcaddFiles CADD score files (defaults to ""; comma sep)
                 -ravspi/--spidexFile Spidex database for alternative splicing (defaults to "")
                 -ravwg/--wholeGene Allow compound pairs in intronic regions (defaults to "1" (=yes))
                 -ravrpf/--genmodModelsReducedPenetranceFile File containg genes with reduced penetrance (defaults to "")
                 -ravrm/--rankModelFile Rank model config file (defaults to "")
                 -ravbcf/--rankVariantBCFFile Produce bcfs from the Rank variants vcfs (defaults to "1" (=yes))
               
               ###Utility
               -pScK/--pSampleCheck QC for samples gender and relationship (defaults to "1" (=yes) )
               -pEvL/--pEvaluation Compare concordance with NIST data set (defaults to "0" (=no) )
                 -evlnid/--NISTID NIST high-confidence sampleID (defaults to "NA12878")
                 -evlnhc/--NISTHighConfidenceCallSet NIST high-confidence variant calls (defaults to "NISTIntgratedCalls.v2.19.vcf")
                 -evlnil/--NISTHighConfidenceCallSetBed NIST high-confidence variant calls interval list (defaults to "NISTIntgratedCalls.v2.19.interval_list")
               -pQcC/--pQCCollect Collect QC metrics from programs processed (defaults to "1" (=yes) )
                 -qccsi/--QCCollectSampleInfoFile SampleInfo File containing info on what to parse from this analysis run (defaults to "{outDataDir}/{familyID}/{familyID}_qc_sampleInfo.yaml")
                 -qccref/--QCCollectRegExpFile Regular expression file containing the regular expression to be used for each program (defaults to "qc_regExp_v1.4.yaml")
               -pMqC/--pMultiQC Create aggregate bioinformatics analysis report across many samples (defaults to "1" (=yes))
               -pReM/--pRemoveRedundantFiles Generating sbatch script for deletion of redundant files (defaults to "1" (=yes);Note: Must be submitted manually to SLURM)
               -pArS/--pAnalysisRunStatus Sets the analysis run status flag to finished in sampleInfoFile (defaults to "1" (=yes))
               -pSac/--pSacct Generating sbatch script for SLURM info on each submitted job (defaults to "1" (=yes);Note: Must be submitted manually to SLURM)
	   };

    sub EvalModules {
	
	##EvalModules
	
	##Function : Evaluate that all modules required are installed 
	##Returns  : ""
	##Arguments: $modulesArrayRef
	##         : $modulesArrayRef => Array of module names

	local $Params::Check::PRESERVE_CASE = 1;

	my ($argHashRef) = @_;
	
	##Flatten argument(s)
	my $modulesArrayRef;
		
	my $tmpl = { 
	    modulesArrayRef => { required => 1, default => [], strict_type => 1, store => \$modulesArrayRef},
	};

	check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];
	
	foreach my $module (@{$modulesArrayRef}) {

	    $module =~s/::/\//g;  #Replace "::" with "/" since the automatic replacement magic only occurs for barewords.
	    $module .= ".pm";  #Add perl module ending for the same reason
	    
	    eval { 
		
		require $module; 
	    };
	    if($@) {
		
		warn("NOTE: ".$module." not installed - Please install to run MIP.\n");
		warn("NOTE: Aborting!\n");
		exit 1;
	    }
	}
    }
}

####Script parameters

my %parameter;  #Holds all parameters for MIP
my %scriptParameter;  #Holds all active parameters after the value has been set

my $logger;  #Will hold the logger object for the MIP log
my @orderParameters;  #To add/write parameters in the correct order
my @broadcasts;  #Holds all set parameters info after AddToScriptParameter

## Add dateTimestamp for later use in log and qcmetrics yaml file
my $dateTime = localtime;
my $dateTimeStamp = $dateTime->datetime;
my $date = $dateTime->ymd;
my $script = (`basename $0`);  #Catches script name
chomp($dateTimeStamp, $date, $script);  #Remove \n;

####Set program parameters

###Project specific

## Loads a YAML file into an arbitrary hash and returns it.
%parameter = &LoadYAML({yamlFile => catfile($Bin, "definitions", "defineParameters.yaml"),
		       });
 
## Adds the order of first level keys from yaml file to array
&OrderParameterNames({orderParametersArrayRef => \@orderParameters,
		      filePath => catfile($Bin, "definitions", "defineParameters.yaml"),
		     });

## Eval parameter hash
&EvalParameterHash({parameterHashRef => \%parameter,
		     filePath => catfile($Bin, "definitions", "defineParameters.yaml"),
		    });

my $mipVersion = "v3.0.5";	#Set MIP version

## Directories, files, sampleInfo and jobIDs
my (%infile, %inDirPath, %infilesLaneNoEnding, %lane, %infilesBothStrandsNoEnding, %jobID, %sampleInfo); 


####Staging/Sanity Check Area 

my %fileInfo = (mosaikAlignReference => ".dat",
		mosaikJumpDbStub => "_jdb_15",
		bwaBuildReference => "",
		exomeTargetBed => [".infile_list", ".pad100.infile_list", ".pad100.interval_list"],
		mosaikJumpDbStubFileEndings => ["_keys.jmp", "_meta.jmp", "_positions.jmp"],  #MosaikJumpDatabase file endings
		bwaBuildReferenceFileEndings => [".amb", ".ann", ".bwt", ".pac", ".sa"],  #BWA human genome reference file endings
		humanGenomeReferenceFileEndings => [".dict", ".fasta.fai"],  #Meta files
    );

## Capture kit aliases supported from pedigree file.
my %supportedCaptureKit = ('Nimblegen_SeqCapEZExome.V2' => "Nimblegen_SeqCapEZExome.V2.GenomeReferenceSourceVersion_targets.bed",
			   'Nimblegen_SeqCapEZExome.V3' => "Nimblegen_SeqCapEZExome.V3.GenomeReferenceSourceVersion_targets.bed",
			   'Agilent_SureSelect.V2' => "Agilent_SureSelect.V2.GenomeReferenceSourceVersion_targets.bed",
			   'Agilent_SureSelect.V3' => "Agilent_SureSelect.V3.GenomeReferenceSourceVersion_targets.bed",
			   'Agilent_SureSelect.V4' => "Agilent_SureSelect.V4.GenomeReferenceSourceVersion_targets.bed",
			   'Agilent_SureSelect.V5' => "Agilent_SureSelect.V5.GenomeReferenceSourceVersion_targets.bed",
			   'Agilent_SureSelectCRE.V1' => "Agilent_SureSelectCRE.V1.GenomeReferenceSourceVersion_targets.bed",
			   'Latest' => "Agilent_SureSelectCRE.V1.GenomeReferenceSourceVersion_targets.bed",
    );

my %supportedCosmidReference;  #References supported as downloads from Cosmid. Hash is populated after user options are processed

## Reference that should be decomposed and normalized using vt
my @vtReferences = ("GATKReAlignerINDELKnownSite",
		    "GATKBaseReCalibrationKnownSite",
		    "GATKHaploTypeCallerSNPKnownSet",
		    "GATKVariantReCalibrationTrainingSetHapMap",
		    "GATKVariantReCalibrationTrainingSetMills",
		    "GATKVariantReCalibrationTrainingSet1000GOmni",
		    "GATKVariantReCalibrationTrainingSet1000GSNP",
		    "GATKVariantReCalibrationTrainingSetDbSNP",
		    "VTgenmodFilter1000G",
		    "GATKVariantEvalGold",
		    "GATKVariantEvalDbSNP",
		    "snpSiftAnnotationFiles",
    );

## Set supported annovar table name filtering options
my @annovarSupportedTableNames = ("refGene", "knownGene", "ensGene", "mce46way", "gerp++elem", "segdup", "gwascatalog", "tfbs", "mirna", "snp137", "snp135", "snp132", "snp131", "snp130", "snp129", "snp137NonFlagged", "snp135NonFlagged", "snp132NonFlagged", "snp131NonFlagged", "snp130NonFlagged", "1000g2012apr_all", "1000g2012apr_amr", "1000g2012apr_eur", "1000g2012apr_asn", "1000g2012apr_afr", "1000g2012feb_all", "esp6500si_all", "esp6500_all", "esp6500_aa", "esp6500_ea", "esp5400_all", "esp5400_aa", "esp5400_ea","clinvar_20131105", "ljb2_sift", "ljb2_pp2hdiv", "ljb2_pp2hvar", "ljb2_mt", "ljb2_ma", "ljb2_fathmm", "ljb2_siphy", "ljb2_lrt", "ljb_all", "ljb2_gerp++", "ljb2_phylop", "caddgt20", "caddgt10");  #Used to print list of supported table names

my %annovarTable;  #Holds annovar tables and features

## Enables cmd "mip.pl" to print usage help
if(!@ARGV) {

    &Help({USAGE => $USAGE,
	   exitCode => 0,
	  });
}

###User Options
GetOptions('ifd|inFilesDirs:s'  => \@{$parameter{inFilesDirs}{value}},  #Comma separated list
	   'isd|inScriptDir:s'  => \$parameter{inScriptDir}{value},  #Directory for custom scripts required by the pipeline
	   'rd|referencesDir:s'  => \$parameter{referencesDir}{value},  #directory containing references
	   'p|projectID:s'  => \$parameter{projectID}{value},
	   's|sampleIDs:s'  => \@{$parameter{sampleIDs}{value}},  #Comma separated list, one below outDataDir
	   'em|email:s'  => \$parameter{email}{value},  #Email adress
	   'emt|emailType:s'  => \$parameter{emailType}{value},  #Email type 
	   'odd|outDataDir:s'  => \$parameter{outDataDir}{value},  #One dir above sample id, must supply whole path i.e. /proj/...
	   'osd|outScriptDir:s'  => \$parameter{outScriptDir}{value},   #One dir above sample id, must supply whole path i.e. /proj/...
	   'f|familyID:s' => \$parameter{familyID}{value},  #Family group ID (Merged to same vcf file after GATK Base Recalibration)
	   'ped|pedigreeFile:s' => \$parameter{pedigreeFile}{value},  #Pedigree file
	   'hgr|humanGenomeReference:s' => \$parameter{humanGenomeReference}{value},  #Human genome reference
	   'al|alignerOutDir:s' => \$parameter{alignerOutDir}{value},  #determining which aligner out data directory was used previously (if not specified)
	   'at|analysisType:s' => \$parameter{analysisType}{value},  #Type of analysis
	   'pl|platForm:s' => \$parameter{platForm}{value},  #Platform/technology used to produce the reads
	   'mc|maximumCores=n' => \$parameter{maximumCores}{value},  #Per node
	   'c|configFile:s' => \$parameter{configFile}{value},
	   'ccp|clusterConstantPath:s' => \$parameter{clusterConstantPath}{value},
	   'acp|analysisConstantPath:s' => \$parameter{analysisConstantPath}{value},
	   'wc|writeConfigFile:s' => \$parameter{writeConfigFile}{value},
	   'sif|sampleInfoFile:s' => \$parameter{sampleInfoFile}{value},  #Write all info on samples and run to YAML file
	   'int|instanceTag:s' => \@{$parameter{instanceTag}{value}},
	   'rea|researchEthicalApproval:s' => \$parameter{researchEthicalApproval}{value},
	   'dra|dryRunAll=i' => \$parameter{dryRunAll}{value},
	   'tmd|tempDirectory:s' => \$parameter{tempDirectory}{value},
	   'sen|sourceEnvironmentCommand=s{,}' => \@{$parameter{sourceEnvironmentCommand}{value}},
	   'jul|javaUseLargePages=n' => \$parameter{javaUseLargePages}{value},
	   'nrm|nodeRamMemory=n' => \$parameter{nodeRamMemory}{value},  #Per node
           'ges|genomicSet:s' => \$parameter{genomicSet}{value},  #Selection of relevant regions post alignment and sort
	   'rio|reduceIO=n' => \$parameter{reduceIO}{value},
	   'riu|replaceIUPAC=n' => \$parameter{replaceIUPAC}{value},
	   'ppm|printProgramMode=n' => \$parameter{printProgramMode}{value},
	   'pp|printProgram' => sub { GetOptions('ppm|printProgramMode=n' => \$parameter{printProgramMode}{value});  #Force ppm to be read before function call
				      &PrintProgram({parameterHashRef => \%parameter,
						     printProgramMode => $parameter{printProgramMode}{value},
						    }); exit;},
	   'l|logFile:s' => \$parameter{logFile}{value},
	   'h|help' => sub { say STDOUT $USAGE; exit;},  #Display help text
	   'v|version' => sub { say STDOUT "\nMip.pl ".$mipVersion, "\n"; exit;},  #Display version number
	   'pGZ|pGZipFastq=n' => \$parameter{pGZipFastq}{value},
	   'pFqC|pFastQC=n' => \$parameter{pFastQC}{value},
	   'pMaD|pMadeline=n' => \$parameter{pMadeline}{value},
	   'pMoB|pMosaikBuild=n' => \$parameter{pMosaikBuild}{value},
	   'mobmfl|mosaikBuildMedianFragLength=n' => \$parameter{mosaikBuildMedianFragLength}{value},  #for fragment length estimation and local search
	   'pMoA|pMosaikAlign=n' => \$parameter{pMosaikAlign}{value},
	   'moaref|mosaikAlignReference:s' => \$parameter{mosaikAlignReference}{value},  #MosaikAlign reference file assumes existance of jump database files in same dir
	   'moaape|mosaikAlignNeuralNetworkPeFile:s' => \$parameter{mosaikAlignNeuralNetworkPeFile}{value},
	   'moaase|mosaikAlignNeuralNetworkSeFile:s' => \$parameter{mosaikAlignNeuralNetworkSeFile}{value}, 
	   'mojdb|mosaikJumpDbStub:s' => \$parameter{mosaikJumpDbStub}{value},  #Stub for MosaikJump database
	   'pMem|pBwaMem=n' => \$parameter{pBwaMem}{value},
	   'memhla|bwaMemHLA=n' => \$parameter{bwaMemHLA}{value},
	   'memrdb|bwaMemRapidDb:s' => \$parameter{bwaMemRapidDb}{value},
	   'memcrm|bwaMemCram=n' => \$parameter{bwaMemCram}{value},
	   'memsts|bwaMembamStats=n' => \$parameter{bwaMembamStats}{value},
	   'memssm|bwaSambambaSortMemoryLimit:s' => \$parameter{bwaSambambaSortMemoryLimit}{value},
	   'pAln|pBwaAln=n' => \$parameter{pBwaAln}{value},
	   'alnq|bwaAlnQualityTrimming=n' => \$parameter{bwaAlnQualityTrimming}{value},  #BWA aln quality threshold for read trimming down to 35bp
	   'pSap|pBwaSampe=n' => \$parameter{pBwaSampe}{value},
	   'pPtM|pPicardToolsMergeSamFiles=n' => \$parameter{pPicardToolsMergeSamFiles}{value},  #PicardTools mergeSamFiles
	   'ptmp|picardToolsMergeSamFilesPrevious:s' => \@{$parameter{picardToolsMergeSamFilesPrevious}{value}},  #Comma separated list
	   'pPtMR|pPicardToolsMergeRapidReads=n' => \$parameter{pPicardToolsMergeRapidReads}{value},  #PicardTools mergeSamFiles - rapid mode
	   'ptp|picardToolsPath:s' => \$parameter{picardToolsPath}{value},  #Path to picardtools
	   'pPmD|pPicardToolsMarkduplicates=n' => \$parameter{pPicardToolsMarkduplicates}{value},  #PicardTools Markduplicates
	   'pSmD|pSambambaMarkduplicates=n' => \$parameter{pSambambaMarkduplicates}{value},  #Sambamba Markduplicates
	   'smdhts|sambambaMarkDupHashTableSize=n' => \$parameter{sambambaMarkDupHashTableSize}{value},
	   'smdols|sambambaMarkDupOverflowListSize=n' => \$parameter{sambambaMarkDupOverflowListSize}{value},
	   'smdibs|sambambaMarkDupIoBufferSize=n' => \$parameter{sambambaMarkDupIoBufferSize}{value},
	   'pChS|pChanjoSexCheck=n' => \$parameter{pChanjoSexCheck}{value},   #Chanjo coverage analysis on sex chromosomes
	   'pSdT|pSambambaDepth=n' => \$parameter{pSambambaDepth}{value},   #Chanjo coverage analysis
	   'sdtcut|sambambaDepthCutOffs:s' => \@{$parameter{sambambaDepthCutOffs}{value}},   # Cutoff used for completeness
	   'sdtbed|sambambaDepthBed:s' => \$parameter{sambambaDepthBed}{value},
	   'sdtbaq|sambambaDepthBaseQuality=n' => \$parameter{sambambaDepthBaseQuality}{value},
	   'sdtmaq|sambambaDepthMappingQuality=n' => \$parameter{sambambaDepthMappingQuality}{value},
	   'sdtndu|sambambaDepthNoDuplicates=n' => \$parameter{sambambaDepthNoDuplicates}{value},
	   'sdtfqc|sambambaDepthNoFailedQualityControl=n' => \$parameter{sambambaDepthNoFailedQualityControl}{value},
	   'pGcB|pGenomeCoverageBED=n' => \$parameter{pGenomeCoverageBED}{value},
	   'xcov|GenomeCoverageBEDMaxCoverage=n' => \$parameter{GenomeCoverageBEDMaxCoverage}{value},  #Sets max depth to calculate coverage
	   'pPtCMM|pPicardToolsCollectMultipleMetrics=n' => \$parameter{pPicardToolsCollectMultipleMetrics}{value},
	   'pPtCHS|pPicardToolsCalculateHSMetrics=n' => \$parameter{pPicardToolsCalculateHSMetrics}{value},
	   'extb|exomeTargetBed=s'  => \%{$parameter{exomeTargetBed}{value}},  #Hash value sampleID=file.bed
	   'pRcP|pRCovPlots=n' => \$parameter{pRCovPlots}{value},
	   'pCnv|pCNVnator=n' => \$parameter{pCNVnator}{value},
	   'cnvhbs|cnvBinSize=n' => \$parameter{cnvBinSize}{value},
	   'pDel|pDelly=n' => \$parameter{pDelly}{value},
	   'deltyp|dellyType:s'  => \@{$parameter{dellyType}{value}},
	   'pMna|pManta=n' => \$parameter{pManta}{value},
	   'pFit|pFindTranslocations=n' => \$parameter{pFindTranslocations}{value},
	   'fitmsp|findTranslocationsMinimumSuppotingPairs=n' => \$parameter{findTranslocationsMinimumSuppotingPairs}{value},
	   'pSvC|pSVCombineVariantCallSets=n' => \$parameter{pSVCombineVariantCallSets}{value},  #Combine structural variant call sets
	   'svcvtd|svVTDecompose=n' => \$parameter{svVTDecompose}{value},  #VT decompose (split multiallelic variants)
	   'svcbtv|svBcfToolsViewFilter=n' => \$parameter{svBcfToolsViewFilter}{value},  #Include structural variants with PASS in FILTER column
	   'svcvan|svVCFAnno=n' => \$parameter{svVCFAnno}{value},
	   'svcval|svVCFAnnoLua:s' => \$parameter{svVCFAnnoLua}{value},  #Lua file postscripting
	   'svcvac|svVCFAnnoConfig:s' => \$parameter{svVCFAnnoConfig}{value},  #Toml config of what to annotate
	   'svcvah|svVCFAnnotationHeaderLinesFile:s' => \$parameter{svVCFAnnotationHeaderLinesFile}{value},  #Adjust for postscript by adding required header lines to vcf
	   'svcgmf|svGenmodFilter=n'  => \$parameter{svGenmodFilter}{value},  #Remove common structural variants from vcf 
	   'svcgfr|svGenmodFilter1000G:s'  => \$parameter{svGenmodFilter1000G}{value},  #Genmod annotate structural variants from 1000G reference
	   'svcgft|svGenmodFilterThreshold:s'  => \$parameter{svGenmodFilterThreshold}{value},  #Threshold for filtering structural variants
	   'svcbcf|svCombineVariantCallSetsBCFFile=n' => \$parameter{svCombineVariantCallSetsBCFFile}{value},  #Produce compressed vcf
	   'pSvv|pSVVariantEffectPredictor=n' => \$parameter{pSVVariantEffectPredictor}{value},
	   'svvepf|svVepFeatures:s'  => \@{$parameter{svVepFeatures}{value}},  #Comma separated list
	   'svvepl|svVepPlugins:s'  => \@{$parameter{svVepPlugins}{value}},  #Comma separated list
	   'pSVVcP|pSVVCFParser=n' => \$parameter{pSVVCFParser}{value},
	   'svvcpvt|svVcfParserVepTranscripts=n' => \$parameter{svVcfParserVepTranscripts}{value},
	   'svvcprff|svVcfParserRangeFeatureFile:s' => \$parameter{svVcfParserRangeFeatureFile}{value},  #path to vcfParserRangeFeatureFile
	   'svvcprfa|svVcfParserRangeFeatureAnnotationColumns:s'  => \@{$parameter{svVcfParserRangeFeatureAnnotationColumns}{value}},  #Comma separated list
	   'svvcpsf|svVcfParserSelectFile:s'  => \$parameter{svVcfParserSelectFile}{value},  #path to vcfParserSelectFile
	   'svvcpsfm|svVcfParserSelectFileMatchingColumn=n' => \$parameter{svVcfParserSelectFileMatchingColumn}{value},  #Column of HGNC Symbol in SelectFile
	   'svvcpsfa|svVcfParserSelectFeatureAnnotationColumns:s'  => \@{$parameter{svVcfParserSelectFeatureAnnotationColumns}{value}},  #Comma separated list
	   'pSvR|pSVRankVariants=n' => \$parameter{pSVRankVariants}{value},  #Ranking of SV variants
	   'svravgft|svGenmodModelsFamilyType:s' => \$parameter{svGenmodModelsFamilyType}{value},
	   'svravrpf|svGenmodModelsReducedPenetranceFile:s' => \$parameter{svGenmodModelsReducedPenetranceFile}{value},
	   'svravwg|svWholeGene=n'  => \$parameter{svWholeGene}{value},  #Allow compound pairs in intronic regions
	   'svravrm|svRankModelFile:s' => \$parameter{svRankModelFile}{value},  #The rank modell config.ini path
	   'svravbcf|svRankVariantsBCFFile=n' => \$parameter{svRankVariantsBCFFile}{value},  #Produce compressed vcfs
	   'pSmp|pSamToolsMpileUp=n' => \$parameter{pSamToolsMpileUp}{value},
	   'pFrb|pFreebayes=n' => \$parameter{pFreebayes}{value},
	   'gtp|genomeAnalysisToolKitPath:s' => \$parameter{genomeAnalysisToolKitPath}{value},  #GATK whole path
	   'gbdv|GATKBundleDownLoadVersion:s' => \$parameter{GATKBundleDownLoadVersion}{value},  #Sets the GATK FTP Bundle Download version
	   'gdco|GATKDownSampleToCoverage=n' => \$parameter{GATKDownSampleToCoverage}{value},  #GATK downsample to coverage
	   'pGrA|pGATKRealigner=n' => \$parameter{pGATKRealigner}{value},  #GATK ReAlignerTargetCreator/IndelRealigner
	   'graks|GATKReAlignerINDELKnownSite:s'  => \@{$parameter{GATKReAlignerINDELKnownSite}{value}},  #Comma separated list
	   'pGbR|pGATKBaseRecalibration=n' => \$parameter{pGATKBaseRecalibration}{value},  #GATK BaseRecalibrator/PrintReads
	   'gbrcov|GATKBaseReCalibrationCovariate:s'  => \@{$parameter{GATKBaseReCalibrationCovariate}{value}},  #Comma separated list
	   'gbrkst|GATKBaseReCalibrationKnownSite:s'  => \@{$parameter{GATKBaseReCalibrationKnownSite}{value}},  #Comma separated list
	   'gbrocr|GATKBaseReCalibrationOverClippedRead=n' => \$parameter{GATKBaseReCalibrationOverClippedRead}{value},  #Filter out reads that are over-soft-clipped
	   'gbrdiq|GATKBaseReCalibrationDisableIndelQual=n' => \$parameter{GATKBaseReCalibrationDisableIndelQual}{value},  #Disable indel quality scores
	   'gbrsqq|GATKBaseReCalibrationStaticQuantizedQuals:s'  => \@{$parameter{GATKBaseReCalibrationStaticQuantizedQuals}{value}},  #Comma separated list
	   'pGhC|pGATKHaploTypeCaller=n' => \$parameter{pGATKHaploTypeCaller}{value},  #GATK Haplotypecaller
	   'ghcann|GATKHaploTypeCallerAnnotation:s'  => \@{$parameter{GATKHaploTypeCallerAnnotation}{value}},  #Comma separated list
	   'ghckse|GATKHaploTypeCallerSNPKnownSet:s' => \$parameter{GATKHaploTypeCallerSNPKnownSet}{value},  #Known SNP set to be used in GATK HaplotypeCaller
	   'ghcscb|GATKHaploTypeCallerSoftClippedBases=n' => \$parameter{GATKHaploTypeCallerSoftClippedBases}{value},  #Do not include soft clipped bases in the variant calling
	   'ghcpim|GATKHaploTypeCallerPcrIndelModel:s' => \$parameter{GATKHaploTypeCallerPcrIndelModel}{value},  #The PCR indel model to use
	   'pGgT|pGATKGenoTypeGVCFs=n' => \$parameter{pGATKGenoTypeGVCFs}{value},  #Merge gVCF records using GATK GenotypeGVCFs
	   'ggtgrl|GATKGenoTypeGVCFsRefGVCF:s' => \$parameter{GATKGenoTypeGVCFsRefGVCF}{value},  #GATK GenoTypeGVCFs gVCF reference infile list for joint genotyping
	   'ggtals|GATKGenoTypeGVCFsAllSites=n' => \$parameter{GATKGenoTypeGVCFsAllSites}{value},  #Emit non-variant sites to the output VCF
	   'pGvR|pGATKVariantRecalibration=n' => \$parameter{pGATKVariantRecalibration}{value},  #GATK VariantRecalibrator/ApplyRecalibration
	   'gvrtsh|GATKVariantReCalibrationTrainingSetHapMap:s' => \$parameter{GATKVariantReCalibrationTrainingSetHapMap}{value},  #GATK VariantRecalibrator resource
	   'gvrtss|GATKVariantReCalibrationTrainingSetDbSNP:s' => \$parameter{GATKVariantReCalibrationTrainingSetDbSNP}{value},  #GATK VariantRecalibrator resource
	   'gvrtsg|GATKVariantReCalibrationTrainingSet1000GSNP:s' => \$parameter{GATKVariantReCalibrationTrainingSet1000GSNP}{value},  #GATK VariantRecalibrator resource
	   'gvrtso|GATKVariantReCalibrationTrainingSet1000GOmni:s' => \$parameter{GATKVariantReCalibrationTrainingSet1000GOmni}{value},  #GATK VariantRecalibrator resource
	   'gvrtsm|GATKVariantReCalibrationTrainingSetMills:s' => \$parameter{GATKVariantReCalibrationTrainingSetMills}{value},  #GATK VariantRecalibrator resource
	   'gvrstf|GATKVariantReCalibrationSnvTSFilterLevel:s' => \$parameter{GATKVariantReCalibrationSnvTSFilterLevel}{value},  #Snv truth sensativity level
	   'gvritf|GATKVariantReCalibrationIndelTSFilterLevel:s' => \$parameter{GATKVariantReCalibrationIndelTSFilterLevel}{value},  #Indel truth sensativity level
	   'gvrdpa|GATKVariantReCalibrationDPAnnotation=n' => \$parameter{GATKVariantReCalibrationDPAnnotation}{value},
	   'gvrsmg|GATKVariantReCalibrationSnvMaxGaussians=n' => \$parameter{GATKVariantReCalibrationSnvMaxGaussians}{value},
	   'gvrimg|GATKVariantReCalibrationIndelMaxGaussians=n' => \$parameter{GATKVariantReCalibrationIndelMaxGaussians}{value},
	   'gvrevf|GATKVariantReCalibrationexcludeNonVariantsFile=n' => \$parameter{GATKVariantReCalibrationexcludeNonVariantsFile}{value},
	   'gvrbcf|GATKVariantReCalibrationBCFFile=n' => \$parameter{GATKVariantReCalibrationBCFFile}{value},  #Produce compressed vcf
	   'gcgpss|GATKCalculateGenotypePosteriorsSupportSet:s' => \$parameter{GATKCalculateGenotypePosteriorsSupportSet}{value},  #GATK CalculateGenotypePosteriors support set
	   'pGcv|pGATKCombineVariantCallSets=n' => \$parameter{pGATKCombineVariantCallSets}{value},  #Combine variant call sets
	   'gcvpc|GATKCombineVariantsPrioritizeCaller:s' => \$parameter{GATKCombineVariantsPrioritizeCaller}{value},  #Prioritize variant calls
	   'gcvbcf|GATKCombineVariantCallSetsBCFFile=n' => \$parameter{GATKCombineVariantCallSetsBCFFile}{value},  #Produce compressed vcf
	   'pGpT|pGATKPhaseByTransmission=n' => \$parameter{pGATKPhaseByTransmission}{value},  #GATK PhaseByTransmission to produce phased genotype calls
	   'pGrP|pGATKReadBackedPhasing=n' => \$parameter{pGATKReadBackedPhasing}{value},  #GATK ReadBackedPhasing
	   'grpqth|GATKReadBackedPhasingPhaseQualityThreshold=n' => \$parameter{GATKReadBackedPhasingPhaseQualityThreshold}{value},  #quality score required to output phasing
	   'pGvEA|pGATKVariantEvalAll=n' => \$parameter{pGATKVariantEvalAll}{value},  #GATK varianteval all variants
	   'pGvEE|pGATKVariantEvalExome=n' => \$parameter{pGATKVariantEvalExome}{value},  #GATK varianteval only exonic variants
	   'gveedbs|GATKVariantEvalDbSNP:s' => \$parameter{GATKVariantEvalDbSNP}{value},
	   'gveedbg|GATKVariantEvalGold:s' => \$parameter{GATKVariantReCalibrationTrainingSetMills}{value},
	   'pPvab|pPrepareForVariantAnnotationBlock=n' => \$parameter{pPrepareForVariantAnnotationBlock}{value},
	   'pVT|pVT=n' => \$parameter{pVT}{value},  #VT program
	   'vtddec|VTDecompose=n' => \$parameter{VTDecompose}{value},  #VT decompose (split multiallelic variants)
	   'vtdnor|VTNormalize=n' => \$parameter{VTNormalize}{value},  #VT normalize varaints according to genomic reference
	   'vtmaa|VTmissingAltAllele=n'  => \$parameter{VTmissingAltAllele}{value},  #VT remove '*' entries from vcf
	   'vtgmf|VTgenmodFilter=n'  => \$parameter{VTgenmodFilter}{value},  #VT Remove common variants from vcf 
	   'vtgfr|VTgenmodFilter1000G:s'  => \$parameter{VTgenmodFilter1000G}{value},  #VT Genmod annotate 1000G reference
	   'vtmaf|VTgenmodFilterMaxAf=n' => \$parameter{VTgenmodFilterMaxAf}{value}, 
	   'vtgft|VTgenmodFilterThreshold:s'  => \$parameter{VTgenmodFilterThreshold}{value},  #VT Threshold for filtering variants
	   'pVeP|pVariantEffectPredictor=n' => \$parameter{pVariantEffectPredictor}{value},  #Annotation of variants using vep
	   'vepp|vepDirectoryPath:s'  => \$parameter{vepDirectoryPath}{value},  #path to vep script dir
	   'vepc|vepDirectoryCache:s'  => \$parameter{vepDirectoryCache}{value},  #path to vep cache dir
	   'vepr|vepReference:s'  => \$parameter{vepReference}{value},  #Use Human reference file with VEP
	   'vepf|vepFeatures:s'  => \@{$parameter{vepFeatures}{value}},  #Comma separated list
	   'veppl|vepPlugins:s'  => \@{$parameter{vepPlugins}{value}},  #Comma separated list
	   'pVcP|pVCFParser=n' => \$parameter{pVCFParser}{value},
	   'vcpvt|vcfParserVepTranscripts=n' => \$parameter{vcfParserVepTranscripts}{value},
	   'vcprff|vcfParserRangeFeatureFile:s'  => \$parameter{vcfParserRangeFeatureFile}{value},  #path to vcfParserRangeFeatureFile
	   'vcprfa|vcfParserRangeFeatureAnnotationColumns:s'  => \@{$parameter{vcfParserRangeFeatureAnnotationColumns}{value}},  #Comma separated list
	   'vcpsf|vcfParserSelectFile:s'  => \$parameter{vcfParserSelectFile}{value},  #path to vcfParserSelectFile
	   'vcpsfm|vcfParserSelectFileMatchingColumn=n' => \$parameter{vcfParserSelectFileMatchingColumn}{value},  #Column of HGNC Symbol in SelectFile
	   'vcpsfa|vcfParserSelectFeatureAnnotationColumns:s'  => \@{$parameter{vcfParserSelectFeatureAnnotationColumns}{value}},  #Comma separated list
	   'pAnV|pAnnovar=n' => \$parameter{pAnnovar}{value},  #Performs annovar filter gene, region and filter analysis
	   'anvp|annovarPath:s'  => \$parameter{annovarPath}{value},  #path to annovar script dir
	   'anvgbv|annovarGenomeBuildVersion:s'  => \$parameter{annovarGenomeBuildVersion}{value},
	   'anvtn|annovarTableNames:s'  => \@{$parameter{annovarTableNames}{value}},  #Comma separated list
	   'anvstn|annovarSupportedTableNames' => sub { &PrintSupportedAnnovarTableNames({scriptParameterHashRef => \%scriptParameter,
											  annovarSupportedTableNamesArrayRef => \@annovarSupportedTableNames,
											 })},  #Generates a list of supported table names
	   'anvarmafth|annovarMAFThreshold=n' => \$parameter{annovarMAFThreshold}{value},
	   'pSnE|pSnpEff=n' => \$parameter{pSnpEff}{value},
	   'snep|snpEffPath:s'  => \$parameter{snpEffPath}{value},  #path to snpEff directory
	   'sneann|snpEffAnn=n' => \$parameter{snpEffAnn}{value},
	   'snegbv|snpEffGenomeBuildVersion:s'  => \$parameter{snpEffGenomeBuildVersion}{value},
	   'snesaf|snpSiftAnnotationFiles=s'  => \%{$parameter{snpSiftAnnotationFiles}{value}},
	   'snesaoi|snpSiftAnnotationOutInfoKey=s'  => \%{$parameter{snpSiftAnnotationOutInfoKey}{value}},
	   'snesdbnsfp|snpSiftDbNSFPFile:s'  => \$parameter{snpSiftDbNSFPFile}{value},  #DbNSFP file
	   'snesdbnsfpa|snpSiftDbNSFPAnnotations:s'  => \@{$parameter{snpSiftDbNSFPAnnotations}{value}},  #Comma separated list
	   'pRaV|pRankVariants=n' => \$parameter{pRankVariants}{value},  #Ranking variants
	   'ravgft|genmodModelsFamilyType:s' => \$parameter{genmodModelsFamilyType}{value},
	   'ravcad|genmodcaddFiles:s'  => \@{$parameter{genmodcaddFiles}{value}},  #Comma separated list
	   'ravspi|spidexFile:s' => \$parameter{spidexFile}{value},
	   'ravwg|wholeGene=n'  => \$parameter{wholeGene}{value},  #Allow compound pairs in intronic regions
	   'ravrpf|genmodModelsReducedPenetranceFile:s' => \$parameter{genmodModelsReducedPenetranceFile}{value},
	   'ravrm|rankModelFile:s' => \$parameter{rankModelFile}{value},  #The rank modell config.ini path
	   'ravbcf|rankVariantBCFFile=n' => \$parameter{rankVariantBCFFile}{value},  #Produce compressed vcfs
	   'pScK|pSampleCheck=n' => \$parameter{pSampleCheck}{value},  #QC for samples gender and relationship
	   'pEvL|pEvaluation=n' => \$parameter{pEvaluation}{value},  #Compare concordance with NIST data set
	   'evlnid|NISTID:s' => \$parameter{NISTID}{value},
	   'evlnhc|NISTHighConfidenceCallSet:s' => \$parameter{NISTHighConfidenceCallSet}{value},
	   'evlnil|NISTHighConfidenceCallSetBed:s' => \$parameter{NISTHighConfidenceCallSetBed}{value},
	   'pQcC|pQCCollect=n' => \$parameter{pQCCollect}{value},  #QCmetrics collect
	   'qccsi|QCCollectSampleInfoFile:s' => \$parameter{QCCollectSampleInfoFile}{value},  #SampleInfo yaml file produced by MIP
	   'qccref|QCCollectRegExpFile:s' => \$parameter{QCCollectRegExpFile}{value},  #Regular expression yaml file
	   'pMqC|pMultiQC=n' => \$parameter{pMultiQC}{value},  #Aggregate bioinformatics reports
	   'pReM|pRemoveRedundantFiles=n' => \$parameter{pRemoveRedundantFiles}{value},
	   'pArS|pAnalysisRunStatus=n' => \$parameter{pAnalysisRunStatus}{value},  #AnalysisRunStatus change flag in sampleInfo file if allowed to execute
	   'pSac|pSacct=n' => \$parameter{pSacct}{value},
    ) or &Help({USAGE => $USAGE,
		exitCode => 1,
	       });

## Change relative path to absolute path for certain parameters 
&UpdateToAbsolutePath({parameterHashRef => \%parameter,
		      });

if (exists($parameter{configFile}{value})) {  #Input from cmd

    ## Loads a YAML file into an arbitrary hash and returns it.
    %scriptParameter = &LoadYAML({yamlFile => $parameter{configFile}{value},
				 });
    
    ##Special case:Enable/activate MIP. Cannot be changed from cmd or config
    $scriptParameter{MIP} = $parameter{MIP}{default};

    ##Special case:Required when turning of vcfParser to know how many files should be analysed (.select.vcf or just .vcf)
    $scriptParameter{VcfParserOutputFileCount} = $parameter{VcfParserOutputFileCount}{default};

    ## Compare keys in two hashes
    &CompareHashKeys({referenceHashRef => \%scriptParameter,
		      comparisonHashRef => \%parameter,
		     });

    my @activeParameters = ("clusterConstantPath", "analysisConstantPath", "analysisType", "alignerOutDir"); 

    ## Replace config parameter with cmd info for active parameter
    &ReplaceConfigParamWithCMDInfo({parameterHashRef => \%parameter,
				    scriptParameterHashRef => \%scriptParameter,
				    parameterNameArrayRef => \@activeParameters,
				   });

    foreach my $orderParameterElement (@orderParameters) {  #Loop through all parameters and update info   

	## Updates the config file to particular user/cluster for entries following specifications. Leaves other entries untouched.
	&UpdateConfigFile({scriptParameterHashRef => \%scriptParameter,
			   parameterNameRef => \$orderParameterElement,
			   familyIDRef => \$parameter{familyID}{value},
			  });
    }
    
    ##Remove previous analysis specific info not relevant for current run e.g. log file
    delete($scriptParameter{logFile});
}

###Populate scriptParameters{parameterName} => 'Value'
foreach my $orderParameterElement (@orderParameters) {
    
    ## 3 type of variables: MIP, path or program/program_parameters each is handled in the AddToScriptParameter subroutine.
    ## Checks and sets user input or default values to scriptParameters
    &AddToScriptParameter({parameterHashRef => \%parameter,
			   scriptParameterHashRef => \%scriptParameter,
			   sampleInfoHashRef => \%sampleInfo,
			   fileInfoHashRef => \%fileInfo,
			   supportedCaptureKitHashRef => \%supportedCaptureKit,
			   broadcastsArrayRef => \@broadcasts,
			   associatedProgramsArrayRef => \@{ $parameter{$orderParameterElement}{associatedProgram}},
			   parameterName => $orderParameterElement,
			  });

    ## Special case for parameters that are dependent on other parameters values
    if ($orderParameterElement eq "outDataDir") {  #Set defaults depending on $scriptParameter{outDataDir} value that now has been set

	$parameter{sampleInfoFile}{default} = catfile($scriptParameter{outDataDir}, $scriptParameter{familyID}, $scriptParameter{familyID}."_qc_sampleInfo.yaml");

	## Set the default Log4perl file using supplied dynamic parameters.
	$parameter{logFile}{default} = &DeafultLog4perlFile({scriptParameterHashRef => \%scriptParameter,
							     cmdInputRef => \$parameter{logFile}{value},
							     scriptRef => \$script,
							     dateRef => \$date,
							     dateTimeStampRef => \$dateTimeStamp,
							    });

	$parameter{QCCollectSampleInfoFile}{default} = $parameter{sampleInfoFile}{default};
    }
    if ($orderParameterElement eq "logFile") {

	## Creates log for the master script
	my $config = &CreateLog4perlCongfig({filePathRef => \$scriptParameter{logFile},
					  });
	Log::Log4perl->init(\$config);
	$logger = Log::Log4perl->get_logger("MIPLogger");
    }
    if ($orderParameterElement eq "pedigreeFile") {  #Write QC for only pedigree data used in analysis                                                        
	
	if (defined($scriptParameter{pedigreeFile})) {

	    make_path(catdir($scriptParameter{outDataDir}, $scriptParameter{familyID}));  #Create family directory
	    my $yamlFile = catfile($scriptParameter{outDataDir}, $scriptParameter{familyID}, "qc_pedigree.yaml");

	    ## Writes a YAML hash to file
	    &WriteYAML({yamlHashRef => \%sampleInfo,
			yamlFilePathRef => \$yamlFile,
		       });
 
	    ## Removes all elements at hash third level except keys in allowedEntries
	    &RemovePedigreeElements({hashRef => \%sampleInfo,
				    });
	}	
    }
    if ($orderParameterElement eq "humanGenomeReference") {  #Supply humanGenomeReference to mosaikAlignReference if required

	if ( (defined($scriptParameter{humanGenomeReference})) && (defined($fileInfo{humanGenomeReferenceNameNoEnding})) ) {

	    ## Sets parameters with autoBuild enabled to the new value dependent on $referenceFileNameRef
	    &SetAutoBuildFeature({parameterHashRef => \%parameter,
				  scriptParameterHashRef => \%scriptParameter,
				  fileInfoHashRef => \%fileInfo,
				  broadcastsArrayRef => \@broadcasts,
				  parameterName => "mosaikAlignReference",
				  referenceFileEndingRef => \$fileInfo{mosaikAlignReference},
				  referenceFileNameRef => \$fileInfo{humanGenomeReferenceNameNoEnding},
				 });
	    &SetAutoBuildFeature({parameterHashRef => \%parameter,
				  scriptParameterHashRef => \%scriptParameter,
				  fileInfoHashRef => \%fileInfo,
				  broadcastsArrayRef => \@broadcasts,
				  parameterName => "mosaikJumpDbStub",
				  referenceFileEndingRef => \$fileInfo{mosaikJumpDbStub},
				  referenceFileNameRef => \$fileInfo{humanGenomeReferenceNameNoEnding},
				 });
	    &SetAutoBuildFeature({parameterHashRef => \%parameter,
				  scriptParameterHashRef => \%scriptParameter,
				  fileInfoHashRef => \%fileInfo,
				  broadcastsArrayRef => \@broadcasts,
				  parameterName => "bwaBuildReference",
				  referenceFileEndingRef => \$fileInfo{bwaBuildReference},
				  referenceFileNameRef => \$scriptParameter{humanGenomeReference},
				 });
	}
    }
} 


###Checks

## Check Existance of files and directories
foreach my $parameterName (keys %parameter) {

    if (exists($parameter{$parameterName}{existsCheck})) {

	&CheckParameterFiles({parameterHashRef => \%parameter,
			      scriptParameterHashRef => \%scriptParameter,
			      sampleInfoHashRef => \%sampleInfo,
			      fileInfoHashRef => \%fileInfo,
			      supportedCaptureKitHashRef => \%supportedCaptureKit,
			      annovarTableHashRef => \%annovarTable,
			      broadcastsArrayRef => \@broadcasts,
			      annovarSupportedTableNamesArrayRef => \@annovarSupportedTableNames,
			      associatedProgramsArrayRef => \@{ $parameter{$parameterName}{associatedProgram}},
			      parameterName => $parameterName,
			      parameterExistsCheck => $parameter{$parameterName}{existsCheck},
			     });
    }
}


## Detect family constellation based on pedigree file
$parameter{dynamicParameters}{trio} = &DetectTrio({scriptParameterHashRef => \%scriptParameter,
						   sampleInfoHashRef => \%sampleInfo,
						  });

## Detect number of founders (i.e. parents ) based on pedigree file
&DetectFounders({scriptParameterHashRef => \%scriptParameter,
		 sampleInfoHashRef => \%sampleInfo,
		});

## Check email adress format
if (exists($scriptParameter{email})) {  #Allow no malformed email adress
    
    &CheckEmailAddress({emailRef => \$scriptParameter{email},
		       });
}


## Check programs in path, and executable
&CheckCommandinPath({parameterHashRef => \%parameter,
		     scriptParameterHashRef => \%scriptParameter,
		    });

## Test that the familyID and the sampleID(s) exists and are unique. Check if id sampleID contains "_".
&CheckUniqueIDNs({scriptParameterHashRef => \%scriptParameter,
		  sampleIdArrayRef => \@{$scriptParameter{sampleIDs}},
		 });

## Check sampleID provided in exomeTargetBed is included in the analysis and only represented once
&CheckSampleIDInExomeTargetBed({scriptParameterHashRef => \%scriptParameter,
				sampleIdArrayRef => \@{$scriptParameter{sampleIDs}},
			       });

## Compares the number of elements in two arrays and exits if the elements are not equal
&CompareArrayElements({arrayRef => \@{$scriptParameter{sampleIDs}},
		       arrayQueryRef => \@{$scriptParameter{inFilesDirs}},
		       parameterName => "sampleIDs",
		       parameterNameQuery => "inFileDirs",
		      });


## Check that VEP directory and VEP cache match
&CheckVEPDirectories({vepDirectoryPathRef => \$scriptParameter{vepDirectoryPath},
		      vepDirectoryCacheRef => \$scriptParameter{vepDirectoryCache},
		     });

## PicardToolsMergeSamFilesPrevious
if(@{$parameter{picardToolsMergeSamFilesPrevious}{value}}) {

    ## Checks if previous alignments have been supplied for each sampleID. Saves merge info in sampleInfo hash.
    &CheckMergePicardToolsMergeSamFilesPrevious({scriptParameterHashRef => \%scriptParameter,
						 fileInfoHashRef => \%fileInfo,
						});
}
else {  #Not supplied - Set to 0 to handle correctly in program subroutines 
    
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  #Set for all sampleIDs
	
	$fileInfo{ $scriptParameter{familyID} }{ $scriptParameter{sampleIDs}[$sampleIDCounter] }{picardToolsMergeSamFilesPrevious} = 0;
    }
}


## Adds dynamic aggregate information from definitions to parameterHash
&AddToParameter({parameterHashRef => \%parameter,
		 aggregateArrayRef => ["type:program",  #Collects all programs that MIP can handle
				       "programType:variantCaller",  #Collects all variantCallers
				       "programType:structuralVariantCaller",  #Collects all structural variantCallers
				       "programType:aligner",
				       "reference:referencesDir",  #Collects all references in that are supposed to be in referenceDirectory
				       "removeRedundantFiles:yes"],  #Collect all programs that are variantCallers
		});
## Check correct value for program mode in MIP
&CheckProgramMode({parameterHashRef => \%parameter,
		   scriptParameterHashRef => \%scriptParameter
		  });


## Check that the correct number of aligners is used in MIP and sets the aligner flag accordingly
&CheckAligner({parameterHashRef => \%parameter,
	       scriptParameterHashRef => \%scriptParameter,
	       broadcastsArrayRef => \@broadcasts,
	      });

## Broadcast set parameters info
foreach my $parameterInfo (@broadcasts) {

    $logger->info($parameterInfo, "\n");
}

### Cosmid references
## Defines the Cosmid manager hash keys and populates it from arguments
&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				  parameterName => "humanGenomeReference",
				  cosmidResourceName => "decoy",
				  cosmidResourceVersion => "5",
				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
				  compressedSwitch => "compressed",
				 });
&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				  parameterName => "sambambaDepthBed",
				  cosmidResourceName => "ccds",
				  cosmidResourceVersion => "latest",
				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
				 });
## Has changed to array parameter fix in future bioconda download
#&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
#				  parameterName => "GATKReAlignerINDELKnownSet1",
#				  cosmidResourceName => "indels",
#				  cosmidResourceVersion => $scriptParameter{GATKBundleDownLoadVersion}."/b".$fileInfo{humanGenomeReferenceVersion},
#				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
#				 });
## Has changed to array parameter fix in future bioconda download
#&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
#				  parameterName => "GATKReAlignerINDELKnownSet2",
#				  cosmidResourceName => "mills",
#				  cosmidResourceVersion => $scriptParameter{GATKBundleDownLoadVersion}."/b".$fileInfo{humanGenomeReferenceVersion},
#				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
#				 });
## Has changed to array parameter fix in future bioconda download
#&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
#				  parameterName => "GATKBaseReCalibrationKnownSite",
#				  cosmidResourceName => "dbsnp",
#				  cosmidResourceVersion => $scriptParameter{GATKBundleDownLoadVersion}."/b".$fileInfo{humanGenomeReferenceVersion},
#				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
#				 });
&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				  parameterName => "GATKHaploTypeCallerSNPKnownSet",
				  cosmidResourceName => "dbsnp",
				  cosmidResourceVersion => $scriptParameter{GATKBundleDownLoadVersion}."/b".$fileInfo{humanGenomeReferenceVersion},
				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
				 });
&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				  parameterName => "GATKVariantReCalibrationTrainingSetHapMap",
				  cosmidResourceName => "hapmap",
				  cosmidResourceVersion => $scriptParameter{GATKBundleDownLoadVersion}."/b".$fileInfo{humanGenomeReferenceVersion},
				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
				 });
&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				  parameterName => "GATKVariantReCalibrationTrainingSetMills",
				  cosmidResourceName => "mills",
				  cosmidResourceVersion => $scriptParameter{GATKBundleDownLoadVersion}."/b".$fileInfo{humanGenomeReferenceVersion},
				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
				 });
&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				  parameterName => "GATKVariantReCalibrationTrainingSet1000GOmni",
				  cosmidResourceName => "1000g_omni",
				  cosmidResourceVersion => $scriptParameter{GATKBundleDownLoadVersion}."/b".$fileInfo{humanGenomeReferenceVersion},
				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
				 });
&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				  parameterName => "GATKVariantReCalibrationTrainingSet1000GSNP",
				  cosmidResourceName => "1000g_snps",
				  cosmidResourceVersion => $scriptParameter{GATKBundleDownLoadVersion}."/b".$fileInfo{humanGenomeReferenceVersion},
				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
				 });
&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				  parameterName => "GATKVariantReCalibrationTrainingSetDbSNP",
				  cosmidResourceName => "dbsnp",
				  cosmidResourceVersion => $scriptParameter{GATKBundleDownLoadVersion}."/b".$fileInfo{humanGenomeReferenceVersion},
				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
				 });
&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				  parameterName => "GATKVariantEvalGold",
				  cosmidResourceName => "mills",
				  cosmidResourceVersion => $scriptParameter{GATKBundleDownLoadVersion}."/b".$fileInfo{humanGenomeReferenceVersion},
				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
				 }); 
&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				  parameterName => "GATKVariantEvalDbSNP",
				  cosmidResourceName => "dbsnpex",
				  cosmidResourceVersion => $scriptParameter{GATKBundleDownLoadVersion}."/b".$fileInfo{humanGenomeReferenceVersion},
				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
				 });

##Flag -> array parameters to enable multiple download via Cosmid using the same flag 
&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				  parameterName => "dbsnp_138.b37.vcf",
				  cosmidResourceName => "dbsnp",
				  cosmidResourceVersion => $scriptParameter{GATKBundleDownLoadVersion}."/b".$fileInfo{humanGenomeReferenceVersion},
				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
				 });
&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				  parameterName => "dbsnp_138.b37.excluding_sites_after_129.vcf",
				  cosmidResourceName => "dbsnpex",
				  cosmidResourceVersion => $scriptParameter{GATKBundleDownLoadVersion}."/b".$fileInfo{humanGenomeReferenceVersion},
				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
				 });
&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				  parameterName => "1000G_phase1.indels.b37.vcf",
				  cosmidResourceName => "1000g_omni",
				  cosmidResourceVersion => $scriptParameter{GATKBundleDownLoadVersion}."/b".$fileInfo{humanGenomeReferenceVersion},
				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
				 });
&DefineSupportedCosmidReferences({supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				  parameterName => "1000G_phase1.snps.high_confidence.b37.vcf",
				  cosmidResourceName => "1000g_snps",
				  cosmidResourceVersion => $scriptParameter{GATKBundleDownLoadVersion}."/b".$fileInfo{humanGenomeReferenceVersion},
				  humanGenomeReferenceVersionRef => \$fileInfo{humanGenomeReferenceVersion},
				 });


## Check that a Cosmid installation exists
&CheckCosmidInstallation({parameterHashRef => \%parameter,
			  scriptParameterHashRef => \%scriptParameter,
			  supportedCosmidReferenceHashRef => \%supportedCosmidReference
			 });

if ($scriptParameter{writeConfigFile} ne 0) {  #Write config file for family

    make_path(dirname($scriptParameter{writeConfigFile}));  #Create directory unless it already exists

    ## Writes a YAML hash to file
    &WriteYAML({yamlHashRef => \%scriptParameter,
		yamlFilePathRef => \$scriptParameter{writeConfigFile},
	       });
}

## Check that all active variant callers have a prioritization order and that the prioritization elements match a supported variant caller.
&CheckPrioritizeVariantCallers({parameterHashRef => \%parameter,
				scriptParameterHashRef => \%scriptParameter,
			       });

## Set contig prefix and contig names depending on reference used
&SetContigs({scriptParameterHashRef => \%scriptParameter,
	     fileInfoHashRef => \%fileInfo,
	    });

## Sorts array depending on reference array. NOTE: Only entries present in reference array will survive in sorted array.
@{$fileInfo{"SelectFileContigs"}} = &SizeSortSelectFileContigs({fileInfoHashRef =>\%fileInfo,
								hashKeyToSort => "SelectFileContigs",
								hashKeySortReference => "contigsSizeOrdered",
								analysisTypeRef => \$scriptParameter{analysisType},
							       });


## Detect the gender included in current analysis
($scriptParameter{maleFound}, $scriptParameter{femaleFound}, $scriptParameter{otherFound})  = &DetectSampleIdGender({scriptParameterHashRef => \%scriptParameter,
														     sampleInfoHashRef => \%sampleInfo,
														    });


## Removes contigY|chrY from SelectFileContigs if no males or 'other' found in analysis
&UpdateFileContigs({selectFileContigsArrayRef => \@{${fileInfo}{SelectFileContigs}},
		    maleFoundRef => \$scriptParameter{maleFound}
		   });

## Write CMD to MIP log file
&WriteCMDMipLog({parameterHashRef => \%parameter,
		 scriptParameterHashRef => \%scriptParameter,
		 orderParametersArrayRef => \@orderParameters,
		 scriptRef => \$script,
		 logFileRef => \$scriptParameter{logFile},
		 mipVersionRef => \$mipVersion,
		});

## Collects the ".fastq(.gz)" files from the supplied infiles directory. Checks if any of the files exist
&CollectInfiles({scriptParameterHashRef => \%scriptParameter,
		 inDirPathHashRef => \%inDirPath,
		 infileHashRef => \%infile,
		});

## Reformat files for MIP output, which have not yet been created into, correct format so that a sbatch script can be generated with the correct filenames
my $uncompressedFileSwitch = &InfilesReFormat({scriptParameterHashRef => \%scriptParameter,
					       sampleInfoHashRef => \%sampleInfo,
					       fileInfoHashRef => \%fileInfo,
					       infileHashRef => \%infile, 
					       inDirPathHashRef => \%inDirPath,
					       infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					       infilesBothStrandsNoEndingHashRef => \%infilesBothStrandsNoEnding,
					       laneHashRef => \%lane,
					       jobIDHashRef => \%jobID,
					       alignerOutDirRef => \$scriptParameter{alignerOutDir}, 
					       programName => "InfilesReFormat",
					      });


## Creates all fileendings as the samples is processed depending on the chain of modules activated
&CreateFileEndings({parameterHashRef => \%parameter,
		    scriptParameterHashRef => \%scriptParameter,
		    fileInfoHashRef => \%fileInfo,
		    infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		    orderParametersArrayRef => \@orderParameters,
		   });

## Create .fam file to be used in variant calling analyses
&CreateFamFile({scriptParameterHashRef => \%scriptParameter,
		executionMode => "system",
		famFilePath => catfile($scriptParameter{outDataDir}, $scriptParameter{familyID}, $scriptParameter{familyID}.".fam"),
	       });


## Add to SampleInfo
&AddToSampleInfo({scriptParameterHashRef => \%scriptParameter,
		  sampleInfoHashRef => \%sampleInfo,
		  fileInfoHashRef => \%fileInfo,
		 });


############
####MAIN####
############

if ($scriptParameter{dryRunAll} == 0) {

    $sampleInfo{ $scriptParameter{familyID} }{ $scriptParameter{familyID} }{AnalysisDate} = $dateTimeStamp;
    $sampleInfo{ $scriptParameter{familyID} }{ $scriptParameter{familyID} }{MIPVersion} = $mipVersion;
}

## Check if vt has processed references, if not try to reprocesses them before launcing modules
&CheckVTForReferences({parameterHashRef => \%parameter,
		       scriptParameterHashRef => \%scriptParameter,
		       sampleInfoHashRef => \%sampleInfo,
		       infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		       jobIDHashRef => \%jobID,
		       vtReferencesArrayRef => \@vtReferences,
		       VTDecompose => $scriptParameter{VTDecompose},
		       VTNormalize => $scriptParameter{VTNormalize},
		      });

if ( ($scriptParameter{pGZipFastq} > 0) && ($uncompressedFileSwitch eq "unCompressed") ) {  #GZip of fastq files

    $logger->info("[GZip for fastq files]\n");

    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  

	for (my $infileCounter=0;$infileCounter<scalar( @{ $infile{$scriptParameter{sampleIDs}[$sampleIDCounter]} });$infileCounter++) {  #To determine which sampleID had the uncompressed files
	    
	    if ($infile{$scriptParameter{sampleIDs}[$sampleIDCounter]}[$infileCounter] =~/.fastq$/) {
	
		## Automatically gzips fastq files
		&GZipFastq({parameterHashRef => \%parameter,
			    scriptParameterHashRef => \%scriptParameter,
			    sampleInfoHashRef => \%sampleInfo,
			    infileHashRef => \%infile,
			    inDirPathHashRef => \%inDirPath,
			    infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			    jobIDHashRef => \%jobID,
			    sampleID => $scriptParameter{sampleIDs}[$sampleIDCounter],
			    programName => "GZipFastq"
			   });
		last;  #Return to sampleID loop i.e. only call subroutine GZipFastq once per sampleID
	    }
	}
    }
}

if ($scriptParameter{pFastQC} > 0) {  #Run FastQC
    
    $logger->info("[FastQC]\n");

    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  
	
	&FastQC({parameterHashRef => \%parameter,
		 scriptParameterHashRef => \%scriptParameter,
		 sampleInfoHashRef => \%sampleInfo,
		 infileHashRef => \%infile, 
		 inDirPathHashRef => \%inDirPath,
		 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		 jobIDHashRef => \%jobID,
		 sampleID => \$scriptParameter{sampleIDs}[$sampleIDCounter],
		 programName => "FastQC",
		});	
    }
}

if ($scriptParameter{pMadeline} > 0) {  #Run Madeline
    
    $logger->info("[Madeline]\n");

    &Madeline({parameterHashRef => \%parameter,
	       scriptParameterHashRef => \%scriptParameter,
	       sampleInfoHashRef => \%sampleInfo,
	       infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
	       jobIDHashRef => \%jobID,
	       programName => "Madeline",
	      });	
}

if ($scriptParameter{pMosaikBuild} > 0) {  #Run MosaikBuild
    
    $logger->info("[MosaikBuild]\n");
    
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  
	
	&MosaikBuild({parameterHashRef => \%parameter,
		      scriptParameterHashRef => \%scriptParameter,
		      sampleInfoHashRef => \%sampleInfo,
		      infileHashRef => \%infile, 
		      inDirPathHashRef => \%inDirPath,
		      infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		      laneHashRef => \%lane,
		      jobIDHashRef => \%jobID,
		      sampleID => \$scriptParameter{sampleIDs}[$sampleIDCounter],
		      alignerOutDir => \$scriptParameter{alignerOutDir}, 
		      programName => "MosaikBuild",
		     });	
    }
}

if ($scriptParameter{pMosaikAlign} > 0) {  #Run MosaikAlign
    
    $logger->info("[MosaikAlign]\n");
    
    if ($scriptParameter{dryRunAll} != 1) {
	
	if ( ($parameter{humanGenomeReference}{buildFile} eq 1) || ($parameter{mosaikAlignReference}{buildFile} eq 1) || ($parameter{mosaikJumpDbStub}{buildFile} eq 1) ) {
	    
	    &BuildMosaikAlignPreRequisites(\%parameter, \%scriptParameter, \%sampleInfo, \%fileInfo, \%infilesLaneNoEnding, \%jobID, \%supportedCosmidReference, \@{$fileInfo{mosaikJumpDbStubFileEndings}}, \$fileInfo{humanGenomeReferenceSource}, \$fileInfo{humanGenomeReferenceVersion}, $scriptParameter{familyID}, $scriptParameter{alignerOutDir}, "MosaikAlign");
	    
	}
	if ( ($parameter{mosaikAlignNeuralNetworkPeFile}{buildFile} eq 1) || ($parameter{mosaikAlignNeuralNetworkSeFile}{buildFile} eq 1) ){

	    ## Locate MOSAIK path and move neural network files in place if lacking
	    &MoveMosaikNN(\%scriptParameter);
	}
    }
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  
	
	&MosaikAlign(\%parameter, \%scriptParameter, \%sampleInfo, \%fileInfo, \%infile, \%inDirPath, \%infilesLaneNoEnding, \%jobID, $scriptParameter{sampleIDs}[$sampleIDCounter], $scriptParameter{alignerOutDir}, "MosaikAlign");	
    }
}


if ($scriptParameter{pBwaMem} > 0) {  #Run BWA Mem
    
    $logger->info("[BWAMem]\n");
    
    if ($scriptParameter{dryRunAll} != 1) {

	if ( ($parameter{humanGenomeReference}{buildFile} eq 1) || ($parameter{bwaBuildReference}{buildFile} eq 1) ) {
	    
	    &BuildBwaPreRequisites({parameterHashRef => \%parameter,
				    scriptParameterHashRef => \%scriptParameter,
				    sampleInfoHashRef => \%sampleInfo,
				    fileInfoHashRef => \%fileInfo,
				    infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				    jobIDHashRef => \%jobID,
				    supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				    bwaBuildReferenceFileEndingsArrayRef => \@{$fileInfo{bwaBuildReferenceFileEndings}},
				    programName => "BwaMem",
				   });
	}
    }
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  
	
	&BWAMem({parameterHashRef => \%parameter,
		 scriptParameterHashRef => \%scriptParameter,
		 sampleInfoHashRef => \%sampleInfo,
		 fileInfoHashRef => \%fileInfo,
		 infileHashRef => \%infile, 
		 inDirPathHashRef => \%inDirPath,
		 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		 jobIDHashRef => \%jobID,
		 sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
		 programName => "BwaMem",
		});	
    }    
}

if ($scriptParameter{pPicardToolsMergeRapidReads} > 0) {  #Run PicardToolsMergeRapidReads - Relevant only in rapid mode
    
    $logger->info("[PicardToolsMergeRapidReads]\n");
    
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  
	
        #Merge all read batch processes to 1 file again containing sorted & indexed reads matching clinical test genes
	&PicardToolsMergeRapidReads({parameterHashRef => \%parameter,
				     scriptParameterHashRef => \%scriptParameter,
				     sampleInfoHashRef => \%sampleInfo,
				     fileInfoHashRef => \%fileInfo,
				     infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				     laneHashRef => \%lane,
				     jobIDHashRef => \%jobID,
				     sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
				     alignerOutDirRef => \$scriptParameter{alignerOutDir}, 
				     programName => "PicardToolsMergeRapidReads",
				    });
    }    
}

if ($scriptParameter{pBwaAln} > 0) {  #Run BWA Aln
    
    $logger->info("[BWA Aln]\n");

    if ($scriptParameter{dryRunAll} != 1) {

	if ( ($parameter{humanGenomeReference}{buildFile} eq 1) || ($parameter{bwaBuildReference}{buildFile} eq 1) ) {
	    
	    &BuildBwaPreRequisites({parameterHashRef => \%parameter,
				    scriptParameterHashRef => \%scriptParameter,
				    sampleInfoHashRef => \%sampleInfo,
				    fileInfoHashRef => \%fileInfo,
				    infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				    jobIDHashRef => \%jobID,
				    supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				    bwaBuildReferenceFileEndingsArrayRef => \@{$fileInfo{bwaBuildReferenceFileEndings}},
				    programName => "BwaAln",
				   });
	}
    }
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  
	
	&BWAAln(\%parameter, \%scriptParameter, \%sampleInfo, \%infile, \%inDirPath, \%infilesLaneNoEnding, \%infilesBothStrandsNoEnding, \%jobID, $scriptParameter{sampleIDs}[$sampleIDCounter], $scriptParameter{alignerOutDir}, "BwaAln");	
    }    
}

if ($scriptParameter{pBwaSampe} > 0) {  #Run BWA Sampe
    
    $logger->info("[BWA Sampe]\n");

    if ($scriptParameter{dryRunAll} != 1) {

	if ( ($parameter{humanGenomeReference}{buildFile} eq 1) || ($parameter{bwaBuildReference}{buildFile} eq 1) ) {
	    
	    &BuildBwaPreRequisites({parameterHashRef => \%parameter,
				    scriptParameterHashRef => \%scriptParameter,
				    sampleInfoHashRef => \%sampleInfo,
				    fileInfoHashRef => \%fileInfo,
				    infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				    jobIDHashRef => \%jobID,
				    supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				    bwaBuildReferenceFileEndingsArrayRef => \@{$fileInfo{bwaBuildReferenceFileEndings}},
				    programName => "BwaSampe",
				   });
	}
    }
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  
	
	&BWASampe(\%parameter, \%scriptParameter, \%sampleInfo, \%infile, \%inDirPath, \%infilesLaneNoEnding, \%infilesBothStrandsNoEnding, \%jobID, $scriptParameter{sampleIDs}[$sampleIDCounter], $scriptParameter{alignerOutDir}, "BwaSampe");
    }
}


if ($scriptParameter{reduceIO}) {  #Run consecutive models

    $scriptParameter{pBAMCalibrationBlock} = 1;  #Enable as program
    $logger->info("[BAMCalibrationBlock]\n");

    &BAMCalibrationBlock({parameterHashRef => \%parameter,
			  scriptParameterHashRef => \%scriptParameter,
			  sampleInfoHashRef => \%sampleInfo,
			  fileInfoHashRef => \%fileInfo,
			  infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			  laneHashRef => \%lane,
			  jobIDHashRef => \%jobID,
			  supportedCosmidReferenceHashRef => \%supportedCosmidReference,
			  alignerOutDirRef => \$scriptParameter{alignerOutDir}, 
			  programName => "BAMCalibrationBlock",
			 });
    
}
else {

    ##Always run even for single samples to rename them correctly for standardised downstream processing. 
    ##Will also split alignment per contig and copy to temporary directory for '-rio 1' block to enable selective removal of block submodules.
    $logger->info("[PicardTool MergeSamFiles]\n");
    
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  
	
	
	&PicardToolsMergeSamFiles({parameterHashRef => \%parameter,
				   scriptParameterHashRef => \%scriptParameter,
				   sampleInfoHashRef => \%sampleInfo,
				   fileInfoHashRef => \%fileInfo,
				   infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				   laneHashRef => \%lane,
				   jobIDHashRef => \%jobID,
				   sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
				   programName => "PicardToolsMergeSamFiles",
				  });
    }

    if ($scriptParameter{pPicardToolsMarkduplicates} > 0) {  #PicardTools Markduplicates
	
	$logger->info("[PicardTools Markduplicates]\n");
	
	for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  
	    
	    &PicardToolsMarkduplicates({parameterHashRef => \%parameter,
					scriptParameterHashRef => \%scriptParameter,
					sampleInfoHashRef => \%sampleInfo,
					fileInfoHashRef => \%fileInfo,
					infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					laneHashRef => \%lane,
					jobIDHashRef => \%jobID,
					sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
					programName => "PicardToolsMarkduplicates",
				       });
	}
    }

    if ($scriptParameter{pSambambaMarkduplicates} > 0) {  #Sambamba Markduplicates
	
	$logger->info("[Sambamba Markduplicates]\n");
	
	for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  
	    
	    &SambambaMarkduplicates({parameterHashRef => \%parameter,
				     scriptParameterHashRef => \%scriptParameter,
				     sampleInfoHashRef => \%sampleInfo,
				     fileInfoHashRef => \%fileInfo,
				     infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				     laneHashRef => \%lane,
				     jobIDHashRef => \%jobID,
				     sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
				     programName => "SambambaMarkduplicates",
				    });
	}
    }

    if ($scriptParameter{pGATKRealigner} > 0) {  #Run GATK ReAlignerTargetCreator/IndelRealigner
	
	$logger->info("[GATK ReAlignerTargetCreator/IndelRealigner]\n");
	
	&CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					     scriptParameterHashRef => \%scriptParameter,
					     sampleInfoHashRef => \%sampleInfo,
					     fileInfoHashRef => \%fileInfo,
					     infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					     jobIDHashRef => \%jobID,
					     supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					     programName => "GATKRealigner",
					    });

	&CheckBuildDownLoadPreRequisites({parameterHashRef => \%parameter,
					  scriptParameterHashRef => \%scriptParameter,
					  sampleInfoHashRef => \%sampleInfo,
					  infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					  jobIDHashRef => \%jobID,
					  supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					  programName => "GATKRealigner",
					 });

	if ($scriptParameter{dryRunAll} != 1) {
	    
	    &CheckBuildPTCHSMetricPreRequisites({parameterHashRef => \%parameter,
						 scriptParameterHashRef => \%scriptParameter,
						 sampleInfoHashRef => \%sampleInfo,
						 fileInfoHashRef => \%fileInfo,
						 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
						 jobIDHashRef => \%jobID,
						 programName => "GATKRealigner",
						});
	}
	for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {   
	    
	    &GATKReAligner({parameterHashRef => \%parameter,
			    scriptParameterHashRef => \%scriptParameter,
			    sampleInfoHashRef => \%sampleInfo,
			    fileInfoHashRef => \%fileInfo,
			    laneHashRef => \%lane,
			    infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			    jobIDHashRef => \%jobID,
			    sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
			    programName => "GATKRealigner",
			   });
	}
    }

    if ($scriptParameter{pGATKBaseRecalibration} > 0) {  #Run GATK BaseRecalibrator/PrintReads
	
	$logger->info("[GATK BaseRecalibrator/PrintReads]\n");
	
	&CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					     scriptParameterHashRef => \%scriptParameter,
					     sampleInfoHashRef => \%sampleInfo,
					     fileInfoHashRef => \%fileInfo,
					     infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					     jobIDHashRef => \%jobID,
					     supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					     programName => "GATKBaseRecalibration",
					    });

	&CheckBuildDownLoadPreRequisites({parameterHashRef => \%parameter,
					  scriptParameterHashRef => \%scriptParameter,
					  sampleInfoHashRef => \%sampleInfo,
					  infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					  jobIDHashRef => \%jobID,
					  supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					  programName => "GATKBaseRecalibration",
					 });
	
	if ($scriptParameter{dryRunAll} != 1) {
	    
	    &CheckBuildPTCHSMetricPreRequisites({parameterHashRef => \%parameter,
						 scriptParameterHashRef => \%scriptParameter,
						 sampleInfoHashRef => \%sampleInfo,
						 fileInfoHashRef => \%fileInfo,
						 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
						 jobIDHashRef => \%jobID,
						 programName => "GATKBaseRecalibration",
						});
	}
	for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {   
	    
	    &GATKBaseReCalibration({parameterHashRef => \%parameter,
				    scriptParameterHashRef => \%scriptParameter,
				    sampleInfoHashRef => \%sampleInfo,
				    fileInfoHashRef => \%fileInfo,
				    laneHashRef => \%lane,
				    infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				    jobIDHashRef => \%jobID,
				    sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
				    programName => "GATKBaseRecalibration",
				   });
	}
    }    
}


if ($scriptParameter{pChanjoSexCheck} > 0) {
    
    $logger->info("[ChanjoSexCheck]\n");
    
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  #For all SampleIDs
	
	&ChanjoSexCheck({parameterHashRef => \%parameter,
			 scriptParameterHashRef => \%scriptParameter,
			 sampleInfoHashRef => \%sampleInfo,
			 fileInfoHashRef => \%fileInfo,
			 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			 laneHashRef => \%lane,
			 jobIDHashRef => \%jobID,
			 sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
			 programName => "ChanjoSexCheck",
			});
    }
}

if ($scriptParameter{pSambambaDepth} > 0) {
    
    $logger->info("[SambambaDepth]\n");
    
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  #For all SampleIDs
	
	&SambambaDepth({parameterHashRef => \%parameter,
			scriptParameterHashRef => \%scriptParameter,
			sampleInfoHashRef => \%sampleInfo,
			fileInfoHashRef => \%fileInfo,
			infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			laneHashRef => \%lane,
			jobIDHashRef => \%jobID,
			sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
			programName => "SambambaDepth",
		       });
    }
}


if ($scriptParameter{pGenomeCoverageBED} > 0) {  #Run GenomeCoverageBED
    
    $logger->info("[GenomeCoverageBED]\n"); 
    
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  
	
	&GenomeCoverageBED({parameterHashRef => \%parameter,
			    scriptParameterHashRef => \%scriptParameter,
			    sampleInfoHashRef => \%sampleInfo,
			    fileInfoHashRef => \%fileInfo,
			    infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			    laneHashRef => \%lane,
			    jobIDHashRef => \%jobID,
			    sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
			    programName => "GenomeCoverageBED",
			   });
    }
}

if ($scriptParameter{pPicardToolsCollectMultipleMetrics} > 0) {  #Run PicardToolsCollectMultipleMetrics
    
    $logger->info("[PicardToolsCollectMultipleMetrics]\n");   
    
    &CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					 scriptParameterHashRef => \%scriptParameter,
					 sampleInfoHashRef => \%sampleInfo,
					 fileInfoHashRef => \%fileInfo,
					 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					 jobIDHashRef => \%jobID,
					 supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					 programName => "PicardToolsCollectMultipleMetrics",
					});
    
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  
	
	&PicardToolsCollectMultipleMetrics({parameterHashRef => \%parameter,
					    scriptParameterHashRef => \%scriptParameter,
					    sampleInfoHashRef => \%sampleInfo,
					    fileInfoHashRef => \%fileInfo,
					    infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					    laneHashRef => \%lane,
					    jobIDHashRef => \%jobID,
					    sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
					    programName => "PicardToolsCollectMultipleMetrics",
					   });
    }
}

if ($scriptParameter{pPicardToolsCalculateHSMetrics} > 0) {  #Run PicardToolsCalculateHSMetrics
    
    $logger->info("[PicardToolsCalculateHSMetrics]\n");   
    
    &CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					 scriptParameterHashRef => \%scriptParameter,
					 sampleInfoHashRef => \%sampleInfo,
					 fileInfoHashRef => \%fileInfo,
					 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					 jobIDHashRef => \%jobID,
					 supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					 programName => "PicardToolsCalculateHSMetrics",
					});

    if ($scriptParameter{dryRunAll} != 1) {
	
	&CheckBuildPTCHSMetricPreRequisites({parameterHashRef => \%parameter,
					     scriptParameterHashRef => \%scriptParameter,
					     sampleInfoHashRef => \%sampleInfo,
					     fileInfoHashRef => \%fileInfo,
					     infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					     jobIDHashRef => \%jobID,
					     programName => "PicardToolsCalculateHSMetrics",
					    });
    }
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  
	
	&PicardToolsCalculateHSMetrics({parameterHashRef => \%parameter,
					scriptParameterHashRef => \%scriptParameter,
					sampleInfoHashRef => \%sampleInfo,
					fileInfoHashRef => \%fileInfo,
					infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					laneHashRef => \%lane,
					jobIDHashRef => \%jobID,
					sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
					programName => "PicardToolsCalculateHSMetrics",
				       });
    }
}

if ($scriptParameter{pRCovPlots} > 0) {  #Run Rcovplot scripts   
    
    $logger->info("[RCovPlots]\n");	
    
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  
	
	&RCoveragePlots(\%parameter, \%scriptParameter, \%sampleInfo, \%fileInfo, \%lane, \%infilesLaneNoEnding, \%jobID, $scriptParameter{sampleIDs}[$sampleIDCounter], $scriptParameter{alignerOutDir}, "RCovPlots");	
    }
}


if ($scriptParameter{pCNVnator} > 0) {  #Run CNVnator
    
    $logger->info("[CNVnator]\n");
    
    &CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					 scriptParameterHashRef => \%scriptParameter,
					 sampleInfoHashRef => \%sampleInfo,
					 fileInfoHashRef => \%fileInfo,
					 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					 jobIDHashRef => \%jobID,
					 supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					 programName => "CNVnator",
					});
    &CheckBuildDownLoadPreRequisites({parameterHashRef => \%parameter,
				      scriptParameterHashRef => \%scriptParameter,
				      sampleInfoHashRef => \%sampleInfo,
				      infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				      jobIDHashRef => \%jobID,
				      supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				      programName => "CNVnator",
				     });
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  #For all SampleIDs

	&CNVnator({parameterHashRef => \%parameter,
		   scriptParameterHashRef => \%scriptParameter,
		   sampleInfoHashRef => \%sampleInfo,
		   fileInfoHashRef => \%fileInfo,
		   infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		   laneHashRef => \%lane,
		   jobIDHashRef => \%jobID,
		   sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
		   programName => "CNVnator",
		  });
    }
}


if ($scriptParameter{pDelly} > 0) {  #Run Delly
    
    $logger->info("[Delly]\n");
    
    &CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					 scriptParameterHashRef => \%scriptParameter,
					 sampleInfoHashRef => \%sampleInfo,
					 fileInfoHashRef => \%fileInfo,
					 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					 jobIDHashRef => \%jobID,
					 supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					 programName => "Delly",
					});
    &CheckBuildDownLoadPreRequisites({parameterHashRef => \%parameter,
				      scriptParameterHashRef => \%scriptParameter,
				      sampleInfoHashRef => \%sampleInfo,
				      infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				      jobIDHashRef => \%jobID,
				      supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				      programName => "Delly",
				     });
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  #For all SampleIDs

	&Delly({parameterHashRef => \%parameter,
		scriptParameterHashRef => \%scriptParameter,
		sampleInfoHashRef => \%sampleInfo,
		fileInfoHashRef => \%fileInfo,
		infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		laneHashRef => \%lane,
		jobIDHashRef => \%jobID,
		sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
		programName => "Delly",
	       });
    }
}

if ($scriptParameter{pManta} > 0) {  #Run Manta
    
    $logger->info("[Manta]\n");
    
    &CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					 scriptParameterHashRef => \%scriptParameter,
					 sampleInfoHashRef => \%sampleInfo,
					 fileInfoHashRef => \%fileInfo,
					 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					 jobIDHashRef => \%jobID,
					 supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					 programName => "Manta",
					});
    &CheckBuildDownLoadPreRequisites({parameterHashRef => \%parameter,
				      scriptParameterHashRef => \%scriptParameter,
				      sampleInfoHashRef => \%sampleInfo,
				      infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				      jobIDHashRef => \%jobID,
				      supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				      programName => "Manta",
				     });
    &Manta({parameterHashRef => \%parameter,
	    scriptParameterHashRef => \%scriptParameter,
	    sampleInfoHashRef => \%sampleInfo,
	    fileInfoHashRef => \%fileInfo,
	    infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
	    laneHashRef => \%lane,
	    jobIDHashRef => \%jobID,
	    programName => "Manta",
	   });
}

if ($scriptParameter{pFindTranslocations} > 0) {  #Run FindTranslocations
    
    $logger->info("[FindTranslocations]\n");
    
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {  #For all SampleIDs

	&FindTranslocations({parameterHashRef => \%parameter,
			     scriptParameterHashRef => \%scriptParameter,
			     sampleInfoHashRef => \%sampleInfo,
			     fileInfoHashRef => \%fileInfo,
			     infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			     laneHashRef => \%lane,
			     jobIDHashRef => \%jobID,
			     sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
			     programName => "FindTranslocations",
			    });
    }
}


if ($scriptParameter{pSVCombineVariantCallSets} > 0) {  #Run CombineVariantCallSets. For all SampleIDs and StructuralVariantCallers

    $logger->info("[SVCombineVariantCallSets]\n");

    &SVCombineVariantCallSets({parameterHashRef => \%parameter,
			       scriptParameterHashRef => \%scriptParameter,
			       sampleInfoHashRef => \%sampleInfo,
			       fileInfoHashRef => \%fileInfo,
			       infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			       laneHashRef => \%lane,
			       jobIDHashRef => \%jobID,
			       programName => "SVCombineVariantCallSets",
			      });
}

if ($scriptParameter{pSVVariantEffectPredictor} > 0) {  #Run SVVariantEffectPredictor. Done per family
    
    $logger->info("[SVVariantEffectPredictor]\n");
    
    &SVVariantEffectPredictor({parameterHashRef => \%parameter,
			       scriptParameterHashRef => \%scriptParameter,
			       sampleInfoHashRef => \%sampleInfo,
			       fileInfoHashRef => \%fileInfo,
			       infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			       jobIDHashRef => \%jobID,
			       programName => "SVVariantEffectPredictor",
			      });
}


if ($scriptParameter{pSVVCFParser} > 0) {  #Run pSVVCFParser. Done per family
    
    $logger->info("[SVVCFParser]\n");
    
    &SVVCFParser({parameterHashRef => \%parameter,
		  scriptParameterHashRef => \%scriptParameter,
		  sampleInfoHashRef => \%sampleInfo,
		  fileInfoHashRef => \%fileInfo,
		  infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		  jobIDHashRef => \%jobID,
		  programName => "SVVCFParser",
		 });
}


if ($scriptParameter{pSVRankVariants} > 0) {  #Run SVRankVariants. Done per family
    
    $logger->info("[SVRankVariants]\n");
    
    &SVRankVariants({parameterHashRef => \%parameter,
		     scriptParameterHashRef => \%scriptParameter,
		     sampleInfoHashRef => \%sampleInfo,
		     fileInfoHashRef => \%fileInfo,
		     infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		     jobIDHashRef => \%jobID,
		     programName => "SVRankVariants",
		    });
}


if ($scriptParameter{pSamToolsMpileUp} > 0) {  #Run SamToolsMpileUp
    
    $logger->info("[SamTools MpileUp]\n");
    
    &CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					 scriptParameterHashRef => \%scriptParameter,
					 sampleInfoHashRef => \%sampleInfo,
					 fileInfoHashRef => \%fileInfo,
					 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					 jobIDHashRef => \%jobID,
					 supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					 programName => "SamToolsMpileUp",
					});
    &CheckBuildDownLoadPreRequisites({parameterHashRef => \%parameter,
				      scriptParameterHashRef => \%scriptParameter,
				      sampleInfoHashRef => \%sampleInfo,
				      infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				      jobIDHashRef => \%jobID,
				      supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				      programName => "SamToolsMpileUp",
				     });
    
    &SamToolsMpileUp({parameterHashRef => \%parameter,
		      scriptParameterHashRef => \%scriptParameter,
		      sampleInfoHashRef => \%sampleInfo,
		      fileInfoHashRef => \%fileInfo,
		      infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		      laneHashRef => \%lane,
		      jobIDHashRef => \%jobID,
		      programName => "SamToolsMpileUp",
		     });
}

if ($scriptParameter{pFreebayes} > 0) {  #Run Freebayes
    
    $logger->info("[Freebayes]\n");
    
    &CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					 scriptParameterHashRef => \%scriptParameter,
					 sampleInfoHashRef => \%sampleInfo,
					 fileInfoHashRef => \%fileInfo,
					 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					 jobIDHashRef => \%jobID,
					 supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					 programName => "Freebayes",
					});
    &CheckBuildDownLoadPreRequisites({parameterHashRef => \%parameter,
				      scriptParameterHashRef => \%scriptParameter,
				      sampleInfoHashRef => \%sampleInfo,
				      infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				      jobIDHashRef => \%jobID,
				      supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				      programName => "Freebayes",
				     });
    
    &Freebayes({parameterHashRef => \%parameter,
		scriptParameterHashRef => \%scriptParameter,
		sampleInfoHashRef => \%sampleInfo,
		fileInfoHashRef => \%fileInfo,
		infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		laneHashRef => \%lane,
		jobIDHashRef => \%jobID,
		programName => "Freebayes",
	       });
}


if ($scriptParameter{pGATKHaploTypeCaller} > 0) {  #Run GATK HaploTypeCaller
    
    $logger->info("[GATK HaplotypeCaller]\n");
    
    &CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					 scriptParameterHashRef => \%scriptParameter,
					 sampleInfoHashRef => \%sampleInfo,
					 fileInfoHashRef => \%fileInfo,
					 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					 jobIDHashRef => \%jobID,
					 supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					 programName => "GATKHaploTypeCaller",
					});

    &CheckBuildDownLoadPreRequisites({parameterHashRef => \%parameter,
				      scriptParameterHashRef => \%scriptParameter,
				      sampleInfoHashRef => \%sampleInfo,
				      infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				      jobIDHashRef => \%jobID,
				      supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				      programName => "GATKHaploTypeCaller",
				     });
    
    if ( ($scriptParameter{dryRunAll} != 1) && ($scriptParameter{analysisType} ne "genomes") ) {
	
	&CheckBuildPTCHSMetricPreRequisites({parameterHashRef => \%parameter,
					     scriptParameterHashRef => \%scriptParameter,
					     sampleInfoHashRef => \%sampleInfo,
					     fileInfoHashRef => \%fileInfo,
					     infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					     jobIDHashRef => \%jobID,
					     programName => "GATKHaploTypeCaller",
					    });
    }
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {
	
	&GATKHaploTypeCaller({parameterHashRef => \%parameter,
			      scriptParameterHashRef => \%scriptParameter,
			      sampleInfoHashRef => \%sampleInfo,
			      fileInfoHashRef => \%fileInfo,
			      infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			      laneHashRef => \%lane,
			      jobIDHashRef => \%jobID,
			      sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
			      programName => "GATKHaploTypeCaller",
			     });
    }
}

if ($scriptParameter{pGATKGenoTypeGVCFs} > 0) {  #Run GATK GenoTypeGVCFs. Done per family

    $logger->info("[GATK GenoTypeGVCFs]\n");

    &CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					 scriptParameterHashRef => \%scriptParameter,
					 sampleInfoHashRef => \%sampleInfo,
					 fileInfoHashRef => \%fileInfo,
					 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					 jobIDHashRef => \%jobID,
					 supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					 programName => "GATKGenoTypeGVCFs",
					});

    &GATKGenoTypeGVCFs({parameterHashRef => \%parameter,
			scriptParameterHashRef => \%scriptParameter,
			sampleInfoHashRef => \%sampleInfo,
			fileInfoHashRef => \%fileInfo,
			infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			laneHashRef => \%lane,
			jobIDHashRef => \%jobID,
			programName => "GATKGenoTypeGVCFs",
		       });

    &GATKConcatenateGenoTypeGVCFs({parameterHashRef => \%parameter,
				   scriptParameterHashRef => \%scriptParameter,
				   sampleInfoHashRef => \%sampleInfo,
				   fileInfoHashRef => \%fileInfo,
				   infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				   laneHashRef => \%lane,
				   jobIDHashRef => \%jobID,
				   programName => "GATKGenoTypeGVCFs",
				  });
}

if ($scriptParameter{pGATKVariantRecalibration} > 0) {  #Run GATK VariantRecalibrator/ApplyRecalibration. Done per family

    $logger->info("[GATK VariantRecalibrator/ApplyRecalibration]\n");

    &CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					 scriptParameterHashRef => \%scriptParameter,
					 sampleInfoHashRef => \%sampleInfo,
					 fileInfoHashRef => \%fileInfo,
					 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					 jobIDHashRef => \%jobID,
					 supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					 programName => "GATKVariantRecalibration",
					});
    &CheckBuildDownLoadPreRequisites({parameterHashRef => \%parameter,
				      scriptParameterHashRef => \%scriptParameter,
				      sampleInfoHashRef => \%sampleInfo,
				      infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				      jobIDHashRef => \%jobID,
				      supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				      programName => "GATKVariantRecalibration",
				     });

    if ( ($scriptParameter{dryRunAll} != 1) && ($scriptParameter{analysisType} ne "genomes") ) {
	
	&CheckBuildPTCHSMetricPreRequisites({parameterHashRef => \%parameter,
					     scriptParameterHashRef => \%scriptParameter,
					     sampleInfoHashRef => \%sampleInfo,
					     fileInfoHashRef => \%fileInfo,
					     infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					     jobIDHashRef => \%jobID,
					     programName => "GATKVariantRecalibration",
					    });
    }
    &GATKVariantReCalibration({parameterHashRef => \%parameter,
			       scriptParameterHashRef => \%scriptParameter,
			       sampleInfoHashRef => \%sampleInfo,
			       fileInfoHashRef => \%fileInfo,
			       infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			       jobIDHashRef => \%jobID,
			       programName => "GATKVariantRecalibration",
			      });
}


if ($scriptParameter{pGATKCombineVariantCallSets} > 0) {  #Run GATKCombineVariantCallSets. Done per family

    $logger->info("[GATKCombineVariantCallSets]\n");

    &GATKCombineVariantCallSets({parameterHashRef => \%parameter,
				 scriptParameterHashRef => \%scriptParameter,
				 sampleInfoHashRef => \%sampleInfo,
				 fileInfoHashRef => \%fileInfo,
				 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				 jobIDHashRef => \%jobID,
				 programName => "GATKCombineVariantCallSets",
				});
}

if ($scriptParameter{pSampleCheck} > 0) {  #Run SampleCheck. Done per family

    $logger->info("[SampleCheck]\n");

    &SampleCheck({parameterHashRef => \%parameter,
		  scriptParameterHashRef => \%scriptParameter,
		  sampleInfoHashRef => \%sampleInfo,
		  fileInfoHashRef => \%fileInfo,
		  infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		  jobIDHashRef => \%jobID,
		  programName => "SampleCheck",
		 });
}

if ($scriptParameter{pEvaluation} > 0) {  #Run Evaluation. Done per family

    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) {

	if ($scriptParameter{sampleIDs}[$sampleIDCounter]=~/$scriptParameter{NISTID}/) {
	    
	    $logger->info("[Evaluation]\n");
	    
	    &Evaluation({parameterHashRef => \%parameter,
			 scriptParameterHashRef => \%scriptParameter,
			 sampleInfoHashRef => \%sampleInfo,
			 fileInfoHashRef => \%fileInfo,
			 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			 jobIDHashRef => \%jobID,
			 sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
			 callType => "BOTH",
			 programName => "Evaluation",
			});
	}
    }
}


if ($scriptParameter{pGATKPhaseByTransmission} > 0) {  #Run GATK PhaseByTransmission. Done per family
    
    $logger->info("[GATK PhaseByTransmission]\n");
    
    &CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					 scriptParameterHashRef => \%scriptParameter,
					 sampleInfoHashRef => \%sampleInfo,
					 fileInfoHashRef => \%fileInfo,
					 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					 jobIDHashRef => \%jobID,
					 supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					 programName => "GATKPhaseByTransmission",
					});
    &GATKPhaseByTransmission(\%parameter, \%scriptParameter, \%sampleInfo, \%fileInfo, \%infilesLaneNoEnding, \%jobID, $scriptParameter{familyID}, $scriptParameter{alignerOutDir}, "BOTH", "GATKPhaseByTransmission");
}

if ($scriptParameter{pGATKReadBackedPhasing} > 0) {  #Run GATK ReadBackedPhasing. Done per family. NOTE: Needs phased calls
    
    $logger->info("[GATK ReadBackedPhasing]\n");
    
    &CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					 scriptParameterHashRef => \%scriptParameter,
					 sampleInfoHashRef => \%sampleInfo,
					 fileInfoHashRef => \%fileInfo,
					 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					 jobIDHashRef => \%jobID,
					 supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					 programName => "GATKReadBackedPhasing",
					});
    &GATKReadBackedPhasing(\%parameter, \%scriptParameter, \%sampleInfo, \%fileInfo, \%lane, \%infilesLaneNoEnding, \%jobID, $scriptParameter{familyID}, $scriptParameter{alignerOutDir}, "BOTH", "GATKReadBackedPhasing");
}

if ($scriptParameter{pGATKVariantEvalAll} > 0) {  #Run GATK VariantEval for all variants. Done per sampleID

    $logger->info("[GATK VariantEval All]\n");

    &CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					 scriptParameterHashRef => \%scriptParameter,
					 sampleInfoHashRef => \%sampleInfo,
					 fileInfoHashRef => \%fileInfo,
					 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					 jobIDHashRef => \%jobID,
					 supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					 programName => "GATKVariantEvalAll",
					});

    &CheckBuildDownLoadPreRequisites({parameterHashRef => \%parameter,
				      scriptParameterHashRef => \%scriptParameter,
				      sampleInfoHashRef => \%sampleInfo,
				      infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				      jobIDHashRef => \%jobID,
				      supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				      programName => "GATKVariantEvalAll",
				     });

    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) { 
	
	&GATKVariantEvalAll({parameterHashRef => \%parameter,
			     scriptParameterHashRef => \%scriptParameter,
			     sampleInfoHashRef => \%sampleInfo,
			     fileInfoHashRef => \%fileInfo,
			     laneHashRef => \%lane,
			     infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			     jobIDHashRef => \%jobID,
			     sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
			     programName => "GATKVariantEvalAll",
			      });
    }
}

### If no males or other remove contig Y from all downstream analysis
## Removes contigY|chrY from SelectFileContigs if no males or other found in analysis
&UpdateFileContigs({selectFileContigsArrayRef => \@{${fileInfo}{contigsSizeOrdered}},
		    maleFoundRef => \$scriptParameter{maleFound},
		   });

if ($scriptParameter{reduceIO}) {  #Run consecutive models
    
    $scriptParameter{pVariantAnnotationBlock} = 1;  #Enable as program
    $logger->info("[VariantAnnotationBlock]\n");
    
    &VariantAnnotationBlock({parameterHashRef => \%parameter,
			     scriptParameterHashRef => \%scriptParameter,
			     sampleInfoHashRef => \%sampleInfo,
			     fileInfoHashRef => \%fileInfo,
			     infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			     jobIDHashRef => \%jobID,
			     annovarTableHashRef => \%annovarTable,
			     supportedCosmidReferenceHashRef => \%supportedCosmidReference,
			     alignerOutDirRef => \$scriptParameter{alignerOutDir}, 
			     callType => "BOTH",
			     programName => "VariantAnnotationBlock",
			    });
}
else {

    $logger->info("[PrepareForVariantAnnotationBlock]\n");
    
    &PrepareForVariantAnnotationBlock({parameterHashRef => \%parameter,
					 scriptParameterHashRef => \%scriptParameter,
					 sampleInfoHashRef => \%sampleInfo,
					 fileInfoHashRef => \%fileInfo,
					 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					 jobIDHashRef => \%jobID,
					 callType => "BOTH",
					 programName => "PrepareForVariantAnnotationBlock",
					});
    
    if ($scriptParameter{pVT} > 0) {  #Run VT. Done per family
	
	$logger->info("[VT]\n");
	
	&VT({parameterHashRef => \%parameter,
	     scriptParameterHashRef => \%scriptParameter,
	     sampleInfoHashRef => \%sampleInfo,
	     fileInfoHashRef => \%fileInfo,
	     infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
	     jobIDHashRef => \%jobID,
	     callType => "BOTH",
	     programName => "VT",
	    });
    }
    if ($scriptParameter{pVariantEffectPredictor} > 0) {  #Run VariantEffectPredictor. Done per family
	
	$logger->info("[VariantEffectPredictor]\n");
	
	&VariantEffectPredictor({parameterHashRef => \%parameter,
				 scriptParameterHashRef => \%scriptParameter,
				 sampleInfoHashRef => \%sampleInfo,
				 fileInfoHashRef => \%fileInfo,
				 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				 jobIDHashRef => \%jobID,
				 callType => "BOTH",
				 programName => "VariantEffectPredictor",
				});
    }
    if ($scriptParameter{pVCFParser} > 0) {  #Run pVCFParser. Done per family

	$logger->info("[VCFParser]\n");
    
	&VCFParser({parameterHashRef => \%parameter,
		    scriptParameterHashRef => \%scriptParameter,
		    sampleInfoHashRef => \%sampleInfo,
		    fileInfoHashRef => \%fileInfo,
		    infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		    jobIDHashRef => \%jobID,
		    callType => "BOTH",
		    programName => "VCFParser",
		   });
    }
    
    if ($scriptParameter{pAnnovar} > 0) {  #Run Annovar. Done per family
	
	$logger->info("[Annovar]\n");
	
	&CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					     scriptParameterHashRef => \%scriptParameter,
					     sampleInfoHashRef => \%sampleInfo,
					     fileInfoHashRef => \%fileInfo,
					     infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					     jobIDHashRef => \%jobID,
					     supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					     programName => "Annovar",
					    });
	
	for (my $tableNamesCounter=0;$tableNamesCounter<scalar(@{$scriptParameter{annovarTableNames}});$tableNamesCounter++) {  #For all specified table names
	    
	    if ($parameter{ $scriptParameter{annovarTableNames}[$tableNamesCounter] }{buildFile} eq 1) {
		
		&BuildAnnovarPreRequisites({parameterHashRef => \%parameter,
					    scriptParameterHashRef => \%scriptParameter,
					    sampleInfoHashRef => \%sampleInfo,
					    infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					    jobIDHashRef => \%jobID,
					    annovarTableHashRef => \%annovarTable,
					    programName => "Annovar",
					   });
		last;  #Will handle all build tables within sbatch script
	    }
	}
	&Annovar({parameterHashRef => \%parameter,
		  scriptParameterHashRef => \%scriptParameter,
		  sampleInfoHashRef => \%sampleInfo,
		  fileInfoHashRef => \%fileInfo,
		  infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		  jobIDHashRef => \%jobID,
		  annovarTableHashRef => \%annovarTable,
		  callType => "BOTH",
		  programName => "Annovar",
		 });
    }

    if ($scriptParameter{pSnpEff} > 0) {  #Run snpEff. Done per family
	
	$logger->info("[SnpEff]\n");
	
	&CheckBuildDownLoadPreRequisites({parameterHashRef => \%parameter,
					  scriptParameterHashRef => \%scriptParameter,
					  sampleInfoHashRef => \%sampleInfo,
					  infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					  jobIDHashRef => \%jobID,
					  supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					  programName => "SnpEff",
					 });

	&SnpEff({parameterHashRef => \%parameter,
		 scriptParameterHashRef => \%scriptParameter,
		 sampleInfoHashRef => \%sampleInfo,
		 fileInfoHashRef => \%fileInfo,
		 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		 jobIDHashRef => \%jobID,
		 callType => "BOTH",
		 programName => "SnpEff",
		});
    }
    if ($scriptParameter{pRankVariants} > 0) {  #Run RankVariants. Done per family
	
	$logger->info("[RankVariants]\n");
	
	&RankVariants({parameterHashRef => \%parameter,
		       scriptParameterHashRef => \%scriptParameter,
		       sampleInfoHashRef => \%sampleInfo,
		       fileInfoHashRef => \%fileInfo,
		       infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		       jobIDHashRef => \%jobID,
		       callType => "BOTH",
		       programName => "RankVariants",
		      });
    }
}

if ($scriptParameter{pGATKVariantEvalExome} > 0) {  #Run GATK VariantEval for exome variants. Done per sampleID
    
    $logger->info("[GATK VariantEval Exome]\n");
    
    &CheckBuildHumanGenomePreRequisites({parameterHashRef => \%parameter,
					 scriptParameterHashRef => \%scriptParameter,
					 sampleInfoHashRef => \%sampleInfo,
					 fileInfoHashRef => \%fileInfo,
					 infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
					 jobIDHashRef => \%jobID,
					 supportedCosmidReferenceHashRef => \%supportedCosmidReference,
					 programName => "GATKVariantEvalExome",
					});
    &CheckBuildDownLoadPreRequisites({parameterHashRef => \%parameter,
				      scriptParameterHashRef => \%scriptParameter,
				      sampleInfoHashRef => \%sampleInfo,
				      infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
				      jobIDHashRef => \%jobID,
				      supportedCosmidReferenceHashRef => \%supportedCosmidReference,
				      programName => "GATKVariantEvalExome",
				     });
    
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$scriptParameter{sampleIDs}});$sampleIDCounter++) { 
	
	&GATKVariantEvalExome({parameterHashRef => \%parameter,
			       scriptParameterHashRef => \%scriptParameter,
			       sampleInfoHashRef => \%sampleInfo,
			       fileInfoHashRef => \%fileInfo,
			       laneHashRef => \%lane,
			       infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			       jobIDHashRef => \%jobID,
			       sampleIDRef => \$scriptParameter{sampleIDs}[$sampleIDCounter],
			       programName => "GATKVariantEvalExome",
			      });
    }
}

if ($scriptParameter{pQCCollect} > 0) {  #Run QCCollect. Done per family

    $logger->info("[QCCollect]\n");

    &QCCollect({parameterHashRef => \%parameter,
		scriptParameterHashRef => \%scriptParameter,
		sampleInfoHashRef => \%sampleInfo,
		infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
		jobIDHashRef => \%jobID,
		programName => "QCCollect",
	       });
}


if ($scriptParameter{pMultiQC} > 0) {

    $logger->info("[MultiQC]\n");

    &MultiQC({parameterHashRef => \%parameter,
	      scriptParameterHashRef => \%scriptParameter,
	      sampleInfoHashRef => \%sampleInfo,
	      infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
	      jobIDHashRef => \%jobID,
	      programName => "MultiQC",
	     });
}


if ($scriptParameter{pRemoveRedundantFiles} > 0) {  #Sbatch generation of removal of alignment files
    
    $logger->info("[Removal of redundant files]\n");

    &RemoveRedundantFiles({parameterHashRef => \%parameter,
			   scriptParameterHashRef => \%scriptParameter,
			   sampleInfoHashRef => \%sampleInfo,
			   fileInfoHashRef => \%fileInfo,
			   infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			   jobIDHashRef => \%jobID,
			   laneHashRef => \%lane,
			   programName => "RemoveRedundantFiles",
			  });	
}

if ( ($scriptParameter{pAnalysisRunStatus} == 1) && ($scriptParameter{dryRunAll} == 0) ) {

    $sampleInfo{ $scriptParameter{familyID} }{ $scriptParameter{familyID} }{AnalysisRunStatus} = "notFinished";  #Add analysis run status flag.
}

if ($scriptParameter{pAnalysisRunStatus} > 0) {

    $logger->info("[AnalysisRunStatus]\n");

    &AnalysisRunStatus({parameterHashRef => \%parameter,
			scriptParameterHashRef => \%scriptParameter,
			sampleInfoHashRef => \%sampleInfo,
			infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
			jobIDHashRef => \%jobID,
			programName => "AnalysisRunStatus",
		       });
}

if ( ($scriptParameter{pSacct} > 0) && ($scriptParameter{dryRunAll} == 0) ) {  #Sbatch generation of sacct jobID data info

    $logger->info("[Sacct]\n");

    &Sacct({parameterHashRef => \%parameter,
	    scriptParameterHashRef => \%scriptParameter,
	    sampleInfoHashRef => \%sampleInfo,
	    infilesLaneNoEndingHashRef => \%infilesLaneNoEnding,
	    jobIDHashRef => \%jobID,
	    alignerOutDirRef => \$scriptParameter{alignerOutDir}, 
	    programName => "Sacct",
	   });
}

#Write QC for programs used in analysis                                                                                                                         
if ($scriptParameter{sampleInfoFile} ne 0) {#Write SampleInfo to yaml file
    
    ## Writes a YAML hash to file
    &WriteYAML({yamlHashRef => \%sampleInfo,
		yamlFilePathRef =>  \$scriptParameter{sampleInfoFile},
	       });
}


######################
####SubRoutines#######
######################

sub Sacct {

##Sacct
    
##Function : Output SLURM info on each job via Sacct command
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $programName                => The program name

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
     &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 1;

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$familyIDRef,
					    programName => $programName,
					    programDirectory => $$alignerOutDirRef,
					   });

    print $FILEHANDLE "sacct --format=jobid,jobname%50,account,partition,alloccpus,TotalCPU,elapsed,start,end,state,exitcode -j ";

    ## If run in dry run mode this will be empty
    if (keys %{$jobIDHashRef}) {

	say $FILEHANDLE join(',', @{${$jobIDHashRef}{Pan}{Pan}});
    }
    close($FILEHANDLE);

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 7, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName,
		       jobDependency => "afterany",
		      });
    }
}


sub AnalysisRunStatus { 

##AnalysisRunStatus
    
##Function : Execute last in MAIN chain, tests that all recorded files exists, have a file sixe greater than zero, checks QC-metrics for PASS or FAIL and sets analysis run status flag to finished.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyIDRef, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $programName                => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$familyIDRef,
					    programName => $programName,
					    programDirectory => lc($programName),
					   });
    
    say $FILEHANDLE q?status="0"?;  #Set status flagg so that perl notFinished remains in sampleInfoFile

    ###Test all file that are supposed to exists as they are present in the sampleInfo file
    my @pathsArrayRef;

    ## Collects all programs file path(s) created by MIP located in %sampleInfo
    &CollectPathEntries({sampleInfoHashRef => $sampleInfoHashRef,
			 pathsArrayRef => \@pathsArrayRef,
			});

    ## Collects all programs outfile path(s) created by MIP as OutDirectory->value and outfile->value located in %sampleInfo.
    &CollectOutDataPathsEntries({parameterHashRef => $parameterHashRef,
				 scriptParameterHashRef => $scriptParameterHashRef,
				 sampleInfoHashRef => $sampleInfoHashRef,
				 pathsArrayRef => \@pathsArrayRef,
				});

    print $FILEHANDLE q?files=(?;  #Create bash array
    foreach my $path (@pathsArrayRef) {

	if (defined($path)) {  #First analysis and dry run will otherwise cause try to print uninitialized values
	    
	    print $FILEHANDLE q?"?.$path.q?" ?;  #Add to array
	}
    }
    say $FILEHANDLE ")";  #Close bash array
    say $FILEHANDLE q?for file in ${files[@]}?;  #loop over files
    say $FILEHANDLE "do ";  #for each element in array do
    say $FILEHANDLE "\t".q?if [ -s $file ]; then?;  #file exists and is larger than zero
    say $FILEHANDLE "\t\t".q?echo "Found file $file"?;  #Echo
    say $FILEHANDLE "\t".q?else?;
    say $FILEHANDLE "\t\t".q?echo "Could not find $file" >&2?;  #Redirect to STDERR
    say $FILEHANDLE "\t\t".q?status="1"?;  #Set status flagg so that perl notFinished remains in sampleInfoFile
    say $FILEHANDLE "\t".q?fi?;
    say $FILEHANDLE q?done ?, "\n";

    ## Test VariantEffectPredictor fork status. If VariantEffectPredictor is unable to fork it will prematurely end the analysis and we will lose variants. 
    if (defined(${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{VariantEffectPredictor}{OutFile})) {

	my $variantEffectPredictorFile = catfile(${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{VariantEffectPredictor}{OutDirectory}, ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{VariantEffectPredictor}{OutFile});

	print $FILEHANDLE q?if grep -q "WARNING Unable to fork" ?;  #not output the matched text only return the exit status code
	say $FILEHANDLE $variantEffectPredictorFile.q?; then?;  #Infile
	say $FILEHANDLE "\t".q?status="1"?;  #Found pattern
	say $FILEHANDLE "\t".q?echo "VariantEffectorPredictor fork status=FAILED for file: ?.$variantEffectPredictorFile.q?" >&2?;  #Echo
	say $FILEHANDLE q?else?;  #Infile is clean
	say $FILEHANDLE "\t".q?echo "VariantEffectorPredictor fork status=PASSED for file: ?.$variantEffectPredictorFile.q?" >&2?;  #Echo
	say $FILEHANDLE q?fi?, "\n";
    }

    ## Test if FAIL exists in QCCollect file i.e. issues with samples e.g. Sex and seq data correlation, relationship etc
    if (defined(${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{QCCollect}{OutFile})) {

	my $QCCollectFile = catfile(${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{QCCollect}{OutDirectory}, ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{QCCollect}{OutFile});
	
	print $FILEHANDLE q?if grep -q "FAIL" ?;  #not output the matched text only return the exit status code
	say $FILEHANDLE $QCCollectFile.q?; then?;  #Infile
	say $FILEHANDLE "\t".q?status="1"?;  #Found pattern
	say $FILEHANDLE "\t".q?echo "QCCollect status=FAILED for file: ?.$QCCollectFile.q?" >&2?;  #Echo
	say $FILEHANDLE q?else?;  #Infile is clean
	say $FILEHANDLE "\t".q?echo "QCCollect status=PASSED for file: ?.$QCCollectFile.q?" >&2?;  #Echo
	say $FILEHANDLE q?fi?, "\n";
	
    }

    ## Test integrity of vcf data keys in header and body
    if ( (defined(${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{VCFFile}{Clinical}{Path})) || (defined(${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{VCFFile}{Research}{Path})) ) {

	print $FILEHANDLE q?perl -MTest::Harness -e ' ?;  #Execute on cmd
	print $FILEHANDLE q?my %args = (?;  #Adjust arguments to harness object
	print $FILEHANDLE q?verbosity => 1, ?;  #Print individual test results to STDOUT
	print $FILEHANDLE q?test_args => { ?;  #Argument to test script 

	if (defined(${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{VCFFile}{Clinical}{Path})) {

	    print $FILEHANDLE q?"test select file" => [ ?;  #Add test for select file using alias
	    print $FILEHANDLE q?"?.${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{VCFFile}{Clinical}{Path}.q?", ?;  #Infile
	    print $FILEHANDLE q?"?.${$scriptParameterHashRef}{writeConfigFile}.q?", ?;  #ConfigFile
	    print $FILEHANDLE q?], ?;
	}

	if (defined(${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{VCFFile}{Research}{Path})) {

	    print $FILEHANDLE q?"test research file" => [ ?;  #Add test research file using alias
	    print $FILEHANDLE q?"?.${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{VCFFile}{Research}{Path}.q?", ?;  #Infile
	    print $FILEHANDLE q?"?.${$scriptParameterHashRef}{writeConfigFile}.q?", ?;  #ConfigFile
	    print $FILEHANDLE q?], ?;
	}

	print $FILEHANDLE q?}); ?;
	print $FILEHANDLE q?my $harness = TAP::Harness->new( \%args ); ?;  #Create harness using arguments provided
	print $FILEHANDLE q?$harness->runtests( ?;  #Execute test(s)  

	if (defined(${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{VCFFile}{Clinical}{Path})) {

	    print $FILEHANDLE q?["?.catfile($Bin, "t", "test.t").q?", "test select file"], ?;
	}

	if (defined(${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{VCFFile}{Research}{Path})) {

	    print $FILEHANDLE q?["?.catfile($Bin, "t", "test.t").q?", "test research file"], ?;
	}
	print $FILEHANDLE q?)'?;
	say $FILEHANDLE "\n";
    }

    say $FILEHANDLE q?if [ $status -ne 1 ]; then?;  #eval status flag
    say $FILEHANDLE "\t".q?perl -i -p -e 'if($_=~/AnalysisRunStatus\:/) { s/notFinished/Finished/g }' ?.${$scriptParameterHashRef}{sampleInfoFile}.q? ?;
    say $FILEHANDLE q?else?;  #Found discrepancies - exit
    say $FILEHANDLE "\t".q?exit 1?;
    say $FILEHANDLE q?fi?, "\n";

    close($FILEHANDLE); 
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 7, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
    return;
}


sub RemoveRedundantFiles {

##RemoveRedundantFiles
    
##Function : Generates a sbatch script, which removes redundant files.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $laneHashRef, $familyIDRef, $alignerOutDir, $callType, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $familyIDRef                => The familyID
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis
##         : $callType                   => The variant call type
##         : $programName                => The program name

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
     &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $reduceIORef = \${$scriptParameterHashRef}{reduceIO};
    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 10;
    my $xargsFileName;

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$familyIDRef,
					    programName => $programName,
					    programDirectory => $$alignerOutDirRef,
					   });

    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) { 
	
	my $sampleID = ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter];
	
	## Sample files
	##Removes intermediate files from the MIP analysis depending on set MIP parameters
	&RemoveFiles({parameterHashRef => $parameterHashRef,
		      scriptParameterHashRef => $scriptParameterHashRef,
		      infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		      sampleInfoHashRef => $sampleInfoHashRef,
		      fileInfoHashRef => $fileInfoHashRef,
		      laneHashRef => $laneHashRef,
		      FILEHANDLE => $FILEHANDLE,
		      sampleID => $sampleID,
		      reduceIORef => $reduceIORef,
		      alignerOutDirRef => $alignerOutDirRef,
		      programName => "RemoveFiles",
		     });
    }	
    ## Family files
    ##Removes intermediate files from the MIP analysis depending on set MIP parameters
    &RemoveFiles({parameterHashRef => $parameterHashRef,
		  scriptParameterHashRef => $scriptParameterHashRef,
		  infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		  sampleInfoHashRef => $sampleInfoHashRef,
		  fileInfoHashRef => $fileInfoHashRef,
		  laneHashRef => $laneHashRef,
		  FILEHANDLE => $FILEHANDLE,
		  reduceIORef => $reduceIORef,
		  alignerOutDirRef => $alignerOutDirRef,
		  programName => "RemoveFiles",
		 });
    close($FILEHANDLE);
}


sub MultiQC {

##MultiQC
    
##Function : Aggregate bioinforamtics reports per case
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyIDRef, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $programName                => The program name

    my ($argHashRef) = @_;
   
    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     programName => $programName,
	);
     &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 1;

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$familyIDRef,
					    programName => $programName,
					    programDirectory => lc($programName),
					   });
    
    ## Assign directories
    my $programOutDirectoryName = ${$parameterHashRef}{"p".$programName}{outDirectoryName};

    foreach my $sampleID (@{${$scriptParameterHashRef}{sampleIDs}}) {

	my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $sampleID);
	my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $sampleID, $programOutDirectoryName);

	print $FILEHANDLE "multiqc ";
	print $FILEHANDLE "--force ";
	print $FILEHANDLE "--outdir ".$outSampleDirectory." ";
	say $FILEHANDLE $inSampleDirectory;
    }

    close($FILEHANDLE);

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 7, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub QCCollect { 

##QCCollect
    
##Function : Collect qc metrics for this analysis run.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $jobIDHashRef, $familyIDRef, $callType, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $callType                   => The variant call type
##         : $programName                => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $reduceIORef = \${$scriptParameterHashRef}{reduceIO};
    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$familyIDRef,
					    programName => $programName,
					    programDirectory => lc($programName),
					   });
    
    my $infile = catfile(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, "qc_sampleinfo.yaml");
    my $inFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef);
    my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef);

    print $FILEHANDLE "perl ".${$scriptParameterHashRef}{inScriptDir}."/qcCollect.pl ";
    print $FILEHANDLE "-sampleInfoFile ".${$scriptParameterHashRef}{QCCollectSampleInfoFile}." ";
    print $FILEHANDLE "-regExpFile ".$$referencesDirRef."/".${$scriptParameterHashRef}{QCCollectRegExpFile}." ";
    say $FILEHANDLE "-o ".$outFamilyDirectory."/".$$familyIDRef."_qcmetrics.yaml ", "\n";     
    
    close($FILEHANDLE); 

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	## Collect QC metadata info for later use
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       programName => "QCCollect",
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef."_qcmetrics.yaml",
		       outDataType => "infileDependent"
		      });

	## Add qcmetrics path to sampleInfo
	${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{QCCollect}{QCCollectMetricsFile}{Path} = $outFamilyDirectory."/".$$familyIDRef."_qcmetrics.yaml";
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 7, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		       });
    }
}


sub Evaluation { 

##Evaluation
    
##Function : Compare metrics for this analysis run with the NIST reference dataset.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $jobIDHashRef, $familyIDRef, $sampleIDRef, $callType, $alignerOutDirRef, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $sampleIDRef                => The sampleID {REF}
##         : $callType                   => The variant call type
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $programName                => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$familyIDRef,
					    programName => $programName,
					    programDirectory => lc($$alignerOutDirRef."/gatk/".$programName),
					    tempDirectory => $$tempDirectoryRef,
					    errorTrap => 0,  #Special case to allow "vcf.idx" to be created
					   });
    
    ## Assign directories
    my $inFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    my $outFamilyDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk", lc($programName));
    ${$parameterHashRef}{"p".$programName}{inDirectory} = $outFamilyDirectory;  #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pGATKCombineVariantCallSets}{fileTag};

    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE,
			path => catfile($inFamilyDirectory, $$familyIDRef.$infileTag.$callType.".vcf*"),
			tempDirectory => $$tempDirectoryRef
		       });
    say $FILEHANDLE "wait", "\n";
    
    ## Rename vcf samples. The samples array will replace the sample names in the same order as supplied.
    &RenameVCFSamples({sampleIDArrayRef => [${$scriptParameterHashRef}{NISTID}."-NIST"],
		       tempDirectoryRef => $tempDirectoryRef,
		       infile => catfile($$referencesDirRef, ${$scriptParameterHashRef}{NISTHighConfidenceCallSet}),
		       outfile => catfile($$tempDirectoryRef, "NIST.vcf"),
		       FILEHANDLE => $FILEHANDLE,
		      });
    
    ## BcfTools Stats
    say $FILEHANDLE "## bcfTools Stats";
    print $FILEHANDLE "bcftools stats ";
    print $FILEHANDLE catfile($$tempDirectoryRef, "NIST.vcf")." ";
    print $FILEHANDLE "> ".catfile($$tempDirectoryRef, "NIST.vcf.stats")." ";
    say $FILEHANDLE "\n";

    ## Generate ".idx" for downstream Picard by failling this process
    say $FILEHANDLE "## Generate '.idx' for downstream Picard by failling this process";
    
    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx2g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => $$tempDirectoryRef,
	       javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
	      });

    print $FILEHANDLE "-T SelectVariants ";  #Type of analysis to run
    print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
    print $FILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
    print $FILEHANDLE "-V: ".catfile($$tempDirectoryRef, "NIST.vcf")." ";
    print $FILEHANDLE "-o ".catfile($$tempDirectoryRef, "NISTXXX.vcf")." ";
    print $FILEHANDLE "-sn ".$$sampleIDRef."XXX ";  #Include genotypes from this sample
    say $FILEHANDLE "\n";

    ## Create .interval_list file from NIST union bed
    say $FILEHANDLE "## Prepare .interval_list file from NIST union bed\n";

    print $FILEHANDLE q?perl -nae 'unless($_=~/NC_007605/ || $_=~/hs37d5/) {print $_}' ?;
    print $FILEHANDLE catfile($$referencesDirRef, ${$fileInfoHashRef}{humanGenomeReferenceNameNoEnding}.".dict")." ";
    print $FILEHANDLE "> ".catfile($$tempDirectoryRef, "Homo_sapiens.GRCh37.dict")." ";
    say $FILEHANDLE "\n";

    print $FILEHANDLE "cat ";
    print $FILEHANDLE catfile($$tempDirectoryRef, "Homo_sapiens.GRCh37.dict")." ";
    print $FILEHANDLE catfile($$referencesDirRef, ${$scriptParameterHashRef}{NISTHighConfidenceCallSetBed})." ";
    print $FILEHANDLE "> ".catfile($$tempDirectoryRef, "NIST.bed.dict_body")." ";
    say $FILEHANDLE "\n";
    
    say $FILEHANDLE "## Remove target annotations, 'track', 'browse' and keep only 5 columns";
    print $FILEHANDLE q?perl  -nae 'if ($_=~/@/) {print $_;} elsif ($_=~/^track/) {} elsif ($_=~/^browser/) {} else {print @F[0], "\t", (@F[1] + 1), "\t", @F[2], "\t", "+", "\t", "-", "\n";}' ?;
    print $FILEHANDLE catfile($$tempDirectoryRef, "NIST.bed.dict_body")." ";  #Infile
    print $FILEHANDLE "> ".catfile($$tempDirectoryRef, "NIST.bed.dict_body_col_5.interval_list")." ";  #Remove unnecessary info and reformat 
    say $FILEHANDLE "\n";

    say $FILEHANDLE "## Create".${$scriptParameterHashRef}{NISTHighConfidenceCallSetBed}.".interval_list";
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx2g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
	       javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
	      });
    
    print $FILEHANDLE "IntervalListTools ";
    print $FILEHANDLE "INPUT=".catfile($$tempDirectoryRef, "NIST.bed.dict_body_col_5.interval_list")." ";
    print $FILEHANDLE "OUTPUT=".catfile($$tempDirectoryRef, "NIST.bed.interval_list")." ";
    say $FILEHANDLE "\n";

    ### MIP data
    ## GATK SelectVariants
    say $FILEHANDLE "## GATK SelectVariants";
    
    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx2g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => $$tempDirectoryRef,
	       javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
	      });

    print $FILEHANDLE "-T SelectVariants ";  #Type of analysis to run
    print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
    print $FILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
    print $FILEHANDLE "-V: ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf")." ";  #FamilyID infile
    print $FILEHANDLE "-o ".catfile($$tempDirectoryRef, "MIP.vcf")." ";  #SampleID exome outfile
    print $FILEHANDLE "-sn ".$$sampleIDRef." ";  #Include genotypes from this sample
    print $FILEHANDLE "-env ";
    say $FILEHANDLE "\n";

    ## Left align, trim and split allels
    say $FILEHANDLE "## GATK LeftAlignAndTrimVariants";
    
    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx2g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => $$tempDirectoryRef,
	       javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
	      });

    print $FILEHANDLE "-T LeftAlignAndTrimVariants ";  #Type of analysis to run
    print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
    print $FILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
    print $FILEHANDLE "--splitMultiallelics ";
    print $FILEHANDLE "--variant ".catfile($$tempDirectoryRef, "MIP.vcf")." ";  #SampleID infile
    print $FILEHANDLE "-o ".catfile($$tempDirectoryRef, "MIP_lts.vcf")." ";  #Outfile
    say $FILEHANDLE "\n";

    ## Modify since different ref genomes
    say $FILEHANDLE "## Modify since different ref genomes";
    print $FILEHANDLE q?perl -nae 'unless($_=~/##contig=<ID=NC_007605,length=171823>/ || $_=~/##contig=<ID=hs37d5,length=35477943>/) {print $_}' ?;
    print $FILEHANDLE catfile($$tempDirectoryRef, "MIP_lts.vcf")." ";  #Infile
    print $FILEHANDLE "> ".catfile($$tempDirectoryRef, "MIP_lts_refrm.vcf")." ";  #Outfile
    say $FILEHANDLE "\n";

    ## BcfTools Stats
    say $FILEHANDLE "## bcfTools Stats";
    print $FILEHANDLE "bcftools stats ";
    print $FILEHANDLE catfile($$tempDirectoryRef, "MIP_lts_refrm.vcf")." ";
    print $FILEHANDLE "> ".catfile($$tempDirectoryRef, "MIP_lts_refrm.vcf.stats")." ";
    say $FILEHANDLE "\n";

    ## Generate ".idx" for downstream Picard by failling this process
    say $FILEHANDLE "## Generate '.idx' for downstream Picard by failling this process";
    
    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx2g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => $$tempDirectoryRef,
	       javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
	      });

    print $FILEHANDLE "-T SelectVariants ";  #Type of analysis to run
    print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
    print $FILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
    print $FILEHANDLE "-V: ".catfile($$tempDirectoryRef, "MIP_lts_refrm.vcf")." ";
    print $FILEHANDLE "-o ".catfile($$tempDirectoryRef, "MIPXXX.vcf")." ";
    print $FILEHANDLE "-sn ".$$sampleIDRef."XXX ";  #Include genotypes from this sample
    say $FILEHANDLE "\n";

    
    say $FILEHANDLE "## Picard GenotypeConcordance - Genome restricted by union - good quality ";
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx2g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
	       javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
	      });
    
    print $FILEHANDLE "GenotypeConcordance ";
    print $FILEHANDLE "TRUTH_VCF=".catfile($$tempDirectoryRef, "NIST.vcf")." ";
    print $FILEHANDLE "CALL_VCF=".catfile($$tempDirectoryRef, "MIP_lts_refrm.vcf")." ";
    print $FILEHANDLE "OUTPUT=".catfile($$tempDirectoryRef, "compMIP.Vs.NIST_ADM1059A3_genome_bed")," ";
    print $FILEHANDLE "TRUTH_SAMPLE=ADM1059A3-NIST ";
    print $FILEHANDLE "CALL_SAMPLE=".$$sampleIDRef." ";
    print $FILEHANDLE "MIN_GQ=20 ";
    print $FILEHANDLE "MIN_DP=10 ";
    print $FILEHANDLE "INTERVALS=".catfile($$tempDirectoryRef, "NIST.bed.interval_list")." ";
    say $FILEHANDLE "\n";

    say $FILEHANDLE "## Picard GenotypeConcordance - Genome - good quality ";
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx2g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
	       javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
	      });
    
    print $FILEHANDLE "GenotypeConcordance ";
    print $FILEHANDLE "TRUTH_VCF=".catfile($$tempDirectoryRef, "NIST.vcf")." ";
    print $FILEHANDLE "CALL_VCF=".catfile($$tempDirectoryRef, "MIP_lts_refrm.vcf")." ";
    print $FILEHANDLE "OUTPUT=".catfile($$tempDirectoryRef, "compMIP.Vs.NIST_ADM1059A3_genome")." ";
    print $FILEHANDLE "TRUTH_SAMPLE=ADM1059A3-NIST ";
    print $FILEHANDLE "CALL_SAMPLE=".$$sampleIDRef." ";
    print $FILEHANDLE "MIN_GQ=20 ";
    print $FILEHANDLE "MIN_DP=10 ";
    say $FILEHANDLE "\n";

    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, "compMIP.Vs.NIST_ADM1059A3_genome*"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, "*vcf.stats"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";

    close($FILEHANDLE); 

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	## Add qcmetrics path to sampleInfo
	${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{QCCollect}{QCCollectMetricsFile}{Path} = catfile($outFamilyDirectory, $$familyIDRef."_qcmetrics.yaml");
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 2, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		       });
    }
}


sub RankVariants { 

##RankVariants
    
##Function : Annotate and score variants depending on mendelian inheritance, frequency and phenotype etc.
##Returns  : "|$xargsFileCounter"
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $callType, $programName, $programInfoPath, $fileName, $FILEHANDLE, $xargsFileCounter
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyIDRef {REF}
##         : $alignerOutDir              => The alignerOutDir used in the analysis
##         : $callType                   => The variant call type
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
##         : $fileName                   => File name
##         : $FILEHANDLE                 => Sbatch filehandle to write to
##         : $xargsFileCounter           => The xargs file counter

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $fileName = ${$argHashRef}{fileName};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $reduceIORef = \${$scriptParameterHashRef}{reduceIO};
    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 20;

    ## Set the number of cores
    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $genModnrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
					     nrCores => 16,
					    });  #Detect the number of cores to use per genmod process.
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script
	
	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    
	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$familyIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
							       nrofCores => $nrCores,
							       processTime => 10,
							       tempDirectory => $$tempDirectoryRef
							      });
    }

    ## Assign directories
    my $inFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    
    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pSnpEff}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{"p".$programName}{fileTag};

    my $vcfParserAnalysisType = "";
    my $vcfParserContigsArrayRef = \@{ ${$fileInfoHashRef}{contigsSizeOrdered} };  #Set default

    for (my $vcfParserOutputFileCounter=0;$vcfParserOutputFileCounter<${$scriptParameterHashRef}{VcfParserOutputFileCount};$vcfParserOutputFileCounter++) {
	
	if ($vcfParserOutputFileCounter == 1) {
	    
	    $vcfParserAnalysisType = ".selected";  #SelectFile variants
	    $vcfParserContigsArrayRef = \@{${$fileInfoHashRef}{SelectFileContigs}};  #Selectfile contigs
	}

	if ( ! $$reduceIORef) { #Run as individual sbatch script
	    
	    ## Copy file(s) to temporary directory
	    say $FILEHANDLE "## Copy file(s) to temporary directory";
	    $xargsFileCounter = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
							  XARGSFILEHANDLE => $XARGSFILEHANDLE,
							  arrayRef => $vcfParserContigsArrayRef,
							  fileName => $fileName,
							  programInfoPath => $programInfoPath,
							  nrCores => $nrCores,
							  xargsFileCounter => $xargsFileCounter,
							  infile => $$familyIDRef.$infileTag.$callType,
							  fileEnding => $vcfParserAnalysisType.".vcf*",
							  inDirectory => $inFamilyDirectory,
							  tempDirectory => ${$scriptParameterHashRef}{tempDirectory},
							 });
	}
	
	## Calculate Gene Models
	say $FILEHANDLE "## Calculate Gene Models";   

	if (${$scriptParameterHashRef}{analysisType} eq "exomes") {
	    
	    ## Clear trap for signal(s)
	    &ClearTrap({FILEHANDLE => $FILEHANDLE,
		       });
	}

	## Create file commands for xargs
	($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							     XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							     fileName => $fileName,
							     programInfoPath => $programInfoPath, 
							     nrCores => $genModnrCores,
							     xargsFileCounter => $xargsFileCounter,
							     firstCommand => "genmod",
							    });
	 
	## Process per contig
	for (my $contigsCounter=0;$contigsCounter<scalar(@{$vcfParserContigsArrayRef});$contigsCounter++) {
	     
	    my $contigRef = \${$vcfParserContigsArrayRef}[$contigsCounter];

	    ## Genmod Models
	    print $XARGSFILEHANDLE "-v ";  #Increase output verbosity
	    print $XARGSFILEHANDLE "models ";  #Annotate genetic models for vcf variants
	    print $XARGSFILEHANDLE "--temp_dir ".$$tempDirectoryRef." ";  #Temporary directory
	    print $XARGSFILEHANDLE "--family_file ".${$scriptParameterHashRef}{pedigreeFile}." ";  #Pedigree file
	    print $XARGSFILEHANDLE "--family_type ".${$scriptParameterHashRef}{genmodModelsFamilyType}." ";  #Family type

	    if (defined(${$scriptParameterHashRef}{genmodModelsReducedPenetranceFile})) {

		print $XARGSFILEHANDLE "--reduced_penetrance ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{genmodModelsReducedPenetranceFile})." ";  #Use list of genes that have been shown to display reduced penetrance
	    }
	    print $XARGSFILEHANDLE "--processes 4 ";  #Define how many processes that should be use for annotation 

	    if (${$scriptParameterHashRef}{pVariantEffectPredictor} > 0) {  #Use VEP annotations in compound models
		
		print $XARGSFILEHANDLE "--vep "; 
	    }
	    if (${$scriptParameterHashRef}{wholeGene} == 1) {
		
		print $XARGSFILEHANDLE "--whole_gene "; 
	    }
	    
	    print $XARGSFILEHANDLE "-o ".catfile(dirname(devnull()), "stdout")." ";  #OutFile
	    print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.$vcfParserAnalysisType.".vcf")." ";  #InFile
	    print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef."_models.stderr.txt ";  #Redirect xargs output to program specific stderr file
	    print $XARGSFILEHANDLE "| ";  #Pipe

	    ## Genmod Annotate
	    print $XARGSFILEHANDLE "genmod ";
	    print $XARGSFILEHANDLE "-v ";  #Increase output verbosity
	    print $XARGSFILEHANDLE "annotate ";  #Annotate vcf variants
	    print $XARGSFILEHANDLE "--temp_dir ".$$tempDirectoryRef." ";  #Temporary directory

	    foreach my $caddFile (@{${$scriptParameterHashRef}{genmodcaddFiles}}) {

		print $XARGSFILEHANDLE "--cadd_file ".catfile($$referencesDirRef, $caddFile)." ";  #CADD score file(s)
	    }
	    if (defined(${$scriptParameterHashRef}{spidexFile})) {
		
		print $XARGSFILEHANDLE "--spidex ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{spidexFile})." ";  #Spidex file
	    }

	    print $XARGSFILEHANDLE "-o ".catfile(dirname(devnull()), "stdout")." ";  #OutFile
	    print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef."_models_annotate.stderr.txt ";  #Redirect xargs output to program specific stderr file
	    print $XARGSFILEHANDLE "- ";  #InStream
	    print $XARGSFILEHANDLE "| ";  #Pipe

	    ## Genmod Score
	    print $XARGSFILEHANDLE "genmod ";
	    print $XARGSFILEHANDLE "-v ";  #Increase output verbosity
	    print $XARGSFILEHANDLE "score ";  #Score variants in a vcf file using Weighted sums
	    print $XARGSFILEHANDLE "--family_file ".${$scriptParameterHashRef}{pedigreeFile}." ";  #Pedigree file
	    print $XARGSFILEHANDLE "--family_type ".${$scriptParameterHashRef}{genmodModelsFamilyType}." ";  #Family type

	    if (defined(${$scriptParameterHashRef}{rankModelFile})) {
		
		print $XARGSFILEHANDLE "--score_config ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{rankModelFile})." ";  #Rank model config.ini file 
	    }
	    
	    print $XARGSFILEHANDLE "-o ".catfile(dirname(devnull()), "stdout")." ";  #OutFile
	    print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef."_models_annotate_score.stderr.txt ";  #Redirect xargs output to program specific stderr file
	    print $XARGSFILEHANDLE "- ";  #InStream
	    print $XARGSFILEHANDLE "| ";  #Pipe

	    ##Genmod Compound
	    print $XARGSFILEHANDLE "genmod ";
	    print $XARGSFILEHANDLE "-v ";  #Increase output verbosity
	    print $XARGSFILEHANDLE "compound ";  #Adjust score for compound variants in a vcf file
	    print $XARGSFILEHANDLE "--temp_dir ".$$tempDirectoryRef." ";  #Temporary directory

	    if (${$scriptParameterHashRef}{pVariantEffectPredictor} > 0) {  #Use VEP annotations in compound models
		
		print $XARGSFILEHANDLE "--vep "; 
	    }

	    print $XARGSFILEHANDLE "-o ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.$vcfParserAnalysisType."_models_annotate_score_compound.vcf")." ";  #OutFile
	    print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef."_models_annotate_score_compound.stderr.txt ";  #Redirect xargs output to program specific stderr file
	    say $XARGSFILEHANDLE "- ";  #InStream
	}
	
	## Writes sbatch code to supplied filehandle to concatenate variants in vcf format. Each array element is combined with the infilePre and Postfix.
	&ConcatenateVariants({scriptParameterHashRef => $scriptParameterHashRef,
			      FILEHANDLE => $FILEHANDLE,
			      arrayRef => $vcfParserContigsArrayRef,
			      infilePrefix => catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_"), 
			      infilePostfix => $vcfParserAnalysisType."_models_annotate_score_compound.vcf",
			      outfile => catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_combined".$vcfParserAnalysisType.".vcf"),
			     });

	## Genmod sort
	print $FILEHANDLE "genmod ";
	print $FILEHANDLE "-v ";  #Increase output verbosity
	print $FILEHANDLE "sort ";  #Sort a VCF file based on rank score
	print $FILEHANDLE "-o ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf ");  #Outfile
	print $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_combined".$vcfParserAnalysisType.".vcf")." ";  #infile
	say $FILEHANDLE "\n";

	if (${$scriptParameterHashRef}{analysisType} eq "exomes") {

	    ## Enable trap for signal(s) and function
	    &EnableTrap({FILEHANDLE => $FILEHANDLE,
			});
	}

	## Copies file from temporary directory.
	say $FILEHANDLE "## Copy file from temporary directory";
	&MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf"),
			      filePath => $outFamilyDirectory,
			      FILEHANDLE => $FILEHANDLE,
			     });
	say $FILEHANDLE "wait", "\n";

	if (${$scriptParameterHashRef}{rankVariantBCFFile} == 1) {
	
	    ## Using GATK combined file directly yields error in bcftools - unclear why 
	    say $FILEHANDLE "\n## Preprocessing for compatibility with bcfTools v1.3\n";
	    print $FILEHANDLE "bcftools view ";
	    print $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf")." ";
	    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType."_tmp.vcf"), "\n";  #Outfile

	    &JavaCore({FILEHANDLE => $FILEHANDLE,
		       memoryAllocation => "Xmx24g -XX:-UseConcMarkSweepGC",
		       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		       javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
		       javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
		      });
	    print $FILEHANDLE "SortVcf ";
	    print $FILEHANDLE "I=".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType."_tmp.vcf")." ";
	    say $FILEHANDLE "O=".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType."_sorted.vcf"), "\n";

	    &VcfToBcf({infile => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType."_sorted"),
		       FILEHANDLE => $FILEHANDLE,
		       outfile => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType),

		      });
	
	    ## Copies file from temporary directory.
	    say $FILEHANDLE "## Copy file from temporary directory";
	    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".bcf*"),
				  filePath => $outFamilyDirectory,
				  FILEHANDLE => $FILEHANDLE,
				 });
	    say $FILEHANDLE "wait", "\n";
	}

	if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	    if ($vcfParserOutputFileCounter == 1) {

		${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{VCFFile}{Clinical}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf");
		${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{RankVariants}{Clinical}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf");   #Save clinical candidate list path

		if (${$scriptParameterHashRef}{rankVariantBCFFile} == 1) {

		    ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{BCFFile}{Clinical}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".bcf");
		}
	    }
	    else {

		${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{VCFFile}{Research}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf");
		${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{RankVariants}{Research}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf");   #Save research candidate list path

		if (${$scriptParameterHashRef}{rankVariantBCFFile} == 1) {

		    ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{BCFFile}{Research}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".bcf");
		}
	    }
	}
    }
    
    close($FILEHANDLE);   

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	if (defined(${$scriptParameterHashRef}{rankModelFile})) {  #Add to SampleInfo
			    
	    if (${$scriptParameterHashRef}{rankModelFile}=~/v(\d+\.\d+.\d+|\d+\.\d+)/) {
				
		${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{RankVariants}{RankModel}{Version} = $1;
	    }
	    ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{RankVariants}{RankModel}{File} = ${$scriptParameterHashRef}{rankModelFile};
	    ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{RankVariants}{RankModel}{Path} = catfile($$referencesDirRef, ${$scriptParameterHashRef}{rankModelFile});

	}
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => ${$scriptParameterHashRef}{familyID},
		       programName => "Genmod",
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf",
		       outDataType => "static"
		      });
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
    if ($$reduceIORef) {
	
	return $xargsFileCounter;  #Track the number of created xargs scripts per module for Block algorithm
    }
}


sub GATKVariantEvalExome { 

##GATKVariantEvalExome
    
##Function : GATK VariantEval for exome variants.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $laneHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $sampleIDRef, $alignerOutDirRef, $callType, $familyIDRef, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleIDRef                => The sampleID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $callType                   => The variant call type
##         : $familyIDRef                => The familyID {REF}
##         : $programName                => The program name {REF}

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     sampleIDRef => $$sampleIDRef,
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$sampleIDRef,
					    programName => $programName,
					    programDirectory => catfile(lc($$alignerOutDirRef), "gatk", "varianteval"),
					    callType => $callType,
					    processTime => 2,
					    tempDirectory => $$tempDirectoryRef
					   });

    ## Assign directories
    my $outSampleDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk", "varianteval");
    my $inFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pGATKCombineVariantCallSets}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pGATKCombineVariantCallSets}{fileTag};

    my $exractExonicRegExp = q?perl -ne ' if ( ($_=~/exonic/) || ($_=~/splicing/) ) {print $_;}' ?;

    ## Add merged infile name after merging all BAM files per sampleID
    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias
    
    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory";
    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE,
			path => catfile($inFamilyDirectory, $$familyIDRef.$infileTag.$callType.".vcf*"),
			tempDirectory => $$tempDirectoryRef
		       });
    
    say $FILEHANDLE "wait", "\n";
    
    ## Select SampleID from familyID vcf file
    
    ## GATK SelectVariants
    say $FILEHANDLE "## GATK SelectVariants";
    
    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx2g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => $$tempDirectoryRef,
	       javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
	      });
    
    print $FILEHANDLE "-T SelectVariants ";  #Type of analysis to run
    print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
    print $FILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
    print $FILEHANDLE "-V: ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf")." ";  #FamilyID infile
    print $FILEHANDLE "-o ".catfile($$tempDirectoryRef, $infile.$outfileTag.$callType."_temp.vcf")." ";  #SampleID exome outfile
    say $FILEHANDLE "-sn ".$$sampleIDRef, "\n";  #Include genotypes from this sample
    
    $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pRankVariants}{fileTag};
    
    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory";
    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE,
			path => catfile($inFamilyDirectory, $$familyIDRef.$infileTag.$callType.".vcf*"),
			tempDirectory => $$tempDirectoryRef
		       });
    say $FILEHANDLE "wait", "\n";
    
    ## Extract exonic variants
    say $FILEHANDLE "## Extract exonic variants";
    print $FILEHANDLE $exractExonicRegExp;
    print $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf")." ";  #InFile
    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$sampleIDRef.$infileTag.$callType."_exonic_variants.vcf"), "\n";  #OutFile
    
    ## Include potential SelectFile variants
    if (${$scriptParameterHashRef}{VcfParserOutputFileCount} == 2) {
	
	my $vcfParserAnalysisType = ".selected";  #SelectFile variants
	
	## Copy file(s) to temporary directory
	say $FILEHANDLE "## Copy file(s) to temporary directory";
	&MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
			    path => catfile($inFamilyDirectory, $$familyIDRef.$infileTag.$callType.$vcfParserAnalysisType.".vcf*"),
			    tempDirectory => $$tempDirectoryRef
			   });
	say $FILEHANDLE "wait", "\n";
	
	## Extract exonic variants
	say $FILEHANDLE "## Extract exonic variants";
	print $FILEHANDLE $exractExonicRegExp;
	print $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.$vcfParserAnalysisType.".vcf")." ";  #InFile
	say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$sampleIDRef.$infileTag.$callType."_exonic_variants".$vcfParserAnalysisType.".vcf"), "\n";  #OutFile
	
	## Merge orphans and selectfiles
	say $FILEHANDLE "## Merge orphans and selectfile(s)";
	print $FILEHANDLE "cat ";
	print $FILEHANDLE catfile($$tempDirectoryRef, $$sampleIDRef.$infileTag.$callType."_exonic_variants.vcf")." ";  #Orphan file
	print $FILEHANDLE catfile($$tempDirectoryRef, $$sampleIDRef.$infileTag.$callType."_exonic_variants".$vcfParserAnalysisType.".vcf")." ";  #SelectFile variants
	say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$sampleIDRef.$infileTag.$callType."_exonic_variants_combined.vcf"), "\n";  #OutFile
	
	## Sort combined file
	say $FILEHANDLE "## Sort combined file";
	print $FILEHANDLE "sort ";
	print $FILEHANDLE "-k1,1 -k2,2n ";  #Numerically by chromosome and start position
	print $FILEHANDLE catfile($$tempDirectoryRef, $$sampleIDRef.$infileTag.$callType."_exonic_variants_combined.vcf")." ";
	say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$sampleIDRef.$infileTag.$callType."_exonic_variants.vcf"), "\n";  #OutFile
    }
    
    print $FILEHANDLE q?perl -ne ' if ($_=~/^#/) {print $_;}' ?;
    print $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf")." ";  #InFile
    print $FILEHANDLE "| ";  #Pipe
    print $FILEHANDLE "cat ";
    print $FILEHANDLE "- ";
    print $FILEHANDLE catfile($$tempDirectoryRef, $$sampleIDRef.$infileTag.$callType."_exonic_variants.vcf")." ";  #infile
    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$sampleIDRef.$infileTag.$callType."_exonic_variants_head.vcf"), "\n";  #OutFile
    
    ## Intersect exonic variants from created sampleID vcf file (required for GATKVariantEval for exonic variants)
    say $FILEHANDLE "## Intersect exonic variants from created sampleID vcf file";
    print $FILEHANDLE "intersectBed ";
    print $FILEHANDLE "-header ";  #Print the header from the A file prior to results.
    print $FILEHANDLE "-a ".catfile($$tempDirectoryRef, $infile.$outfileTag.$callType."_temp.vcf")." ";  #SampleID temp exome vcf infile
    print $FILEHANDLE "-b ".catfile($$tempDirectoryRef, $$sampleIDRef.$infileTag.$callType."_exonic_variants_head.vcf")." ";  #SampleID exonic variants
    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $infile.$outfileTag.$callType."_exome.vcf"), "\n";  #OutFile (VCF-format)
    
    ## VariantEval
    say $FILEHANDLE "## GATK VariantEval";
    
    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx2g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => $$tempDirectoryRef,
	       javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
	      });
    
    print $FILEHANDLE "-T VariantEval ";  #Type of analysis to run
    print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
    print $FILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
    print $FILEHANDLE "-D ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{GATKVariantEvalDbSNP})." ";  #dbSNP file
    print $FILEHANDLE "-gold ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{GATKVariantEvalGold})." ";  #Evaluations that count calls at sites of true variation (e.g., indel calls) will use this argument as their gold standard for comparison
    print $FILEHANDLE "--eval ".catfile($$tempDirectoryRef, $infile.$outfileTag.$callType."_exome.vcf")." ";  #InFile
    say $FILEHANDLE "-o ".catfile($$tempDirectoryRef, $infile.$outfileTag.$callType."_exome.vcf.varianteval"), "\n";  #OutFile
    
    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $infile.$outfileTag.$callType."_exome.vcf.varianteval"),
			  filePath => $outSampleDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	## Collect QC metadata info for later use                                                                                 
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => ${$scriptParameterHashRef}{familyID},
		       sampleID => $$sampleIDRef,
		       programName => "VariantEval_Exome",
		       infile => $infile,
		       outDirectory => $outSampleDirectory,
		       outfileEnding => $outfileTag.$callType."_exome.vcf.varianteval",
		       outDataType => "infileDependent"
		      });
    }
    close($FILEHANDLE);   
 
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 2, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub GATKVariantEvalAll { 

##GATKVariantEvalAll
    
##Function : GATK VariantEval for all variants.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $laneHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyIDRef, $sampleIDRef, $alignerOutDirRef, $callType, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $sampleIDRef                => The sampleID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $callType                   => The variant call type
##         : $programName                => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     sampleIDRef => $$sampleIDRef,
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header    
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$sampleIDRef,
					    programName => $programName,
					    programDirectory => catfile(lc($$alignerOutDirRef), "gatk", "varianteval"),
					    callType => $callType,
					    processTime => 2,
					    tempDirectory => $$tempDirectoryRef,
					   });

    ## Assign directories
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk");
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk", "varianteval");
    my $inFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pGATKCombineVariantCallSets}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pGATKCombineVariantCallSets}{fileTag};

    ## Add merged infile name after merging all BAM files per sampleID
    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias

    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE,
			path => catfile($inFamilyDirectory, $$familyIDRef.$infileTag.$callType.".vcf*"),
			tempDirectory => $$tempDirectoryRef
		       });
    say $FILEHANDLE "wait", "\n";
    
    ## Select SampleID from familyID vcf file
    
    ## GATK SelectVariants
    say $FILEHANDLE "## GATK SelectVariants";
    
    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx2g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => $$tempDirectoryRef,
	       javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
	      });
    
    print $FILEHANDLE "-T SelectVariants ";  #Type of analysis to run	
    print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
    print $FILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
    print $FILEHANDLE "-V: ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf")." ";  #FamilyID infile
    print $FILEHANDLE "-o ".catfile($$tempDirectoryRef, $infile.$outfileTag.$callType.".vcf")." ";  #SampleID outfile
    say $FILEHANDLE "-sn ".$$sampleIDRef, "\n";  #Include genotypes from this sample
    
    ## GATK VariantEval
    say $FILEHANDLE "## GATK VariantEval";
    
    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx2g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => $$tempDirectoryRef,
	       javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
	      });
    
    print $FILEHANDLE "-T VariantEval ";  #Type of analysis to run	
    print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
    print $FILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
    print $FILEHANDLE "-D ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{GATKVariantEvalDbSNP})." ";  #dbSNP file
    print $FILEHANDLE "-gold ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{GATKVariantEvalGold})." ";  #Evaluations that count calls at sites of true variation (e.g., indel calls) will use this argument as their gold standard for comparison
    print $FILEHANDLE "--eval ".catfile($$tempDirectoryRef, $infile.$infileTag.$callType.".vcf")." ";  #InFile
    say $FILEHANDLE "-o ".catfile($$tempDirectoryRef, $infile.$outfileTag.$callType.".vcf.varianteval"), "\n";  #OutFile
    
    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $infile.$outfileTag.$callType.".vcf.varianteval"),
			  filePath => $outSampleDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	## Collect QC metadata info for later use                                                                                                
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => ${$scriptParameterHashRef}{familyID},
		       sampleID => $$sampleIDRef,
		       programName => "VariantEval_All",
		       infile => $infile,
		       outDirectory => $outSampleDirectory,
		       outfileEnding => $outfileTag.$callType.".vcf.varianteval",
		       outDataType => "infileDependent"
		      });
    }
    close($FILEHANDLE);   

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 2, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub SnpEff {
 
##SnpEff
    
##Function : SnpEff annotates variants from different sources.
##Returns  : "|$xargsFileCounter"
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $callType, $programName, $programInfoPath, $fileName, $FILEHANDLE, $xargsFileCounter
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $callType                   => The variant call type
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
##         : $fileName                   => File name
##         : $FILEHANDLE                 => Sbatch filehandle to write to
##         : $xargsFileCounter           => The xargs file counter

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $reduceIORef = \${$scriptParameterHashRef}{reduceIO};
    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 20;
    my $xargsFileName;

    ## Set the number of cores to allocate per sbatch job.
    my $nrCores = ${$scriptParameterHashRef}{maximumCores};

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script
	
	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
	
	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header    
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$familyIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
							       callType => $callType,
							       nrofCores => $nrCores,
							       processTime => 10,
							       tempDirectory => $$tempDirectoryRef
							      });
    }

    ## Assign directories
    my $inFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    ${$parameterHashRef}{"p".$programName}{inDirectory} = $outFamilyDirectory;  #Used downstream
    
    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pAnnovar}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{"p".$programName}{fileTag};

    my $vcfParserAnalysisType = "";
    my $vcfParserContigsArrayRef = \@{ ${$fileInfoHashRef}{contigsSizeOrdered} };  #Set default
    
    for (my $vcfParserOutputFileCounter=0;$vcfParserOutputFileCounter<${$scriptParameterHashRef}{VcfParserOutputFileCount};$vcfParserOutputFileCounter++) {

	my $coreCounter = 1;

	if ($vcfParserOutputFileCounter == 1) {
    
	    $vcfParserAnalysisType = ".selected";  #SelectFile variants
	    $vcfParserContigsArrayRef = \@{${$fileInfoHashRef}{SelectFileContigs}};  #Selectfile contigs
	}

	if ( ! $$reduceIORef) {  #Run as individual sbatch script
	    
	    ## Copy file(s) to temporary directory
	    say $FILEHANDLE "## Copy file(s) to temporary directory";
	    ($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									    XARGSFILEHANDLE => $XARGSFILEHANDLE,
									    arrayRef => $vcfParserContigsArrayRef,
									    fileName =>$fileName,
									    programInfoPath => $programInfoPath,
									    nrCores => $nrCores,
									    xargsFileCounter => $xargsFileCounter,
									    infile => $$familyIDRef.$infileTag.$callType,
									    fileEnding => $vcfParserAnalysisType.".vcf*",
									    inDirectory => $inFamilyDirectory,
									    tempDirectory => $$tempDirectoryRef,
									   });
	}

	## SnpSift Annotation
	say $FILEHANDLE "## SnpSift Annotation";

	my $annotationFileCounter = 0;

	if (${$scriptParameterHashRef}{snpEffAnn} eq 1) {  #Annotate using SnpEff

	    ## Create file commands for xargs
	    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
								 XARGSFILEHANDLE => $XARGSFILEHANDLE,
								 fileName => $fileName,
								 programInfoPath => $programInfoPath,
								 nrCores => $nrCores,
								 xargsFileCounter => $xargsFileCounter,
								 firstCommand => "java",
								 memoryAllocation => "Xmx4g -XX:-UseConcMarkSweepGC",
								 javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
								 javaTemporaryDirectory => $$tempDirectoryRef,
								 javaJar => catfile(${$scriptParameterHashRef}{snpEffPath}, "snpEff.jar"),
								});
	    
	    for (my $contigsCounter=0;$contigsCounter<scalar(@{$vcfParserContigsArrayRef});$contigsCounter++) {
		
		my $contigRef = \${$vcfParserContigsArrayRef}[$contigsCounter];
		
		print $XARGSFILEHANDLE "ann ";
		print $XARGSFILEHANDLE "-v ";  #Verbose mode
		print $XARGSFILEHANDLE ${$scriptParameterHashRef}{snpEffGenomeBuildVersion}." ";  #Reference genome
		print $XARGSFILEHANDLE "-c ".catfile(${$scriptParameterHashRef}{snpEffPath}, "snpEff.config")." ";  #Specify config file
		print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.$vcfParserAnalysisType.".vcf")." "; #Infile
		print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
		say $XARGSFILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.$vcfParserAnalysisType.".vcf.".$xargsFileCounter)." "; #Outfile;
	    }
	    $annotationFileCounter = $xargsFileCounter;
	}

	for my $annotationFile (keys %{${$scriptParameterHashRef}{snpSiftAnnotationFiles}}) {
		
	    my $infoKey = ${$scriptParameterHashRef}{snpSiftAnnotationFiles}{$annotationFile};

	    ## Create file commands for xargs
	    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
								 XARGSFILEHANDLE => $XARGSFILEHANDLE,
								 fileName => $fileName,
								 programInfoPath => $programInfoPath,
								 nrCores => $nrCores,
								 xargsFileCounter => $xargsFileCounter,
								 firstCommand => "java",
								 memoryAllocation => "Xmx2g -XX:-UseConcMarkSweepGC",
								 javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
								 javaTemporaryDirectory => $$tempDirectoryRef,
								 javaJar => catfile(${$scriptParameterHashRef}{snpEffPath}, "SnpSift.jar"),
								});
	    
	    for (my $contigsCounter=0;$contigsCounter<scalar(@{$vcfParserContigsArrayRef});$contigsCounter++) {
	    
		my $contigRef = \${$vcfParserContigsArrayRef}[$contigsCounter];
	    
		print $XARGSFILEHANDLE "annotate ";
		
		if (defined(${$scriptParameterHashRef}{snpSiftAnnotationFiles}{$annotationFile})) {
		    
		    ## Apply specific INFO field output key for easier downstream processing
		    if (defined(${$scriptParameterHashRef}{snpSiftAnnotationOutInfoKey}{$annotationFile})) {
			
			print $XARGSFILEHANDLE "-name ".${$scriptParameterHashRef}{snpSiftAnnotationOutInfoKey}{$annotationFile}." ";
		    }
		    print $XARGSFILEHANDLE "-info ".${$scriptParameterHashRef}{snpSiftAnnotationFiles}{$annotationFile}." ";  #Database
		}
		print $XARGSFILEHANDLE catfile($$referencesDirRef, $annotationFile)." ";  #Database
		
		if ($annotationFileCounter == 0) {  #First file per contig
		    
		    print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.$vcfParserAnalysisType.".vcf")." "; #Infile
		}
		else {
		    
		    my $annotationInfileNumber = $xargsFileCounter - 1;
		    print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.$vcfParserAnalysisType.".vcf.".$annotationInfileNumber)." ";  #Infile from previous round
		    
		}
		print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
		say $XARGSFILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.$vcfParserAnalysisType.".vcf.".$xargsFileCounter)." ";  #Outfile
	    }
	    $annotationFileCounter++;  #Increment counter
	    close($XARGSFILEHANDLE);
	}

	if (@{${$scriptParameterHashRef}{snpSiftDbNSFPAnnotations}}) {
	
	    ## SnpSiftDbNSFP Annotation
	    say $FILEHANDLE "## SnpSiftDnNSFP Annotation";

	    ## Create file commands for xargs
	    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
								 XARGSFILEHANDLE => $XARGSFILEHANDLE,
								 fileName => $fileName,
								 programInfoPath => $programInfoPath,
								 nrCores => $nrCores,
								 xargsFileCounter => $xargsFileCounter,
								 firstCommand => "java",
								 memoryAllocation => "Xmx2g -XX:-UseConcMarkSweepGC",
								 javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
								 javaTemporaryDirectory => $$tempDirectoryRef,
								 javaJar => catfile(${$scriptParameterHashRef}{snpEffPath}, "SnpSift.jar"),
								});
	    
	    my $annotationInfileNumber = $xargsFileCounter - 1;

	    for (my $contigsCounter=0;$contigsCounter<scalar(@{$vcfParserContigsArrayRef});$contigsCounter++) {
	    
		my $contigRef = \${$vcfParserContigsArrayRef}[$contigsCounter];
		
		print $XARGSFILEHANDLE "dbnsfp ";
		print $XARGSFILEHANDLE "-db ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{snpSiftDbNSFPFile})." ";  #DbNSFP file
		print $XARGSFILEHANDLE "-f ";  #fields to add
		print $XARGSFILEHANDLE join(',', @{${$scriptParameterHashRef}{snpSiftDbNSFPAnnotations}})." ";  #Databases
		print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.$vcfParserAnalysisType.".vcf.".$annotationInfileNumber)." ";  #Infile
		print $XARGSFILEHANDLE "2>> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
		say $XARGSFILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.$vcfParserAnalysisType.".vcf.".$xargsFileCounter)." ";  #Outfile
	    }
	    close($XARGSFILEHANDLE);
	}
	
	## Add INFO headers and FIX_INFO for annotations using vcfparser
	say $FILEHANDLE "## Add INFO headers and FIX_INFO for annotations using vcfparser";

	## Create file commands for xargs
	($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							     XARGSFILEHANDLE => $XARGSFILEHANDLE,
							     fileName => $fileName,
							     programInfoPath => $programInfoPath,
							     nrCores => $nrCores,
							     xargsFileCounter => $xargsFileCounter,
							     firstCommand => "perl",
							    });
	    
	my $annotationInfileNumber = $xargsFileCounter - 1;

	for (my $contigsCounter=0;$contigsCounter<scalar(@{$vcfParserContigsArrayRef});$contigsCounter++) {
	    
	    my $contigRef = \${$vcfParserContigsArrayRef}[$contigsCounter];

	    print $XARGSFILEHANDLE catfile(${$scriptParameterHashRef}{inScriptDir}, "vcfParser.pl")." ";  #Parses the vcf output
	    print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.$vcfParserAnalysisType.".vcf.".$annotationInfileNumber)." ";  #Infile
	    print $XARGSFILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.$vcfParserAnalysisType.".vcf")." ";  #Outfile
	    say $XARGSFILEHANDLE "2>> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	}

	if ( ! $$reduceIORef) {  #Run as individual sbatch script

	    ## Copies file from temporary directory. Per contig
	    say $FILEHANDLE "## Copy file from temporary directory";
	    ($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									    XARGSFILEHANDLE => $XARGSFILEHANDLE,
									    arrayRef => $vcfParserContigsArrayRef,
									    fileName =>$fileName,
									    programInfoPath => $programInfoPath,
									    nrCores => ${$scriptParameterHashRef}{maximumCores},
									    xargsFileCounter => $xargsFileCounter,
									    outfile => $$familyIDRef.$outfileTag.$callType,
									    fileEnding => $vcfParserAnalysisType.".vcf*",
									    outDirectory => $outFamilyDirectory,
									    tempDirectory => $$tempDirectoryRef,
									   });
	}
	else {

	    ## QC Data File(s)
	    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".${$fileInfoHashRef}{contigsSizeOrdered}[0].$vcfParserAnalysisType.".vcf"),
				  filePath => $outFamilyDirectory,
				  FILEHANDLE => $FILEHANDLE,
				 });
	    say $FILEHANDLE "wait", "\n";   
	}

	## Adds the most complete vcf file to sampleInfo
	&AddMostCompleteVCF({scriptParameterHashRef => $scriptParameterHashRef,
			     sampleInfoHashRef => $sampleInfoHashRef,
			     programName => $programName,
			     path => catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf"),
			     vcfParserOutputFileCounter => $vcfParserOutputFileCounter,
			    });
    }

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	## Collect QC metadata info for later use
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       programName => $programName,
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.$outfileTag.$callType."_".${$fileInfoHashRef}{contigsSizeOrdered}[0].$vcfParserAnalysisType.".vcf",
		       outDataType => "static"
		      });
    }

    if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	close($FILEHANDLE);
	
	if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			   sampleInfoHashRef => $sampleInfoHashRef,
			   jobIDHashRef => $jobIDHashRef,
			   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			   dependencies => 1, 
			   path => ${$parameterHashRef}{"p".$programName}{chain},
			   sbatchFileName => $fileName
			  });
	}
    }
    if ($$reduceIORef) {
	
	return $xargsFileCounter;  #Track the number of created xargs scripts per module for Block algorithm
    }
}


sub Annovar { 

##Annovar
    
##Function : Annotate and filter SNVs by gene, region and databases.
##Returns  : "|$xargsFileCounter"
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $annovarTableHashRef, $familyID, $alignerOutDir, $callType, $programName, $fileName, $programInfoPath, $FILEHANDLE, $xargsFileCounter
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $annovarTableHashRef        => annovarTableHashRef {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $callType                   => The variant call type
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
##         : $fileName                   => File name
##         : $FILEHANDLE                 => Sbatch filehandle to write to
##         : $xargsFileCounter           => The xargs file counter

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $annovarTableHashRef = ${$argHashRef}{annovarTableHashRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $reduceIORef = \${$scriptParameterHashRef}{reduceIO};
    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 20;
    my $xargsFileName;

    ## Set the number of cores to allocate per sbatch job.
    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    
    unless (defined($FILEHANDLE)){ #Run as individual sbatch script

	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
	
	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header    
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$familyIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
							       callType => $callType,
							       nrofCores => $nrCores,
							       processTime => 7,
							       tempDirectory => $$tempDirectoryRef
							      });
    } 
    
    ## Assign directories
    my $inFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    ${$parameterHashRef}{"p".$programName}{inDirectory} = $outFamilyDirectory;  #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pVCFParser}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{"p".$programName}{fileTag};

    my $vcfParserAnalysisType = "";
    my $vcfParserContigsArrayRef = \@{ ${$fileInfoHashRef}{contigsSizeOrdered} };  #Set default

    for (my $vcfParserOutputFileCounter=0;$vcfParserOutputFileCounter<${$scriptParameterHashRef}{VcfParserOutputFileCount};$vcfParserOutputFileCounter++) {

	if ($vcfParserOutputFileCounter == 1) {

	    $vcfParserAnalysisType = ".selected";  #SelectFile variants
	    $vcfParserContigsArrayRef = \@{${$fileInfoHashRef}{SelectFileContigs}};  #Selectfile contigs
	}
	my $coreCounter=1;   	    	

	if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	    ## Copy file(s) to temporary directory
	    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
	    ($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									    XARGSFILEHANDLE => $XARGSFILEHANDLE,
									    arrayRef => $vcfParserContigsArrayRef,
									    fileName =>$fileName,
									    programInfoPath => $programInfoPath,
									    nrCores => $nrCores,
									    xargsFileCounter => $xargsFileCounter,
									    infile => $$familyIDRef.$infileTag.$callType,
									    fileEnding => $vcfParserAnalysisType.".vcf*",
									    inDirectory => $inFamilyDirectory,
									    tempDirectory => $$tempDirectoryRef,
									   });
	}

	## Annovar
	say $FILEHANDLE "## Annovar";
	
	## Create file commands for xargs
	($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE, 
							     XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							     fileName => $fileName,
							     programInfoPath => $programInfoPath,
							     nrCores => $nrCores,
							     xargsFileCounter => $xargsFileCounter,
							     firstCommand => "perl",
							    });
	
	for (my $contigsCounter=0;$contigsCounter<scalar(@{$vcfParserContigsArrayRef});$contigsCounter++) {
	    
	    my $contigRef = \${$vcfParserContigsArrayRef}[$contigsCounter];
	    
	    print $XARGSFILEHANDLE catfile(${$scriptParameterHashRef}{annovarPath}, "table_annovar.pl")." ";  #Annovar script 
	    print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.$vcfParserAnalysisType.".vcf")." ";  #Infile
	    print $XARGSFILEHANDLE catfile(${$scriptParameterHashRef}{annovarPath}, "humandb")." ";  #annovar/humandb directory is assumed
	    print $XARGSFILEHANDLE "-buildver ".${$scriptParameterHashRef}{annovarGenomeBuildVersion}." ";  #Genome build version
	    print $XARGSFILEHANDLE "-vcfinput ";  #Input format
	    print $XARGSFILEHANDLE "--remove ";  #Remove all temporary files
	    print $XARGSFILEHANDLE "-out ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.$vcfParserAnalysisType.".vcf")." ";  #Outfile prefix
	    print $XARGSFILEHANDLE "-protocol ";  #Comma-delimited string specifying database protocol
	    
	    print $XARGSFILEHANDLE join(',', @{${$scriptParameterHashRef}{annovarTableNames}})." ";  #Databases to use
	    
	    print $XARGSFILEHANDLE "-operation ";  #Comma-delimited string specifying type of operation	

	    for (my $tableNamesCounter=0;$tableNamesCounter<scalar(@{${$scriptParameterHashRef}{annovarTableNames}});$tableNamesCounter++) {  #For all specified table names
		
		if (${$annovarTableHashRef}{${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter]}{annotation} eq "geneanno") {
		    
		    print $XARGSFILEHANDLE "g";
		}
		elsif (${$annovarTableHashRef}{${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter]}{annotation} eq "regionanno") {
		    
		    print $XARGSFILEHANDLE "r";
		}
		elsif (${$annovarTableHashRef}{${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter]}{annotation} eq "filter") {
		    
		    print $XARGSFILEHANDLE "f";
		}
		unless ($tableNamesCounter == scalar(@{${$scriptParameterHashRef}{annovarTableNames}}) - 1) {
		    
		    print $XARGSFILEHANDLE ",";
		}
	    }
	    print $XARGSFILEHANDLE " ";
	    
	    print $XARGSFILEHANDLE "-argument ";
	    for (my $tableNamesCounter=0;$tableNamesCounter<scalar(@{${$scriptParameterHashRef}{annovarTableNames}});$tableNamesCounter++) {  #For all specified table names
		
		if (${$annovarTableHashRef}{${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter]}{annotation} eq "geneanno" ) {  #Use hgvs output style
		    
		    print $XARGSFILEHANDLE q?\'--hgvs ?;  #Use hgvs annotation
		    print $XARGSFILEHANDLE q?--exonicsplicing\' ?;  #Annotate variants near intron/exonic borders
		}
		if (${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] =~/^1000g/) {#Set MAF TH
		    
		    print $XARGSFILEHANDLE "'--maf_threshold ".${$scriptParameterHashRef}{annovarMAFThreshold}."'";
		}
		if ( (${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] =~/^snp/) || (${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] =~/_esp/) ) {#Set MAF TH
		    
		    print $XARGSFILEHANDLE "'--score_threshold ".${$scriptParameterHashRef}{annovarMAFThreshold}."'"; #score_threshold since Annovar reserved the maf_threshold for 1000G
		}
		unless ($tableNamesCounter == scalar(@{${$scriptParameterHashRef}{annovarTableNames}}) - 1) {
		    
		    print $XARGSFILEHANDLE ",";
		}
	    }
	    print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	    print $XARGSFILEHANDLE "; ";
	    print $XARGSFILEHANDLE "mv ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.$vcfParserAnalysisType.".vcf.".${$scriptParameterHashRef}{annovarGenomeBuildVersion}."_multianno.vcf")." ";
	    say $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.$vcfParserAnalysisType.".vcf");
	}	
	if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	    ## Copies file from temporary directory.
	    say $FILEHANDLE "## Copy file from temporary directory";
	    ($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									    XARGSFILEHANDLE => $XARGSFILEHANDLE,
									    arrayRef => $vcfParserContigsArrayRef,
									    fileName =>$fileName,
									    programInfoPath => $programInfoPath,
									    nrCores => $nrCores,
									    xargsFileCounter => $xargsFileCounter,
									    outfile => $$familyIDRef.$outfileTag.$callType,
									    fileEnding => $vcfParserAnalysisType.".vcf*",
									    outDirectory => $outFamilyDirectory,
									    tempDirectory => $$tempDirectoryRef,
									   });
	}

	## Adds the most complete vcf file to sampleInfo
	&AddMostCompleteVCF({scriptParameterHashRef => $scriptParameterHashRef,
			     sampleInfoHashRef => $sampleInfoHashRef,
			     programName => $programName,
			     path => catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf"),
			     vcfParserOutputFileCounter => $vcfParserOutputFileCounter,
			    });
    }

    if ( ! $$reduceIORef) {  #Run as individual sbatch script

	close($FILEHANDLE);

	if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			   sampleInfoHashRef => $sampleInfoHashRef,
			   jobIDHashRef => $jobIDHashRef,
			   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			   dependencies => 1, 
			   path => ${$parameterHashRef}{"p".$programName}{chain},
			   sbatchFileName => $fileName
			  });
	}
    }
    if ($$reduceIORef) {
	
	return $xargsFileCounter;  #Track the number of created xargs scripts per module for Block algorithm
    }
}


sub VCFParser {
 
##VCFParser
    
##Function : VCFParser performs parsing of VariantEffectPredictor annotated variants
##Returns  : "|$xargsFileCounter"
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $callType, $programName, $fileName, $programInfoPath, $FILEHANDLE, $xargsFileCounter
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $callType                   => The variant call type
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
##         : $fileName                   => File name
##         : $FILEHANDLE                 => Sbatch filehandle to write to
##         : $xargsFileCounter           => The xargs file counter

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $programName = ${$argHashRef}{programName};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $reduceIORef = \${$scriptParameterHashRef}{reduceIO};
    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 20;
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script
 
	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle

	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header    
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$familyIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
							       callType => $callType,
							       tempDirectory => $$tempDirectoryRef,
							      });
    }

    ## Assign directories
    my $inFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    ${$parameterHashRef}{"p".$programName}{inDirectory} = $outFamilyDirectory;  #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{pVariantEffectPredictor}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{"p".$programName}{fileTag};

    if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	## Copy file(s) to temporary directory
	say $FILEHANDLE "## Copy file(s) to temporary directory"; 
	($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									XARGSFILEHANDLE => $XARGSFILEHANDLE,
									arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
									fileName =>$fileName,
									programInfoPath => $programInfoPath,
									nrCores => $nrCores,
									xargsFileCounter => $xargsFileCounter,
									infile => $$familyIDRef.$infileTag.$callType,
									inDirectory => $inFamilyDirectory,
									tempDirectory => $$tempDirectoryRef,
								       });
    }

    ## VCFParser
    say $FILEHANDLE "## VCFParser";

    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "perl",
							});

    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {

	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];

	print $XARGSFILEHANDLE catfile(${$scriptParameterHashRef}{inScriptDir}, "vcfParser.pl")." ";  #Parses the VEP output to tab-sep format
	print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.".vcf")." ";  #Infile
	
	if (${$scriptParameterHashRef}{pVariantEffectPredictor} > 0) {
	    
	    print $XARGSFILEHANDLE "--parseVEP ".${$scriptParameterHashRef}{vcfParserVepTranscripts}." ";  #Parse VEP transcript specific entries
	}
	if ($$contigRef =~ /MT|M/) {
	    
	    print $XARGSFILEHANDLE "--padding 10 ";  #Special case for mitochondrial contig annotation
	}
	if (${$scriptParameterHashRef}{vcfParserRangeFeatureFile} ne "noUserInfo") {
	    
	    print $XARGSFILEHANDLE "-rf ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{vcfParserRangeFeatureFile})." ";  #List of genes to analyse separately	
	    
	    if (@{${$scriptParameterHashRef}{vcfParserRangeFeatureAnnotationColumns}}) {
		
		print $XARGSFILEHANDLE "-rf_ac ";  #Range annotation columns
		print $XARGSFILEHANDLE join(',', @{${$scriptParameterHashRef}{vcfParserRangeFeatureAnnotationColumns}})." ";	    
	    }
	}
	if (${$scriptParameterHashRef}{vcfParserSelectFile} ne "noUserInfo") {
	 
	    if (! &CheckEntryHashofArray({hashRef => $fileInfoHashRef,
					  key => "SelectFileContigs",
					  element => $$contigRef,
					 })
		) {

		print $XARGSFILEHANDLE "-sf ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{vcfParserSelectFile})." ";  #List of genes to analyse separately
		print $XARGSFILEHANDLE "-sf_mc ".${$scriptParameterHashRef}{vcfParserSelectFileMatchingColumn}." ";  #Column of HGNC Symbol in SelectFile (-sf)
		
		if (@{${$scriptParameterHashRef}{vcfParserSelectFeatureAnnotationColumns}}) {
		    
		    print $XARGSFILEHANDLE "-sf_ac ";  #Select annotation columns
		    print $XARGSFILEHANDLE join(',', @{${$scriptParameterHashRef}{vcfParserSelectFeatureAnnotationColumns}})." ";	    
		}
		print $XARGSFILEHANDLE "-sof ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.".selected.vcf")." ";
	    }
	}
	print $XARGSFILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.".vcf")." ";  #outfile
	say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
    }

    ## QC Data File(s)
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".${$fileInfoHashRef}{contigsSizeOrdered}[0].".vcf"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	## Clear old VCFParser entry if present
	if (defined(${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$programName})) {
	    
	    delete(${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$programName});
	}
	if (${$scriptParameterHashRef}{vcfParserRangeFeatureFile} ne "noUserInfo") {

	    ## Collect databases(s) from a potentially merged selectFile and adds them to sampleInfo
	    &CollectSubDatabases({sampleInfoHashRef => $sampleInfoHashRef,
				  familyIDRef => $familyIDRef,
				  programNameRef => \$programName,
				  databaseFile => catfile($$referencesDirRef, ${$scriptParameterHashRef}{vcfParserRangeFeatureFile}),
				  databaseKey => "RangeFile",
				 });

	    if (${$scriptParameterHashRef}{vcfParserRangeFeatureFile}=~/v(\d+\.\d+.\d+|\d+\.\d+)/) {
		
		${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$programName}{RangeFile}{Version} = $1;
	    }
	    ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$programName}{RangeFile}{Path} = catfile($$referencesDirRef, ${$scriptParameterHashRef}{vcfParserRangeFeatureFile});
	}
	if (${$scriptParameterHashRef}{vcfParserSelectFile} ne "noUserInfo") {

	    ## Collect databases(s) from a potentially merged selectFile and adds them to sampleInfo
	    &CollectSubDatabases({sampleInfoHashRef => $sampleInfoHashRef,
				  familyIDRef => $familyIDRef,
				  programNameRef => \$programName,
				  databaseFile => catfile($$referencesDirRef, ${$scriptParameterHashRef}{vcfParserSelectFile}),
				  databaseKey => "SelectFile",
				 });

	    if (${$scriptParameterHashRef}{vcfParserSelectFile}=~/v(\d+\.\d+.\d+|\d+\.\d+)/) {
		
		${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$programName}{SelectFile}{Version} = $1;
	    }
	    ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$programName}{SelectFile}{Path} = catfile($$referencesDirRef, ${$scriptParameterHashRef}{vcfParserSelectFile});
	}

	## Collect QC metadata info for later use
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       programName => $programName,
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.$outfileTag.$callType."_".${$fileInfoHashRef}{contigsSizeOrdered}[0].".vcf",
		       outDataType => "static"
		      });
    }

    close($XARGSFILEHANDLE);
    
    if ( ! $$reduceIORef) {  #Run as individual sbatch script

	my $vcfParserAnalysisType = "";
	my @vcfParserContigsRef = \@{ ${$fileInfoHashRef}{contigsSizeOrdered} };

	for (my $vcfParserOutputFileCounter=0;$vcfParserOutputFileCounter<${$scriptParameterHashRef}{VcfParserOutputFileCount};$vcfParserOutputFileCounter++) {

	    if ($vcfParserOutputFileCounter == 1) {
		
		$vcfParserAnalysisType = ".selected";  #SelectFile variants
		@vcfParserContigsRef = \@{${$fileInfoHashRef}{SelectFileContigs}};
	    }

	    ## Copies file from temporary directory.
	    say $FILEHANDLE "## Copy file(s) from temporary directory";
	    ($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									    XARGSFILEHANDLE => $XARGSFILEHANDLE,
									    arrayRef => @vcfParserContigsRef,
									    fileName =>$fileName,
									    programInfoPath => $programInfoPath,
									    nrCores => $nrCores,
									    xargsFileCounter => $xargsFileCounter,
									    outfile => $$familyIDRef.$outfileTag.$callType,
									    fileEnding => $vcfParserAnalysisType.".vcf*",
									    outDirectory => $outFamilyDirectory,
									    tempDirectory => $$tempDirectoryRef,
									   });
	    
	    ## Adds the most complete vcf file to sampleInfo
	    &AddMostCompleteVCF({scriptParameterHashRef => $scriptParameterHashRef,
				 sampleInfoHashRef => $sampleInfoHashRef,
				 programName => $programName,
				 path => catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf"),
				 vcfParserOutputFileCounter => $vcfParserOutputFileCounter,
				});
	}
	close($FILEHANDLE);
    }
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	if ( ! $$reduceIORef) {  #Run as individual sbatch script
	    
	    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			   sampleInfoHashRef => $sampleInfoHashRef,
			   jobIDHashRef => $jobIDHashRef,
			   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			   dependencies => 1, 
			   path => ${$parameterHashRef}{"p".$programName}{chain},
			   sbatchFileName => $fileName
			  });
	}
    }
    if ($$reduceIORef) {
	
	return $xargsFileCounter;  #Track the number of created xargs scripts per module for Block algorithm
    }
}

sub VariantEffectPredictor {
    
##VariantEffectPredictor
    
##Function : VariantEffectPredictor performs annotation of variants.
##Returns  : "|$xargsFileCounter"
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $callType, $programName, $programInfoPath, $fileName, $FILEHANDLE, $xargsFileCounter
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $callType                   => The variant call type
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
##         : $fileName                   => File name
##         : $FILEHANDLE                 => Sbatch filehandle to write to
##         : $xargsFileCounter           => The xargs file counter
##         : $stderrPath                 => The stderr path of the block script

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $stderrPath = ${$argHashRef}{stderrPath};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $reduceIORef = \${$scriptParameterHashRef}{reduceIO};
    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 20;
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script

	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    }

    my $nrForkes = 4;  #VariantEffectPredictor forks

    ## Set the number of cores to allocate per sbatch job.
    my $nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
				       nrCores => scalar(@{${$fileInfoHashRef}{contigs}}),
				      });  #Detect the number of cores to use
    $nrCores = floor($nrCores / $nrForkes);  #Adjust for the number of forks 

    if ( ! $$reduceIORef) {  #Run as individual sbatch script

	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$familyIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
							       callType => $callType,
							       nrofCores => ${$scriptParameterHashRef}{maximumCores},
							       processTime => 10,
							       tempDirectory => $$tempDirectoryRef
							      });
	$stderrPath = $programInfoPath.".stderr.txt";
    }
    my ($volume, $directories, $stderrFile) = File::Spec->splitpath($stderrPath);  #Split to enable submission to &SampleInfoQC later

    ## Assign directories
    my $inFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    ${$parameterHashRef}{"p".$programName}{inDirectory} = $outFamilyDirectory;  #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pVT}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{"p".$programName}{fileTag};

    if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	## Copy file(s) to temporary directory
	say $FILEHANDLE "## Copy file(s) to temporary directory"; 
	($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									XARGSFILEHANDLE => $XARGSFILEHANDLE,
									arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
									fileName =>$fileName,
									programInfoPath => $programInfoPath,
									nrCores => $nrCores,
									xargsFileCounter => $xargsFileCounter,
									infile => $$familyIDRef.$infileTag.$callType,
									inDirectory => $inFamilyDirectory,
									tempDirectory => $$tempDirectoryRef,
								       });
    }

    ## VariantEffectPredictor
    say $FILEHANDLE "## VariantEffectPredictor";

    my $assemblyVersion = ${$fileInfoHashRef}{humanGenomeReferenceSource}.${$fileInfoHashRef}{humanGenomeReferenceVersion};
    
    ## Alias genome source and version to be compatible with VEP
    &AliasAssemblyVersion({assemblyVersion => \$assemblyVersion
			  });
    
    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "perl",
							});

    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {

	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];

	print $XARGSFILEHANDLE catfile(${$scriptParameterHashRef}{vepDirectoryPath}, "variant_effect_predictor.pl")." ";  #VEP script 
	print $XARGSFILEHANDLE "--assembly ".$assemblyVersion." "; 
	print $XARGSFILEHANDLE "--dir_cache ".${$scriptParameterHashRef}{vepDirectoryCache}." ";  #Specify the cache directory to use
	print $XARGSFILEHANDLE "--cache ";  #Enables use of the cache.

	if (${$scriptParameterHashRef}{vepReference} == 1 ) {  #Use reference file for analysis with vep

	    print $XARGSFILEHANDLE "--fasta ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
	}

	print $XARGSFILEHANDLE "--force_overwrite ";  #force the overwrite of the existing file
	print $XARGSFILEHANDLE "--format vcf ";  #Input is in the VCF format
	print $XARGSFILEHANDLE "--vcf ";  #Writes output in VCF format.
	print $XARGSFILEHANDLE "--no_progress ";  #Do not show progress in stderr
	print $XARGSFILEHANDLE "--fork ".$nrForkes." ";  #Enable forking, using the specified number of forks.
	print $XARGSFILEHANDLE "--buffer_size 20000 ";  #Sets the internal buffer size, corresponding to the number of variations that are read in to memory simultaneously 
	print $XARGSFILEHANDLE "--offline ";  #Use installed assembly 
	print $XARGSFILEHANDLE "--chr ".$$contigRef." ";

	##VEPPlugins
	foreach my $plugin (@{${$scriptParameterHashRef}{vepPlugins}}) {

	    if ($plugin eq "LoF") {

		print $XARGSFILEHANDLE "--plugin ".$plugin.",human_ancestor_fa:".catfile(${$scriptParameterHashRef}{vepDirectoryCache}, "human_ancestor.fa,filter_position:0.05")." ";
	    }
	    elsif ($plugin eq "UpDownDistance") {  #Special case for mitochondrial contig annotation
		
		if ($$contigRef =~ /MT|M/) {

		    print $XARGSFILEHANDLE "--plugin UpDownDistance,10,10 ";
		}
	    }
	    else {

		print $XARGSFILEHANDLE "--plugin ".$plugin." ";
	    }
	}

	##VEPFeatures
	foreach my $vepFeature (@{${$scriptParameterHashRef}{vepFeatures}}) {

	    print $XARGSFILEHANDLE "--".$vepFeature." ";  #Add VEP features to the output.
	    
	    if ( ($$contigRef =~ /MT|M/) && ($vepFeature eq "refseq") ) {  #Special case for mitochondrial contig annotation
		
		print $XARGSFILEHANDLE "--all_refseq ";
	    }
	    if ( ($vepFeature eq "sift") || ($vepFeature eq "polyphen") )  {  #Protein predictions
		
		print $XARGSFILEHANDLE "p ";  #Add prediction term 
	    }
	}

	print $XARGSFILEHANDLE "-i ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.".vcf")." ";  #InFile (family vcf)
	print $XARGSFILEHANDLE "-o ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.".vcf")." ";  #OutFile
	print $XARGSFILEHANDLE "1> ".$xargsFileName.".".$$contigRef.".stdout.txt ";  #Redirect xargs output to program specific stdout file
	say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file	
    }
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	## Collect QC metadata info for later use                     	
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       programName => $programName."Summary",
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.$outfileTag.$callType."_".${$fileInfoHashRef}{contigsSizeOrdered}[0].".vcf_summary.html",
		       outDataType => "static"
		      });
	## Collect QC metadata info for later use                     	
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       programName => $programName,
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.$outfileTag.$callType."_".${$fileInfoHashRef}{contigsSizeOrdered}[0].".vcf",
		       outDataType => "static"
		      });
    }

    ## QC Data File(s)
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_*.vcf_s*"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    
    close($XARGSFILEHANDLE);

    if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	## Copies file from temporary directory.
	say $FILEHANDLE "## Copy file from temporary directory";
	&MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_*.vcf*"),
			      filePath => $outFamilyDirectory,
			      FILEHANDLE => $FILEHANDLE,
			     });
	say $FILEHANDLE "wait", "\n";

	close($FILEHANDLE);
    }
    else {  #Move file for downstream collection of VEP version
	
	## Copies file from temporary directory.
	say $FILEHANDLE "## Copy file from temporary directory";
	&MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".${$fileInfoHashRef}{contigsSizeOrdered}[0].".vcf"),
			      filePath => $outFamilyDirectory,
			      FILEHANDLE => $FILEHANDLE,
			     });
	say $FILEHANDLE "wait", "\n";	    
    }

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	if ( ! $$reduceIORef) {  #Run as individual sbatch script

	    ## Submitt job
	    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			   sampleInfoHashRef => $sampleInfoHashRef,
			   jobIDHashRef => $jobIDHashRef,
			   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			   dependencies => 1, 
			   path => ${$parameterHashRef}{"p".$programName}{chain},
			   sbatchFileName => $fileName
			  });
	}
	if ($$reduceIORef) {  #Redirect qcCollect search to Block File, since VEP will write stderr there
	    
	    $programName = "VariantAnnotationBlock";
	}

	## Collect QC metadata info for later use
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       programName => $programName,
		       outDirectory => $directories,
		       outfileEnding => $stderrFile,
		       outDataType => "infoDirectory"
		      });
    }
    if ($$reduceIORef) {
	
	return $xargsFileCounter;  #Track the number of created xargs scripts per module for Block algorithm
    }
}


sub GATKReadBackedPhasing {
 
##GATKReadBackedPhasing
    
##Function : GATK ReadBackedPhasing performs physical phasing of SNP calls, based on sequencing reads.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $laneHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyID, $alignerOutDir, $callType, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyID                   => The familyID
##         : $alignerOutDir              => The alignerOutDir used in the analysis
##         : $callType                   => The variant call type
##         : $programName                => The program name

    my $parameterHashRef = $_[0];
    my $scriptParameterHashRef = $_[1];
    my $sampleInfoHashRef = $_[2];
    my $fileInfoHashRef = $_[3];
    my $laneHashRef = $_[4];
    my $infilesLaneNoEndingHashRef = $_[5];
    my $jobIDHashRef = $_[6];
    my $familyID = $_[7];
    my $alignerOutDir = $_[8];
    my $callType = $_[9];
    my $programName = $_[10];
    
    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $nrCores = 1;

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header    
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $familyID,
					    programName => $programName,
					    programDirectory => catfile(lc($alignerOutDir), "gatk"),
					    callType => $callType,
					    nrofCores => $nrCores,
					    processTime => 15,
					    tempDirectory => ${$scriptParameterHashRef}{tempDirectory}
					   });

    ## Assign directories
    my $inFamilyDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $familyID, $alignerOutDir, "gatk");
    my $outFamilyDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $familyID, $alignerOutDir, "gatk");

    ## Assign fileTags
    my $infileTag;

    ## Choose infile ending depending on GATK PhasebyTransmission swith
    if (${$scriptParameterHashRef}{pGATKPhaseByTransmission} > 0) { 

	$infileTag = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{ ${$scriptParameterHashRef}{familyID} }{pGATKPhaseByTransmission}{fileTag};
    }
    else {

	$infileTag = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{ ${$scriptParameterHashRef}{familyID} }{pGATKCombineVariantCallSets}{fileTag};
    }
    my $outfileTag = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{ ${$scriptParameterHashRef}{familyID} }{"p".$programName}{fileTag};

    ## Copy VCF file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE,
			path => catfile($inFamilyDirectory, $familyID.$infileTag.$callType.".vcf*"),
			tempDirectory => ${$scriptParameterHashRef}{tempDirectory}
		       });
    say $FILEHANDLE "wait", "\n";

    ## Copy BAM file(s) to temporary directory
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {  #Collect infiles for all sampleIDs

	my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter], $alignerOutDir, "gatk");
	my $infileTag = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{ ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter] }{pGATKBaseRecalibration}{fileTag};

	## Add merged infile name after merging all BAM files per sampleID
	my $infile = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter]}{MergeInfile};  #Alias

	## Copy file(s) to temporary directory
	say $FILEHANDLE "## Copy file(s) to temporary directory";
	&MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
			    path => catfile($inSampleDirectory, $infile.$infileTag.".b*"),
			    tempDirectory => ${$scriptParameterHashRef}{tempDirectory}
			   });
	say $FILEHANDLE "wait", "\n";
    }

    ## GATK ReadBackedPhasing
    say $FILEHANDLE "## GATK ReadBackedPhasing";

    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx4g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
	       javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
	      });

    print $FILEHANDLE "-T ReadBackedPhasing ";  #Type of analysis to run    
    print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
    print $FILEHANDLE "-R ".catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
    print $FILEHANDLE "--phaseQualityThresh ".${$scriptParameterHashRef}{GATKReadBackedPhasingPhaseQualityThreshold}." ";

    if (${$scriptParameterHashRef}{pGATKPhaseByTransmission} > 0) { 

	print $FILEHANDLE "-respectPhaseInInput ";  #Already phased data - respect calls
    }

    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {  #Collect infiles for all sampleIDs
	
	my $infileTag = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{ ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter] }{pGATKBaseRecalibration}{fileTag};

	## Add merged infile name after merging all BAM files per sampleID
	my $infile = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter]}{MergeInfile};  #Alias
	
	print $FILEHANDLE "-I ".catfile(${$scriptParameterHashRef}{tempDirectory}, $infile.$infileTag.".bam ");  #InFile
    } 
    print $FILEHANDLE "-L: ".catfile(${$scriptParameterHashRef}{tempDirectory}, $familyID.$infileTag.$callType.".vcf")." ";  #Limit to  (family vcf)
    print $FILEHANDLE "-V: ".catfile(${$scriptParameterHashRef}{tempDirectory}, $familyID.$infileTag.$callType.".vcf")." ";  #InFile (family vcf)
    say $FILEHANDLE "-o ".catfile(${$scriptParameterHashRef}{tempDirectory}, $familyID.$outfileTag.$callType.".vcf"), "\n";  #OutFile

    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile(${$scriptParameterHashRef}{tempDirectory}, $familyID.$outfileTag.$callType.".vcf*"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";

    close($FILEHANDLE);

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 2, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub GATKPhaseByTransmission {

##GATKPhaseByTransmission
    
##Function : GATK PhaseByTransmission computes the most likely genotype combination and phases trios and parent/child pairs given their genotype likelihoods and a mutation prior and phases all sites were parent/child transmission can be inferred unambiguously.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyID, $alignerOutDir, $callType, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyID                   => The familyID
##         : $alignerOutDir              => The alignerOutDir used in the analysis
##         : $callType                   => The variant call type
##         : $programName                => The program name

    my $parameterHashRef = $_[0];
    my $scriptParameterHashRef = $_[1];
    my $sampleInfoHashRef = $_[2];
    my $fileInfoHashRef = $_[3];
    my $infilesLaneNoEndingHashRef = $_[4];
    my $jobIDHashRef = $_[5];
    my $familyID = $_[6];
    my $alignerOutDir = $_[7];
    my $callType = $_[8];
    my $programName = $_[9];

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header    
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $familyID,
					    programName => $programName,
					    programDirectory => catfile(lc($alignerOutDir), "gatk"),
					    callType => $callType,
					    processTime => 15,
					    tempDirectory => ${$scriptParameterHashRef}{tempDirectory}
					   });
    
    ## Assign directories
    my $outFamilyFileDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $familyID);
    my $inFamilyDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $familyID, $alignerOutDir, "gatk");
    my $outFamilyDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $familyID, $alignerOutDir, "gatk");

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{ ${$scriptParameterHashRef}{familyID} }{pGATKCombineVariantCallSets}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{ ${$scriptParameterHashRef}{familyID} }{"p".$programName}{fileTag};
    
    ## Create .fam file to be used in variant calling analyses
    &CreateFamFile({scriptParameterHashRef => $scriptParameterHashRef,
		    FILEHANDLE => $FILEHANDLE,
		    famFilePath => catfile($outFamilyFileDirectory, $familyID.".fam"),
		   });
    
    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE,
			path => catfile($inFamilyDirectory, $familyID.$infileTag.$callType.".vcf*"),
			tempDirectory => ${$scriptParameterHashRef}{tempDirectory}
		       });
    say $FILEHANDLE "wait", "\n";

    ## GATK PhaseByTransmission    
    say $FILEHANDLE "## GATK PhaseByTransmission";

    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx4g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
	       javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
	      });

    print $FILEHANDLE "-T PhaseByTransmission ";  #Type of analysis to run    
    print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
    print $FILEHANDLE "-R ".catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
    print $FILEHANDLE "-V: ".catfile(${$scriptParameterHashRef}{tempDirectory}, $familyID.$infileTag.$callType.".vcf")." ";  #InFile (family vcf)

    ## Check if "--pedigree" and "--pedigreeValidationType" should be included in analysis
    &GATKPedigreeFlag({scriptParameterHashRef => $scriptParameterHashRef,
		       FILEHANDLE => $FILEHANDLE,
		       outFamilyFileDirectory => $outFamilyFileDirectory,
		       pedigreeValidationType => "SILENT",
		       programName => $programName,
		      });

    say $FILEHANDLE "-o ".catfile(${$scriptParameterHashRef}{tempDirectory}, $familyID.$outfileTag.$callType.".vcf"), "\n";  #OutFile

    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile(${$scriptParameterHashRef}{tempDirectory}, $familyID.$outfileTag.$callType.".vcf*"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";

    close($FILEHANDLE);

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub SampleCheck { 

##SampleCheck
    
##Function : Tests sample for correct relatives (only performed for samples with relatives defined in pedigree file) performed on sequence data.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $callType, $programName
##         : $parameterHashRef       => The parameter hash {REF}
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef      => Info on samples and family hash {REF}
##         : $fileInfoHashRef        => The fileInfo hash {REF}
##         : $jobIDHashRef           => The jobID hash {REF}
##         : $familyIDRef            => The familyID {REF}
##         : $alignerOutDirRef       => The alignerOutDir used in the analysis {REF}
##         : $callType               => The variant call type
##         : $programName            => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $xargsFileName;
    my $xargsFileCounter = 0;

    ## Set the number of cores to allocate per sbatch job.
    my $nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
				       nrCores => scalar(@{${$scriptParameterHashRef}{sampleIDs}}),
				      });
    
    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							      jobIDHashRef => $jobIDHashRef,
							      FILEHANDLE => $FILEHANDLE,
							      directoryID => $$familyIDRef,
							      programName => $programName,
							      programDirectory => catfile(lc($$alignerOutDirRef), lc($programName)),
							      callType => $callType,
							      nrofCores => $nrCores,
							      processTime => 10,
							     });
    
    ## Assign Directories
    my $inFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    my $outFamilyDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, lc($programName));

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pGATKCombineVariantCallSets}{fileTag};

    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE,
			path => catfile($inFamilyDirectory, $$familyIDRef.$infileTag.$callType.".vcf*"),
			tempDirectory => $$tempDirectoryRef
		       });
    say $FILEHANDLE "wait", "\n";

    my $founderCount = &DetectFounders({scriptParameterHashRef => $scriptParameterHashRef,
					sampleInfoHashRef => $sampleInfoHashRef,
				       });

    ## GATK SelectVariants and Plink2 bed, bim and .fam file 
    say $FILEHANDLE "## GATK SelectVariants and Plink2 bed, bim and .fam file";

    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE,
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "java",
							 memoryAllocation => "Xmx2g",
							 javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
							 javaTemporaryDirectory => $$tempDirectoryRef,
							 javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
							});
    foreach my $sampleID (@{${$scriptParameterHashRef}{sampleIDs}}) {
	
	print $XARGSFILEHANDLE "-T SelectVariants ";  #Type of analysis to run
	print $XARGSFILEHANDLE "-l INFO ";  #Set the minimum level of logging
	print $XARGSFILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
	print $XARGSFILEHANDLE "-V: ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf")." ";  #FamilyID infile
	print $XARGSFILEHANDLE "-o ".catfile($$tempDirectoryRef, $sampleID.".vcf")." ";  #SampleID outfile
	print $XARGSFILEHANDLE "-sn ".$sampleID." ";  #Include genotypes from this sample
	print $XARGSFILEHANDLE "-env ";
	print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$sampleID."_SelectVariants.stderr.txt ";  #Redirect xargs output to program specific stderr file	
	print $XARGSFILEHANDLE "; ";

	## Generate Plink bed and bim (as well as fam) files
	print $XARGSFILEHANDLE "plink2 ";
	print $XARGSFILEHANDLE "--vcf ".catfile($$tempDirectoryRef, $sampleID.".vcf")." ";  #InFile
	print $XARGSFILEHANDLE "--chr 23-24 ";  #Only analyse sex chromosomes
	print $XARGSFILEHANDLE "--out ".catfile($$tempDirectoryRef, $sampleID."_vcf_data_unsplit")." ";  #OutFile (.ped and .map)
	say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$sampleID."_plink2.stderr.txt ";  #Redirect xargs output to program specific stderr file	
    }

    ## Add a subsetet and correct .fam file for analysis
    say $FILEHANDLE "## Add a subsetet and correct .fam file for analysis";
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {  #Collect infiles for all sampleIDs
	
	my $sampleIDRef = \${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter];  #Alias
	my $lineCounter = 2 + $sampleIDCounter;  #Skip header line
	print $FILEHANDLE q?perl -nae 'if($F[1]=~/?.$$sampleIDRef.q?/) {print $F[0]."\t".$F[1]."\t0\t0\t".$F[4]."\t".$F[5]}' ?;  #Include 1 line and remove founders
	print $FILEHANDLE catfile(${$scriptParameterHashRef}{outDataDir}, ${$scriptParameterHashRef}{familyID}, ${$scriptParameterHashRef}{familyID}.".fam")." ";
	print $FILEHANDLE "> "; 
	print $FILEHANDLE catfile($$tempDirectoryRef, $$sampleIDRef."_vcf_data_unsplit.fam")." ";
	say $FILEHANDLE "2> ".$xargsFileName.".".$$sampleIDRef."_sampleFam.stderr.txt ", "\n";  #Redirect xargs output to program specific stderr file	
    }

    ## Perform sex-check on individual samples and sampleID.fam  using Plink2
    say $FILEHANDLE "## Perform sex-check on individual samples and sampleID.fam  using Plink2";

    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE,
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "plink2",
							});

    foreach my $sampleID (@{${$scriptParameterHashRef}{sampleIDs}}) {

	## Split X to remove PAR regions
	print $XARGSFILEHANDLE "--bfile ".catfile($$tempDirectoryRef, $sampleID."_vcf_data_unsplit")." ";
	print $XARGSFILEHANDLE "--split-x b37 no-fail ";  #By default, PLINK errors out when no variants would be affected by --split-x;the 'no-fail' modifier overrides this.
	print $XARGSFILEHANDLE "--make-bed ";
	print $XARGSFILEHANDLE "--out ".catfile($$tempDirectoryRef, $sampleID."_vcf_data")." ";
	print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$sampleID."_plink2_splitX.stderr.txt ";  #Redirect xargs output to program specific stderr file	
	print $XARGSFILEHANDLE "; ";

	print $XARGSFILEHANDLE "plink2 ";
	print $XARGSFILEHANDLE "--bfile ".catfile($$tempDirectoryRef, $sampleID."_vcf_data")." ";
	print $XARGSFILEHANDLE "--check-sex ";
	
	unless (${$sampleInfoHashRef}{${$scriptParameterHashRef}{familyID} }{$sampleID}{Sex} == 2) {
	    
	    print $XARGSFILEHANDLE "y-only ";
	}
	print $XARGSFILEHANDLE "--out ".catfile($outFamilyDirectory, $sampleID."_vcf_data")." ";
	say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$sampleID."_plink2_check-sex.stderr.txt ";  #Redirect xargs output to program specific stderr file
    }
    
    ## Concatenate files for qc downsteam 
    print $FILEHANDLE "cat ";
    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {  #Collect infiles for all sampleIDs

	my $sampleID = ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter];  #Alias

	print $FILEHANDLE catfile($outFamilyDirectory, $sampleID."_vcf_data.sexcheck")." ";
    }
    print $FILEHANDLE "| ";  #Pipe
    print $FILEHANDLE q?perl -nae 'if ($.==1) {chomp($_);  print $_; if ($F[5] eq "F") {print "/YCOUNT\n"} else {print "/F\n"} } elsif ($_!~/FID/) {print $_}' ?;  #Print first header and sampleId lines
    print $FILEHANDLE "> ".catfile($outFamilyDirectory, $$familyIDRef.".sexcheck")." ";
    say $FILEHANDLE "\n";

    if ( (${$scriptParameterHashRef}{pSampleCheck} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	## Collect QC metadata info for later use                                                                                               
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => ${$scriptParameterHashRef}{familyID},
		       programName => "SexCheck",
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.".sexcheck",
		       outDataType => "infileDependent"
		      });
    }


    say $FILEHANDLE "#Create Plink .ped and .map file per family using vcfTools";
    print $FILEHANDLE "vcftools ";
    print $FILEHANDLE "--vcf ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf")." ";  #InFile
    print $FILEHANDLE "--plink ";  #PLINK format
    say $FILEHANDLE "--out ".catfile($outFamilyDirectory, $$familyIDRef), "\n";  #OutFile (.ped and .map)

    say $FILEHANDLE "#Create vcfTools inbreeding coefficient F per family using vcfTools";
    print $FILEHANDLE "vcftools ";
    print $FILEHANDLE "--vcf ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf")." ";  #InFile
    print $FILEHANDLE "--het ";  #Individual inbreeding
    say $FILEHANDLE "--out ".catfile($outFamilyDirectory, $$familyIDRef), "\n";  #Outfile

    if ( (${$scriptParameterHashRef}{pSampleCheck} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	## Collect QC metadata info for later use                                                                                               
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => ${$scriptParameterHashRef}{familyID},
		       programName => "InbreedingFactor",
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.".het",
		       outDataType => "infileDependent"
		      });
    }

    if (scalar(@{${$scriptParameterHashRef}{sampleIDs}}) > 1) {  #Only perform if more than 1 sample
	
	say $FILEHANDLE "#Create Plink .mibs per family"; 
	print $FILEHANDLE "plink2 ";
	print $FILEHANDLE "--noweb ";  #No web check
	print $FILEHANDLE "--ped ".catfile($outFamilyDirectory, $$familyIDRef.".ped")." ";  #InFile
	print $FILEHANDLE "--map ".catfile($outFamilyDirectory, $$familyIDRef.".map")." ";  #InFile
	print $FILEHANDLE "--cluster ";  #Perform IBS clustering
	print $FILEHANDLE "--matrix ";  #Create a N x N matrix of genome-wide average IBS pairwise identities
	say $FILEHANDLE "--out ".catfile($outFamilyDirectory, $$familyIDRef), "\n";  #OutFile
	
	if ( (${$scriptParameterHashRef}{pSampleCheck} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	    ## Collect QC metadata info for later use                                                                                               
	    &SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
			   familyID => ${$scriptParameterHashRef}{familyID},
			   programName => "RelationCheck",
			   outDirectory => $outFamilyDirectory,
			   outfileEnding => $$familyIDRef.".mibs",
			   outDataType => "infileDependent"
			  });
	}
    }
    
    close($FILEHANDLE); 

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 2, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub VT { 

##VT
    
##Function : Split multi allelic records into single records and normalize
##Returns  : "|$xargsFileCounter"
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $callType, $fileName, $programName, $programInfoPath, $FILEHANDLE, $xargsFileCounter, $stderrPath
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $callType                   => The variant call type
##         : $fileName                   => File name
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
##         : $FILEHANDLE                 => Filehandle to write to
##         : $xargsFileCounter           => The xargs file counter
##         : $stderrPath                 => The stderr path of the block script

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $stderrPath = ${$argHashRef}{stderrPath};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $reduceIORef = \${$scriptParameterHashRef}{reduceIO};
    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $xargsFileName;
    my $time = 10;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script
	
	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    }

    ## Set the number of cores to allocate per sbatch job.
    my $nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
				       nrCores => scalar(@{${$fileInfoHashRef}{contigs}})
				      });  #Detect the number of cores to use

    if ( ! $$reduceIORef) { #Run as individual sbatch script

	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$familyIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
							       callType => $callType,
							       nrofCores => $nrCores,
							       processTime => $time,
							       tempDirectory => $$tempDirectoryRef,
							      });
	$stderrPath = $programInfoPath.".stderr.txt";
    }
    my ($volume, $directories, $stderrFile) = File::Spec->splitpath($stderrPath); #Split to enable submission to &SampleInfoQC later

    ## Assign directories
    my $inFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    ${$parameterHashRef}{"p".$programName}{inDirectory} = $outFamilyDirectory;  #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pGATKCombineVariantCallSets}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{"p".$programName}{fileTag};

    if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	## Copy file(s) to temporary directory
	say $FILEHANDLE "## Copy file(s) to temporary directory"; 
	($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									XARGSFILEHANDLE => $XARGSFILEHANDLE,
									arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
									fileName =>$fileName,
									programInfoPath => $programInfoPath,
									nrCores => $nrCores,
									xargsFileCounter => $xargsFileCounter,
									infile => $$familyIDRef.$infileTag.$callType,
									inDirectory => $inFamilyDirectory,
									tempDirectory => $$tempDirectoryRef,
								       });
    }
    
    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "less",
							});

    my $removeStarRegExp = q?perl -nae \'unless\($F\[4\] eq \"\*\") \{print $_\}\' ?;  #VEP does not annotate '*' since the alt allele does not exist, this is captured in the upsream indel and SNV record associated with '*'

    ## Split vcf into contigs
    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {
	
	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];
	
	print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.".vcf")." ";  #Infile 

	## VT - Split multi allelic records into single records and normalize
	&VTCore({scriptParameterHashRef => $scriptParameterHashRef,
		 sampleInfoHashRef => $sampleInfoHashRef,
		 infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		 jobIDHashRef => $jobIDHashRef,
		 FILEHANDLE => $XARGSFILEHANDLE,
		 infilePath => catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf"),
		 outfilePath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.".vcf"),
		 decompose => ${$scriptParameterHashRef}{VTDecompose},
		 normalize => ${$scriptParameterHashRef}{VTNormalize},
		 sed => 1,
		 inStream => 1,
		 cmdbreak => ";",
		 xargsFileName => $xargsFileName,
		 contigRef => $contigRef,
		});

	my $altFileEnding = "";

	## Remove decomposed '*' entries
	if (${$scriptParameterHashRef}{VTmissingAltAllele} == 1) {

	    $altFileEnding = "_noStar";
	    print $XARGSFILEHANDLE catfile($removeStarRegExp.$$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.".vcf")." ";
	    print $XARGSFILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.$altFileEnding.".vcf")." ";
	    print $XARGSFILEHANDLE "2>> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	    print $XARGSFILEHANDLE "; ";
	}

	## Remove common variants
	if (${$scriptParameterHashRef}{VTgenmodFilter} > 0) {

	    print $XARGSFILEHANDLE "genmod ";  #Program
	    print $XARGSFILEHANDLE "-v ";  #Increase output verbosity
	    print $XARGSFILEHANDLE "annotate ";  #Command
	    print $XARGSFILEHANDLE "--thousand_g ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{VTgenmodFilter1000G})." ";  #1000G reference

	    if (${$scriptParameterHashRef}{VTgenmodFilterMaxAf} == 1) {

		print $XARGSFILEHANDLE "--max_af ";  #If the MAX AF should be annotated
	    }
	    print $XARGSFILEHANDLE "-o ".catfile(dirname(devnull()), "stdout")." ";  #OutStream
	    print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.$altFileEnding.".vcf")." ";
	    print $XARGSFILEHANDLE "2>> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	    print $XARGSFILEHANDLE "| ";

	    $altFileEnding .= "_genmodFilter";  #Update ending

	    print $XARGSFILEHANDLE "genmod ";  #Program
	    print $XARGSFILEHANDLE "-v ";  #Increase output verbosity
	    print $XARGSFILEHANDLE "filter ";  #Command
	    print $XARGSFILEHANDLE "-t ".${$scriptParameterHashRef}{VTgenmodFilterThreshold}." ";  #Threshold for filtering variants
	    print $XARGSFILEHANDLE "- ";  #InStream
	    print $XARGSFILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.$altFileEnding.".vcf")." ";  #OutFile
	    print $XARGSFILEHANDLE "2>> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	    print $XARGSFILEHANDLE "; ";
	}

	print $XARGSFILEHANDLE "mv ";
	print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.$altFileEnding.".vcf")." ";
	say $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.".vcf")." ";
    }

    if ( ! $$reduceIORef) { #Run as individual sbatch script

	## Copies file from temporary directory.
	say $FILEHANDLE "## Copy file from temporary directory";
	&MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_*.vcf*"),
			      filePath => $outFamilyDirectory,
			      FILEHANDLE => $FILEHANDLE,
			     });
	say $FILEHANDLE "wait", "\n";

	close($FILEHANDLE);
    }
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	## Collect QC metadata info for later use
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => ${$scriptParameterHashRef}{familyID},
		       programName => "vt",
		       outDirectory => $directories,
		       outfileEnding => $stderrFile,
		       outDataType => "infoDirectory"
		      });

	if ( ! $$reduceIORef) { #Run as individual sbatch script

	    ## Submitt job
	    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			   sampleInfoHashRef => $sampleInfoHashRef,
			   jobIDHashRef => $jobIDHashRef,
			   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			   dependencies => 1, 
			   path => ${$parameterHashRef}{"p".$programName}{chain},
			   sbatchFileName => $fileName
			  });
	}
    }
    if ($$reduceIORef) {
	
	return $xargsFileCounter;  #Track the number of created xargs scripts per module for Block algorithm
    }
}


sub PrepareForVariantAnnotationBlock { 

##PrepareForVariantAnnotationBlock
    
##Function : Copy files for VariantAnnotationBlock to enable restart and skip of modules within block
##Returns  : "|$xargsFileCounter"
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $callType, $fileName, $programName, $programInfoPath, $FILEHANDLE, $xargsFileCounter, $stderrPath
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $callType                   => The variant call type
##         : $fileName                   => File name
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
##         : $FILEHANDLE                 => Filehandle to write to
##         : $xargsFileCounter           => The xargs file counter
##         : $stderrPath                 => The stderr path of the block script

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $stderrPath = ${$argHashRef}{stderrPath};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $reduceIORef = \${$scriptParameterHashRef}{reduceIO};
    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $xargsFileName;
    my $time = 10;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script
	
	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    }

    ## Set the number of cores to allocate per sbatch job.
    my $nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
				       nrCores => scalar(@{${$fileInfoHashRef}{contigs}})
				      });  #Detect the number of cores to use

    if ( ! $$reduceIORef) { #Run as individual sbatch script
	
	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$familyIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
							       callType => $callType,
							       nrofCores => $nrCores,
							       processTime => $time,
							       tempDirectory => $$tempDirectoryRef,
							      });
	$stderrPath = $programInfoPath.".stderr.txt";
    }
    my ($volume, $directories, $stderrFile) = File::Spec->splitpath($stderrPath); #Split to enable submission to &SampleInfoQC later

    ## Assign directories
    my $inFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    ${$parameterHashRef}{"p".$programName}{inDirectory} = $outFamilyDirectory;  #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pGATKCombineVariantCallSets}{fileTag};
    
    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE,
			path => catfile($inFamilyDirectory, $$familyIDRef.$infileTag.$callType.".vcf*"),
			tempDirectory => $$tempDirectoryRef
		       });
    say $FILEHANDLE "wait", "\n";

    ## Compress or decompress original file or stream to outfile (if supplied)
    &Bgzip({FILEHANDLE => $FILEHANDLE,
	    infilePath => catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf"),
	    outfilePath => catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf.gz"),
	   });
    
    ## Index file using tabix 
    &Tabix({FILEHANDLE => $FILEHANDLE,
	    infilePath => catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf.gz"),
	   });

    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "tabix",
							});

    ## Split vcf into contigs
    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {
	
	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];
	
	print $XARGSFILEHANDLE "-h ";  #Include header
	print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf.gz")." ";
	print $XARGSFILEHANDLE $$contigRef." ";
	say $XARGSFILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.".vcf");
    }

    if ( ! $$reduceIORef) { #Run as individual sbatch script

	## Copies file from temporary directory.
	say $FILEHANDLE "## Copy file from temporary directory";
	&MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_*.vcf*"),
			      filePath => $outFamilyDirectory,
			      FILEHANDLE => $FILEHANDLE,
			     });
	say $FILEHANDLE "wait", "\n";

	close($FILEHANDLE);
    }
if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	if ( ! $$reduceIORef) { #Run as individual sbatch script

	    ## Submitt job
	    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			   sampleInfoHashRef => $sampleInfoHashRef,
			   jobIDHashRef => $jobIDHashRef,
			   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			   dependencies => 1, 
			   path => ${$parameterHashRef}{"p".$programName}{chain},
			   sbatchFileName => $fileName
			  });
	}
    }
    if ($$reduceIORef) {
	
	return $xargsFileCounter;  #Track the number of created xargs scripts per module for Block algorithm
    }
}


sub GATKCombineVariantCallSets { 

##GATKCombineVariantCallSets
    
##Function : GATK CombineVariants to combine all variants call from different callers.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $callType, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $callType                   => The variant call type
##         : $programName                => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my @variantCallers;  #Stores callers that have been executed
    my @parallelChains;  #Stores the parallel chains that jobIds should be inherited from

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header    
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$familyIDRef,
					    programName => $programName,
					    programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
					    callType => $callType,
					    processTime => 2,
					    tempDirectory => $$tempDirectoryRef,
					   });

    ## Assign directories
    my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    ${$parameterHashRef}{"p".$programName}{inDirectory} = $outFamilyDirectory;  #Used downstream

    ## Assign fileTags
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pGATKCombineVariantCallSets}{fileTag};

    foreach my $variantCaller (@{${$parameterHashRef}{dynamicParameters}{variantCaller}}) {
	
	if (${$scriptParameterHashRef}{$variantCaller} > 0) {  #Expect vcf
	    
	    my $programOutDirectoryName = ${$parameterHashRef}{$variantCaller}{outDirectoryName};
	    my $inFamilyDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, $programOutDirectoryName);
	    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$variantCaller}{fileTag};
	    
	    unshift(@variantCallers, $programOutDirectoryName);  #To prioritize downstream - 1. gatk 2. samtools determined by orderParameters order

	    unless (${$parameterHashRef}{$variantCaller}{chain} eq "MAIN") {  #Do not add MAIN chains

		push(@parallelChains, ${$parameterHashRef}{$variantCaller}{chain});
	    }

	    ## Copy file(s) to temporary directory
	    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
	    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE,
				path => catfile($inFamilyDirectory, $$familyIDRef.$infileTag.$callType.".vcf*"),
				tempDirectory => $$tempDirectoryRef
			       });
	}
    }
    say $FILEHANDLE "wait", "\n";

    ## GATK CombineVariants
    say $FILEHANDLE "## GATK CombineVariants";

    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx2g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => $$tempDirectoryRef,
	       javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
	      });
    
    print $FILEHANDLE "-T CombineVariants ";  #Type of analysis to run	
    print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
    print $FILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
    print $FILEHANDLE "-env ";  #Do not include loci found to be non-variant after the subsetting procedure.

    foreach my $variantCaller (@{${$parameterHashRef}{dynamicParameters}{variantCaller}}) {
	
	if (${$scriptParameterHashRef}{$variantCaller} > 0) {  #Expect vcf

	    my $programOutDirectoryName = ${$parameterHashRef}{$variantCaller}{outDirectoryName};
	    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$variantCaller}{fileTag};
	    print $FILEHANDLE "-V:".$programOutDirectoryName." ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf")." ";  #FamilyID infile
	}
    }

    print $FILEHANDLE "-o ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".vcf")." ";  #Union of variant call sets outfile
    print $FILEHANDLE "-genotypeMergeOptions PRIORITIZE ";

    if (defined(${$scriptParameterHashRef}{GATKCombineVariantsPrioritizeCaller})) {

	print $FILEHANDLE "-priority ".${$scriptParameterHashRef}{GATKCombineVariantsPrioritizeCaller};
    }
    else {

	print $FILEHANDLE "-priority ".join(",", @variantCallers);
    }
    say $FILEHANDLE "\n";
    
    if (${$scriptParameterHashRef}{GATKCombineVariantCallSetsBCFFile} == 1) {
	
	&VcfToBcf({infile => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType),
		   FILEHANDLE => $FILEHANDLE,
		  });
	
	## Copies file from temporary directory.
	say $FILEHANDLE "## Copy file from temporary directory";
	&MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".bcf*"),
			      filePath => $outFamilyDirectory,
			      FILEHANDLE => $FILEHANDLE,
			     });
    }

    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".vcf"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";

    close($FILEHANDLE);   

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{VCFFile}{ReadyVcf}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.".vcf");

	if (${$scriptParameterHashRef}{GATKCombineVariantCallSetsBCFFile} eq 1) {

	    ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{BCFFile}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.".bcf");
	}

	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 7, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName,
		       parallelChainsArrayRef => \@parallelChains,
		      });
    }
}


sub GATKVariantReCalibration { 

##GATKVariantReCalibration
    
##Function : GATK VariantRecalibrator/ApplyRecalibration.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $callType, $programName
##         : $parameterHashRef       => The parameter hash {REF}
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef      => Info on samples and family hash {REF}
##         : $fileInfoHashRef        => The fileInfo hash {REF}
##         : $jobIDHashRef           => The jobID hash {REF}
##         : $familyIDRef            => The familyID {REF}
##         : $alignerOutDirRef       => The alignerOutDir used in the analysis {REF}
##         : $callType               => The variant call type
##         : $programName            => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $programOutDirectoryName = ${$parameterHashRef}{"p".$programName}{outDirectoryName};

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							      jobIDHashRef => $jobIDHashRef,
							      FILEHANDLE => $FILEHANDLE,
							      directoryID => $$familyIDRef,
							      programName => $programName,
							      programDirectory => catfile(lc($$alignerOutDirRef), lc($programOutDirectoryName)),
							      callType => $callType,
							      nrofCores => $nrCores,
							      processTime => 10,
							      tempDirectory => catfile($$tempDirectoryRef, "gatk", "intermediary"),
							     });
    my ($volume, $directories, $stderrFile) = File::Spec->splitpath($programInfoPath.".stderr.txt");  #Split to enable submission to &SampleInfoQC later

    ## Assign directories
    my $outFamilyFileDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef);  #For ".fam" file
    my $inFamilyDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, $programOutDirectoryName);
    my $intermediarySampleDirectory = catfile($$tempDirectoryRef, "gatk", "intermediary");
    my $outFamilyDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, $programOutDirectoryName);
    ${$parameterHashRef}{"p".$programName}{inDirectory} = $outFamilyDirectory;  #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pGATKGenoTypeGVCFs}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{"p".$programName}{fileTag};

    ## Create .fam file to be used in variant calling analyses
    &CreateFamFile({scriptParameterHashRef => $scriptParameterHashRef,
		    FILEHANDLE => $FILEHANDLE,
		    famFilePath => catfile($outFamilyFileDirectory, $$familyIDRef.".fam"),
		   });
    
    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE,
			path => catfile($inFamilyDirectory, $$familyIDRef.$infileTag.$callType.".vcf*"),
			tempDirectory => $$tempDirectoryRef
		       });
    say $FILEHANDLE "wait", "\n";
    
    ## GATK VariantRecalibrator
    my @modes = ("SNP","INDEL");

    if ( (${$scriptParameterHashRef}{analysisType} eq "exomes") || (${$scriptParameterHashRef}{analysisType} eq "rapid") ) {  #Exome/rapid analysis

	@modes = ("BOTH");
    }

    for (my $modeCounter=0;$modeCounter<scalar(@modes);$modeCounter++) {  #SNP and INDEL will be recalibrated successively in the same file because when you specify eg SNP mode, the indels are emitted without modification, and vice-versa. Exome and Rapid will be processed using mode BOTH since there are to few INDELS to use in the recalibration model even though using 30 exome BAMS in Haplotypecaller step. 

	say $FILEHANDLE "## GATK VariantRecalibrator";

	## Writes java core commands to filehandle.
	&JavaCore({FILEHANDLE => $FILEHANDLE,
		   memoryAllocation => "Xmx6g",
		   javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		   javaTemporaryDirectory => $$tempDirectoryRef,
		   javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
		  });

	print $FILEHANDLE "-T VariantRecalibrator ";  #Type of analysis to run
	print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
	print $FILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
	print $FILEHANDLE "-recalFile ".catfile($intermediarySampleDirectory, $$familyIDRef.$infileTag.$callType.".intervals")." ";
	print $FILEHANDLE "-rscriptFile ".catfile($intermediarySampleDirectory, $$familyIDRef.$infileTag.$callType.".intervals.plots.R")." ";
	print $FILEHANDLE "-tranchesFile ".catfile($intermediarySampleDirectory, $$familyIDRef.$infileTag.$callType.".intervals.tranches")." ";

	if ( (${$scriptParameterHashRef}{analysisType} eq "exomes") || (${$scriptParameterHashRef}{analysisType} eq "rapid") ) {  #Exome/rapid analysis use combined reference for more power
	
	    print $FILEHANDLE "-input ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf")." ";  #Infile HaplotypeCaller combined vcf which used reference gVCFs to create combined vcf (30> samples gCVFs)
	}
	else {  #WGS
	    
	    if ($modes[$modeCounter] eq "SNP") {
	
		print $FILEHANDLE "-input ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf")." ";

		if (${$scriptParameterHashRef}{GATKVariantReCalibrationSnvMaxGaussians} ne 0) {
		    
		    print $FILEHANDLE "--maxGaussians 4 ";  #Use hard filtering
		}
	    }
	    if ($modes[$modeCounter] eq "INDEL") {#Use created recalibrated snp vcf as input
	
		print $FILEHANDLE "-input ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".SNV.vcf")." ";
	    }
	    if (${$scriptParameterHashRef}{GATKVariantReCalibrationDPAnnotation} == 1) {  #Special case: Not to be used with hybrid capture. NOTE: Disable when analysing exom + genomes using '-at genomes' 

		print $FILEHANDLE "-an DP ";  #The names of the annotations which should used for calculations.
	    }
	}
	if ( ($modes[$modeCounter] eq "SNP") || ($modes[$modeCounter] eq "BOTH") ) {
	    
	    print $FILEHANDLE "-resource:hapmap,VCF,known=false,training=true,truth=true,prior=15.0 ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{GATKVariantReCalibrationTrainingSetHapMap})." ";  #A list of sites for which to apply a prior probability of being correct but which are not used by the algorithm
	    print $FILEHANDLE "-resource:omni,VCF,known=false,training=true,truth=false,prior=12.0 ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{GATKVariantReCalibrationTrainingSet1000GOmni})." ";  #A list of sites for which to apply a prior probability of being correct but which are not used by the algorithm
	    print $FILEHANDLE "-resource:1000G,known=false,training=true,truth=false,prior=10.0 ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{GATKVariantReCalibrationTrainingSet1000GSNP})." ";  #A list of sites for which to apply a prior probability of being correct but which are not used by the algorithm
	    print $FILEHANDLE "-an MQ ";  #The names of the annotations which should used for calculations.
	}
	if ( ($modes[$modeCounter] eq "INDEL") || ($modes[$modeCounter] eq "BOTH") ) {
	    
	    print $FILEHANDLE "-resource:mills,VCF,known=true,training=true,truth=true,prior=12.0 ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{GATKVariantReCalibrationTrainingSetMills})." ";  #A list of sites for which to apply a prior probability of being correct but which are not used by the algorithm

	    if (${$scriptParameterHashRef}{GATKVariantReCalibrationIndelMaxGaussians} ne 0) {
		
		print $FILEHANDLE "--maxGaussians 4 ";  #Use hard filtering
	    }
	}
	print $FILEHANDLE "-resource:dbsnp,known=true,training=false,truth=false,prior=2.0 ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{GATKVariantReCalibrationTrainingSetDbSNP})." ";  #A list of sites for which to apply a prior probability of being correct but which are not used by the algorithm
    
	print $FILEHANDLE "-an QD ";  #The names of the annotations which should used for calculations
	print $FILEHANDLE "-an MQRankSum ";  #The names of the annotations which should used for calculations
	print $FILEHANDLE "-an ReadPosRankSum ";  #The names of the annotations which should used for calculations
	print $FILEHANDLE "-an FS ";  #The names of the annotations which should used for calculations
	print $FILEHANDLE "-an SOR ";  #The names of the annotations which should used for calculations
	print $FILEHANDLE "--mode ".$modes[$modeCounter]." ";  #Recalibration mode to employ (SNP|INDEL|BOTH)
	print $FILEHANDLE "-nt ".${$scriptParameterHashRef}{maximumCores}." ";  #How many data threads should be allocated to running this analysis    

	## Check if "--pedigree" and "--pedigreeValidationType" should be included in analysis
	&GATKPedigreeFlag({scriptParameterHashRef => $scriptParameterHashRef,
			   FILEHANDLE => $FILEHANDLE,
			   outFamilyFileDirectory => $outFamilyFileDirectory,
			   pedigreeValidationType => "SILENT",
			   programName => $programName,
			  });
	
	## GATK ApplyRecalibration
	say $FILEHANDLE "\n\n## GATK ApplyRecalibration";

	## Writes java core commands to filehandle.
	&JavaCore({FILEHANDLE => $FILEHANDLE,
		   memoryAllocation => "Xmx6g",
		   javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		   javaTemporaryDirectory => $$tempDirectoryRef,
		   javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
		  });

	print $FILEHANDLE "-T ApplyRecalibration ";
	print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
	print $FILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
	print $FILEHANDLE "-recalFile ".catfile($intermediarySampleDirectory, $$familyIDRef.$infileTag.$callType.".intervals")." ";
	print $FILEHANDLE "-tranchesFile ".catfile($intermediarySampleDirectory, $$familyIDRef.$infileTag.$callType.".intervals.tranches")." ";

	if ( (${$scriptParameterHashRef}{analysisType} eq "exomes") || (${$scriptParameterHashRef}{analysisType} eq "rapid")) {  #Exome/rapid analysis use combined reference for more power
	    
	    print $FILEHANDLE "-input ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf")." ";  #Infile HaplotypeCaller combined vcf which used reference gVCFs to create combined vcf file
	    print $FILEHANDLE "-o ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_filtered.vcf")." ";
	}
	else  {  #WGS
	    
	    if ($modes[$modeCounter] eq "SNP") {
		
		print $FILEHANDLE "-input ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf")." ";
		print $FILEHANDLE "-o ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".SNV.vcf")." ";
		print $FILEHANDLE "--ts_filter_level ".${$scriptParameterHashRef}{GATKVariantReCalibrationSnvTSFilterLevel}." ";
	    }
	    if ($modes[$modeCounter] eq "INDEL") {#Use created recalibrated snp vcf as input
	
		print $FILEHANDLE "-input ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".SNV.vcf")." ";
		print $FILEHANDLE "-o ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".vcf")." ";
		print $FILEHANDLE "--ts_filter_level ".${$scriptParameterHashRef}{GATKVariantReCalibrationIndelTSFilterLevel}." ";
	    }
	}

	## Check if "--pedigree" and "--pedigreeValidationType" should be included in analysis
	&GATKPedigreeFlag({scriptParameterHashRef => $scriptParameterHashRef,
			   FILEHANDLE => $FILEHANDLE,
			   outFamilyFileDirectory => $outFamilyFileDirectory,
			   pedigreeValidationType => "SILENT",
			   programName => $programName,
			  });
 
	print $FILEHANDLE "--mode ".$modes[$modeCounter]." ";  #Recalibration mode to employ (SNP|INDEL|BOTH)
	say $FILEHANDLE "\n";
    }

    ## GATK SelectVariants

    ## Removes all genotype information for exome ref and recalulates meta-data info for remaining samples in new file.
    if ( (${$scriptParameterHashRef}{analysisType} eq "exomes") || (${$scriptParameterHashRef}{analysisType} eq "rapid") ) {  #Exome/rapid analysis
	
	say $FILEHANDLE "## GATK SelectVariants";

	## Writes java core commands to filehandle.
	&JavaCore({FILEHANDLE => $FILEHANDLE,
		   memoryAllocation => "Xmx2g",
		   javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		   javaTemporaryDirectory => $$tempDirectoryRef,
		   javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
		  });
	
	print $FILEHANDLE "-T SelectVariants ";  #Type of analysis to run
	print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
	print $FILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file	
	print $FILEHANDLE "-env ";  #Do not include loci found to be non-variant after the subsetting procedure. 
	print $FILEHANDLE "-V: ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_filtered.vcf")." ";  #InFile

	for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {  #For all sampleIDs
		
	    print $FILEHANDLE "-sn ".${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter]." ";  #Include genotypes from this sample
	}
	print $FILEHANDLE "-o ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".vcf")." ";  #OutFile
	print $FILEHANDLE " &"; 
	
	## Produces another vcf file containing non-variant loci (useful for example in MAF comparisons), but is not used downstream in MIP
	if (${$scriptParameterHashRef}{GATKVariantReCalibrationexcludeNonVariantsFile} eq 1) {

	    say $FILEHANDLE "\n\n#GATK SelectVariants","\n";

	    ## Writes java core commands to filehandle.
	    &JavaCore({FILEHANDLE => $FILEHANDLE,
		       memoryAllocation => "Xmx2g",
		       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		       javaTemporaryDirectory => $$tempDirectoryRef,
		       javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
		      });

	    print $FILEHANDLE "-T SelectVariants ";  #Type of analysis to run	    
	    print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
	    print $FILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file	
	    print $FILEHANDLE "-V: ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_filtered.vcf")." ";  #InFile
	    print $FILEHANDLE "-o ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_incnonvariantloci.vcf")." ";  #OutFile
	    
	    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {  #For all sampleIDs
		
		print $FILEHANDLE "-sn ".${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter]." ";  #Include genotypes from this sample
	    }
	    say $FILEHANDLE "\n\nwait\n";

	    ## Copies file from temporary directory.
	    say $FILEHANDLE "## Copy file from temporary directory";
	    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_incnonvariantloci.vcf*"),
				  filePath => $outFamilyDirectory,
				  FILEHANDLE => $FILEHANDLE,
				 });
	}
	say $FILEHANDLE "\n\nwait\n";
    }

    ## GenotypeRefinement
    if (${$parameterHashRef}{dynamicParameters}{trio}) {

	say $FILEHANDLE "## GATK CalculateGenotypePosteriors";
	
	## Writes java core commands to filehandle.
	&JavaCore({FILEHANDLE => $FILEHANDLE,
		   memoryAllocation => "Xmx6g",
		   javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		   javaTemporaryDirectory => $$tempDirectoryRef,
		   javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
		  });

	print $FILEHANDLE "-T CalculateGenotypePosteriors ";  #Type of analysis to run	    
	print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
	print $FILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
	
	## Check if "--pedigree" and "--pedigreeValidationType" should be included in analysis
	&GATKPedigreeFlag({scriptParameterHashRef => $scriptParameterHashRef,
			   FILEHANDLE => $FILEHANDLE,
			   outFamilyFileDirectory => $outFamilyFileDirectory,
			   pedigreeValidationType => "SILENT",
			   programName => $programName,
			  });

	print $FILEHANDLE "--supporting ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{GATKCalculateGenotypePosteriorsSupportSet})." ";  #Supporting data set
	print $FILEHANDLE "-V ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".vcf")." ";  #Infile
	print $FILEHANDLE "-o ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_refined.vcf")." ";  #Outfile
	say $FILEHANDLE "\n";

	## Change name of file to accomodate downstream
	print $FILEHANDLE "mv ";
	print $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_refined.vcf")." ";
	print $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".vcf");
	say $FILEHANDLE "\n";
    }

    ## Produce a bcf compressed and index from vcf
    if (${$scriptParameterHashRef}{GATKVariantReCalibrationBCFFile} == 1) {
	
	&VcfToBcf({infile => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType),
		   FILEHANDLE => $FILEHANDLE,
		  });
	
	## Copies file from temporary directory.
	say $FILEHANDLE "## Copy file from temporary directory";
	&MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".bcf*"),
			      filePath => $outFamilyDirectory,
			      FILEHANDLE => $FILEHANDLE,
			     });
	say $FILEHANDLE "wait", "\n";
    }
    
    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".vcf*"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    &MigrateFileFromTemp({tempPath => catfile($intermediarySampleDirectory, $$familyIDRef.$infileTag.$callType.".intervals.tranches.pdf"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";

    close($FILEHANDLE);   
    	
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	## Collect QC metadata info for later use
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => ${$scriptParameterHashRef}{familyID},
		       programName => "PedigreeCheck",  #Disabled pedigreeCheck to not include relationship test is qcCollect
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.$outfileTag.$callType.".vcf",
		       outDataType => "infileDependent"
		      });
	${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{VCFFile}{ReadyVcf}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.".vcf");	

	if (${$scriptParameterHashRef}{GATKVariantReCalibrationBCFFile} eq 1) {

	    ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{BCFFile}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.".bcf");
	}
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub GATKConcatenateGenoTypeGVCFs { 

##GATKConcatenateGenoTypeGVCFs
    
##Function : Concatenate GVCFs produced after GATKGenoTypeGVCFs done per contig. 
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $laneHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $callType, $programName
##         : $parameterHashRef       => The parameter hash {REF}
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef      => Info on samples and family hash {REF}
##         : $fileInfoHashRef        => The fileInfo hash {REF}
##         : $laneHashRef            => The lane info hash {REF}
##         : $jobIDHashRef           => The jobID hash {REF}
##         : $familyIDRef            => The familyID {REF}
##         : $alignerOutDirRef       => The alignerOutDir used in the analysis {REF}
##         : $callType               => The variant call type
##         : $programName            => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "GATKConcatenateGenoTypeGVCFs");  #Special case


    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $nrCores = ${$scriptParameterHashRef}{maximumCores};

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header	
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$familyIDRef,
					    programName => $programName,
					    programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
					    callType => $callType,
					    nrofCores => $nrCores,
					    processTime => 10,
					    tempDirectory => $$tempDirectoryRef
					   });
    
    ## Assign directories
    my $inFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pGATKGenoTypeGVCFs}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pGATKGenoTypeGVCFs}{fileTag}; 

    my $coreCounter = 1;
    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigs}});$contigsCounter++) {
	
	&PrintWait({counterRef => \$contigsCounter,
		    nrCoresRef => \$nrCores,
		    coreCounterRef => \$coreCounter,
		    FILEHANDLE => $FILEHANDLE,
		   });

	## Copy file(s) to temporary directory
	&MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
			    path => catfile($inFamilyDirectory, $$familyIDRef.$infileTag.$callType."_".${$fileInfoHashRef}{contigs}[$contigsCounter].".vcf*"),
			    tempDirectory => $$tempDirectoryRef
			   });
    }
     say $FILEHANDLE "wait", "\n";

    ## Writes sbatch code to supplied filehandle to concatenate variants in vcf format. Each array element is combined with the infilePre and Postfix.
    &ConcatenateVariants({scriptParameterHashRef => $scriptParameterHashRef,
			  FILEHANDLE => $FILEHANDLE,
			  arrayRef => \@{${$fileInfoHashRef}{contigs}},
			  infilePrefix => catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_"), 
			  infilePostfix => ".vcf",
			  outfile => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".vcf"),
			 });
    
    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".vcf*"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    
    close($FILEHANDLE);
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub GATKGenoTypeGVCFs { 

##GATKGenoTypeGVCFs
    
##Function : GATK GenoTypeGVCFs. 
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $laneHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $callType, $programName
##         : $parameterHashRef       => The parameter hash {REF}
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef      => Info on samples and family hash {REF}
##         : $fileInfoHashRef        => The fileInfo hash {REF}
##         : $laneHashRef            => The lane info hash {REF}
##         : $jobIDHashRef           => The jobID hash {REF}
##         : $familyIDRef            => The familyID {REF}
##         : $alignerOutDirRef       => The alignerOutDir used in the analysis {REF}
##         : $callType               => The variant call type
##         : $programName            => The program name

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $sbatchScriptTracker=0;
    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $processTime = 10;

    if (${$scriptParameterHashRef}{GATKGenoTypeGVCFsAllSites} eq 1) {
	
	$processTime = 50;  #Including all sites requires longer processing time
    }

     ## Assign directories
    my $outFamilyFileDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef);  #For ".fam" file

    ## Create .fam file to be used in variant calling analyses
    &CreateFamFile({scriptParameterHashRef => $scriptParameterHashRef,
		    FILEHANDLE => $FILEHANDLE,
		    famFilePath => catfile($outFamilyFileDirectory, $$familyIDRef.".fam"),
		   });

    ## Split per contig
    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigs}});$contigsCounter++) {    

	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header	
	my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
						jobIDHashRef => $jobIDHashRef,
						FILEHANDLE => $FILEHANDLE,
						directoryID => $$familyIDRef,
						programName => $programName,
						programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
						callType => $callType,
						nrofCores => $nrCores,
						processTime => $processTime,
						tempDirectory => $$tempDirectoryRef
					       });
	
	## Assign directories
	my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
	${$parameterHashRef}{"p".$programName}{inDirectory} = $outFamilyDirectory;  #Used downstream

	## Assign fileTags
	my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{"p".$programName}{fileTag}; 
	
	## Collect infiles for all sampleIDs to enable migration to temporary directory
	for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {
	    
	    ## Add merged infile name after merging all BAM files per sampleID
	    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter]}{MergeInfile};  #Alias
	    
	    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter], $$alignerOutDirRef, "gatk");
	    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{ ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter] }{pGATKHaploTypeCaller}{fileTag};
	    
	    ## Copy file(s) to temporary directory
	    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
	    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
				path => catfile($inSampleDirectory, $infile.$infileTag."_".${$fileInfoHashRef}{contigs}[$contigsCounter].".vcf*"),
				tempDirectory => $$tempDirectoryRef
			       });
	    say $FILEHANDLE "wait", "\n";
	}
	
	## GATK GenoTypeGVCFs
	say $FILEHANDLE "## GATK GenoTypeGVCFs";
	
	## Writes java core commands to filehandle.
	&JavaCore({FILEHANDLE => $FILEHANDLE,
		   memoryAllocation => "Xmx24g",
		   javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		   javaTemporaryDirectory => $$tempDirectoryRef,
		   javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
		  });
	
	print $FILEHANDLE "-T GenotypeGVCFs ";  #Type of analysis to run    
	print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
	print $FILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
	print $FILEHANDLE "-D ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{GATKHaploTypeCallerSNPKnownSet})." ";  #Known SNPs to use for annotation SNPs
	print $FILEHANDLE "-nt 16 ";  #How many data threads should be allocated to running this analysis.

	## Check if "--pedigree" and "--pedigreeValidationType" should be included in analysis
	&GATKPedigreeFlag({scriptParameterHashRef => $scriptParameterHashRef,
			   FILEHANDLE => $FILEHANDLE,
			   outFamilyFileDirectory => $outFamilyFileDirectory,
			   pedigreeValidationType => "SILENT",
			   programName => $programName,
			  });

	if (${$scriptParameterHashRef}{GATKGenoTypeGVCFsAllSites} eq 1) {

	    print $FILEHANDLE "-allSites ";  #Include loci found to be non-variant after genotyping
	}

	print $FILEHANDLE "-L ".${$fileInfoHashRef}{contigs}[$contigsCounter]." ";  #Per contig

	if ( (${$scriptParameterHashRef}{analysisType} eq "exomes") || (${$scriptParameterHashRef}{analysisType} eq "rapid") ) {
	    			
	    print $FILEHANDLE "-V ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{GATKGenoTypeGVCFsRefGVCF})." ";
	}
	
	for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {  #Collect infiles for all sampleIDs

	    ## Add merged infile name after merging all BAM files per sampleID
	    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter]}{MergeInfile};  #Alias	    
	    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{ ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter] }{pGATKHaploTypeCaller}{fileTag};
	    
	    print $FILEHANDLE "-V ".catfile($$tempDirectoryRef, $infile.$infileTag."_".${$fileInfoHashRef}{contigs}[$contigsCounter].".vcf")." ";  #InFile
	} 
	say $FILEHANDLE "-o ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".${$fileInfoHashRef}{contigs}[$contigsCounter].".vcf"), "\n";  #OutFile

	## Copies file from temporary directory.
	say $FILEHANDLE "## Copy file from temporary directory";
	&MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".${$fileInfoHashRef}{contigs}[$contigsCounter].".vcf*"),
			      filePath => $outFamilyDirectory,
			      FILEHANDLE => $FILEHANDLE,
			     });
	say $FILEHANDLE "wait", "\n";
	    
	close($FILEHANDLE);  
	
	if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	    ## Collect QC metadata info for later use
	    ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{VCFFile}{ReadyVcf}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.".vcf");
	    
	    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			   sampleInfoHashRef => $sampleInfoHashRef,
			   jobIDHashRef => $jobIDHashRef,
			   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			   dependencies => 3, 
			   path => ${$parameterHashRef}{"p".$programName}{chain},
			   sbatchFileName => $fileName,
			   sbatchScriptTracker => $sbatchScriptTracker
			  });
	}
	$sbatchScriptTracker++; #Tracks nr of sbatch scripts
    }
}


sub RCoveragePlots { 

##RCoveragePlots
    
##Function : Generates sbatch scripts for R scripts: 1. covplots_genome.R 2. covplots_exome.R; on files generated from calculateCoverage genomeCoverageBED.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $laneHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $sampleID, $alignerOutDir, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleID                   => The sampleID
##         : $alignerOutDir              => The alignerOutDir used in the analysis
##         : $programName                => The program name

    my $parameterHashRef = $_[0];
    my $scriptParameterHashRef = $_[1];
    my $sampleInfoHashRef = $_[2];
    my $fileInfoHashRef = $_[3];
    my $laneHashRef = $_[4];
    my $infilesLaneNoEndingHashRef = $_[5];
    my $jobIDHashRef = $_[6];
    my $sampleID = $_[7];
    my $alignerOutDir = $_[8];
    my $programName = $_[9];

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $sampleID,
					    programName => $programName,
					    programDirectory => catfile(lc($alignerOutDir), "coveragereport"),
					    tempDirectory => ${$scriptParameterHashRef}{tempDirectory}
					   });
    
    ## Assign directories
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $sampleID, $alignerOutDir, "coveragereport");
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $sampleID, $alignerOutDir, "coveragereport");

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{pGenomeCoverageBED}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{pGATKBaseRecalibration}{fileTag};

    ## Add merged infile name after merging all BAM files per sampleID
    my $infile = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{MergeInfile};  #Alias
    
    if ( defined(${$scriptParameterHashRef}{pGenomeCoverageBED}) && (${$scriptParameterHashRef}{pGenomeCoverageBED} > 0) ) {
	
	print $FILEHANDLE "Rscript ";
	print $FILEHANDLE catfile(${$scriptParameterHashRef}{inScriptDir}, "covplots_genome.R")."  ";
	print $FILEHANDLE catfile($inSampleDirectory, $infile.$infileTag)." ";  #InFile
	print $FILEHANDLE $infile." ";  #Sample name
	print $FILEHANDLE ${$scriptParameterHashRef}{GenomeCoverageBEDMaxCoverage}." ";  #X-axis max scale
	say $FILEHANDLE $outSampleDirectory, " &", "\n";  #OutFile
    }
    say $FILEHANDLE "wait", "\n";
    close($FILEHANDLE);

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       sampleID => $sampleID,
		       dependencies => 2, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
    return;
}


sub GenomeCoverageBED { 

##GenomeCoverageBED
    
##Function : Calculates coverage on BAM files.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $familyIDRef, $sampleID, $alignerOutDir, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $sampleID                   => The sampleID
##         : $alignerOutDir              => The alignerOutDir used in the analysis
##         : $programName                => The program name
    
    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infileHashRef = ${$argHashRef}{infileHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $programName = ${$argHashRef}{programName};
    
    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} },  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{$$sampleIDRef},  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     sampleIDRef => $$sampleIDRef,
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $fileName;
    
    ## Assign directories
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk");
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "coveragereport");

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{pGATKBaseRecalibration}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{"p".$programName}{fileTag};

    ## Add merged infile name after merging all BAM files per sampleID
    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias

    my $coreCounter=1;
    my $nrCores=1;

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					 jobIDHashRef => $jobIDHashRef,
					 FILEHANDLE => $FILEHANDLE,
					 directoryID => $$sampleIDRef,
					 programName => $programName,
					 programDirectory => catfile(lc($$alignerOutDirRef), "coveragereport"),
					 nrofCores => $nrCores,
					 processTime => 16,
					 tempDirectory => $$tempDirectoryRef,
					});
    
    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory";
    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
			path => catfile($inSampleDirectory, $infile.$infileTag.".b*"),
			tempDirectory => $$tempDirectoryRef,
		       });
    say $FILEHANDLE "wait", "\n";
    
    ## GenomeCoverageBed
    say $FILEHANDLE "## Calculate coverage metrics on alignment";
    print $FILEHANDLE "genomeCoverageBed ";
    print $FILEHANDLE "-max ".${$scriptParameterHashRef}{GenomeCoverageBEDMaxCoverage}." ";  #Combine all positions with a depth >= max into a single bin in the histogram.
    print $FILEHANDLE "-ibam ".catfile($$tempDirectoryRef, $infile.$infileTag.".bam")." ";  #InFile
    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $infile.$outfileTag)." ", "\n";  #OutFile
    
    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $infile.$outfileTag),
			  filePath => $outSampleDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";    
    close($FILEHANDLE);

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       sampleID => $$sampleIDRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
    return;
}


sub PicardToolsCalculateHSMetrics { 
 
##PicardToolsCalculateHSMetrics
    
##Function : Calculates coverage on exonic part of BAM files.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $sampleID, $alignerOutDir, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleID                   => The sampleID
##         : $alignerOutDir              => The alignerOutDir used in the analysis
##         : $programName                => The program name

    my ($argHashRef) = @_;
 
    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);
    
    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $fileName;

    ## Assign directories
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk");
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "coveragereport");

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{pGATKBaseRecalibration}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{"p".$programName}{fileTag};

    ## Add merged infile name after merging all BAM files per sampleID
    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias

    ## Alias exomeTargetBed endings
    my $infileListEndingRef = \${$fileInfoHashRef}{exomeTargetBed}[0];  
    my $paddedInfileListEndingRef = \${$fileInfoHashRef}{exomeTargetBed}[1];
    my $paddedIntervalListEndingRef = \${$fileInfoHashRef}{exomeTargetBed}[2];

    my $coreCounter=1;
    my $nrCores=1;

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					 jobIDHashRef => $jobIDHashRef,
					 FILEHANDLE => $FILEHANDLE,
					 directoryID => $$sampleIDRef,
					 programName => $programName,
					 programDirectory => catfile(lc($$alignerOutDirRef), "coveragereport"),
					 nrofCores => $nrCores,
					 processTime => 16,
					 tempDirectory => $$tempDirectoryRef,
					});
    
    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
			path => catfile($inSampleDirectory, $infile.$infileTag.".b*"),
			tempDirectory => $$tempDirectoryRef,
		       });
    say $FILEHANDLE "wait", "\n";
    
    ## CalculateHsMetrics
    say $FILEHANDLE "## Calculate capture metrics on alignment";
    
    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx4g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => $$tempDirectoryRef,
	       javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
	      });
    
    print $FILEHANDLE "CalculateHsMetrics ";
    print $FILEHANDLE "INPUT=".catfile($$tempDirectoryRef, $infile.$infileTag.".bam")." ";  #InFile
    print $FILEHANDLE "OUTPUT=".catfile($$tempDirectoryRef, $infile.$outfileTag)." ";  #OutFile
    print $FILEHANDLE "REFERENCE_SEQUENCE=".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file

    ## Get exomeTargetBed file for specfic sampleID and add fileEnding from fileInfoHash if supplied
    my $exomeTargetBedFile = &GetExomTargetBEDFile({scriptParameterHashRef => $scriptParameterHashRef,
						    sampleIDRef => $sampleIDRef,
						   });
    

    print $FILEHANDLE "BAIT_INTERVALS=".catfile($$referencesDirRef, $exomeTargetBedFile.$$paddedInfileListEndingRef)." ";  #Capture kit padded target infile_list file
    say $FILEHANDLE "TARGET_INTERVALS=".catfile($$referencesDirRef, $exomeTargetBedFile.$$infileListEndingRef), "\n";  #Capture kit target infile_list file
    
    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $infile.$outfileTag),
			  filePath => $outSampleDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    
    if ( (${$scriptParameterHashRef}{pPicardToolsCalculateHSMetrics} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	## Collect QC metadata info for later use
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => ${$scriptParameterHashRef}{familyID},
		       sampleID => $$sampleIDRef,
		       programName => "CalculateHsMetrics",
		       infile => $infile,
		       outDirectory => $outSampleDirectory,
		       outfileEnding => $outfileTag,
		       outDataType => "infileDependent"
		      });
    }    
    close($FILEHANDLE);

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       sampleID => $$sampleIDRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub PicardToolsCollectMultipleMetrics { 
 
##PicardToolsCollectMultipleMetrics
    
##Function : Calculates coverage and alignment metrics on BAM files.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $sampleIDRef, $alignerOutDirRef, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleIDRef                => The sampleID
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis
##         : $programName                => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);
    
    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $fileName;

    ## Assign directories
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk");
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "coveragereport");

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{pGATKBaseRecalibration}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{pGATKBaseRecalibration}{fileTag};

    ## Add merged infile name after merging all BAM files per sampleID
    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias

    my $nrCores = 1;
    my $coreCounter=1;

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					 jobIDHashRef => $jobIDHashRef,
					 FILEHANDLE => $FILEHANDLE,
					 directoryID => $$sampleIDRef,
					 programName => $programName,
					 programDirectory => catfile(lc($$alignerOutDirRef), "coveragereport"),
					 nrofCores => $nrCores,
					 processTime => 16,
					 tempDirectory => $$tempDirectoryRef,
					});

    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
			path => catfile($inSampleDirectory, $infile.$infileTag.".b*"),
			tempDirectory => $$tempDirectoryRef,
		       });
    say $FILEHANDLE "wait", "\n";
    
    ## CollectMultipleMetrics
    say $FILEHANDLE "## Collecting multiple metrics on alignment";
    
    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx4g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => $$tempDirectoryRef,
	       javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
	      });
    
    print $FILEHANDLE "CollectMultipleMetrics ";
    print $FILEHANDLE "INPUT=".catfile($$tempDirectoryRef, $infile.$infileTag.".bam")." ";  #InFile
    print $FILEHANDLE "OUTPUT=".catfile($$tempDirectoryRef, $infile.$outfileTag)." ";  #OutFile
    say $FILEHANDLE "R=".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference}), "\n";  #Reference file
    
    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $infile.$outfileTag.".alignment_summary_metrics"),
			  filePath => $outSampleDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $infile.$outfileTag.".quality*"),
			  filePath => $outSampleDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $infile.$outfileTag.".insert*"),
			  filePath => $outSampleDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    
    if ( (${$scriptParameterHashRef}{pPicardToolsCollectMultipleMetrics} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	## Collect QC metadata info for later use                                                                                             
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       sampleID => $$sampleIDRef,
		       programName => "CollectMultipleMetrics",
		       infile => $infile,
		       outDirectory => $outSampleDirectory,
		       outfileEnding => $outfileTag.".alignment_summary_metrics",
		       outDataType => "infileDependent"
		      });
    }    
    close($FILEHANDLE);

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       sampleID => $$sampleIDRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub ChanjoSexCheck {

##ChanjoSexCheck
    
##Function : Predict gender from BAM files.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $sampleIDRef, $alignerOutDirRef, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleIDRef                => The sampleID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $programName                => The program name
    
    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $fileName;      
    
    ## Assign directories               
    my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef);
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk");
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "coveragereport");

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{ $$familyIDRef }{$$sampleIDRef}{pGATKBaseRecalibration}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{ $$familyIDRef }{$$sampleIDRef}{"p".$programName}{fileTag};

    ## Add merged infile name after merging all BAM files per sampleID
    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias

    my $coreCounter=1;	

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					 jobIDHashRef => $jobIDHashRef,
					 FILEHANDLE => $FILEHANDLE,
					 directoryID => $$sampleIDRef,
					 programName => $programName,
					 programDirectory => catfile(lc($$alignerOutDirRef), "coveragereport"),
					 processTime => 2,
					});
   
    ## ChanjoSexCheck
    say $FILEHANDLE "## Predicting sex from alignment";
    print $FILEHANDLE "chanjo ";  #Program
    print $FILEHANDLE "-v -v ";  #Incrementing "-v" for increased verbosity
    print $FILEHANDLE "--log_file ".catfile($outSampleDirectory, $infile.$infileTag."_chanjoSexCheck.log")." ";
    print $FILEHANDLE "sex ";  #Sub command

    ## Set chromosome prefix if required
    if (any {$_ eq "chrX"} @{${$fileInfoHashRef}{contigsSizeOrdered}}) {  #If element is part of array

	print $FILEHANDLE "--prefix chr ";
    }
    print $FILEHANDLE catfile($inSampleDirectory, $infile.$infileTag.".bam")." ";  #InFile
    say $FILEHANDLE "> ".catfile($outSampleDirectory, $infile.$outfileTag), "\n";  #OutFile
    
    if ( (${$scriptParameterHashRef}{pChanjoSexCheck} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	## Collect QC metadata info for later use
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       sampleID => $$sampleIDRef,
		       programName => "ChanjoSexCheck",
		       infile => $infile,
		       outDirectory => $outSampleDirectory,
		       outfileEnding => $outfileTag,
		       outDataType => "infileDependent"
		      });
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => ${$scriptParameterHashRef}{familyID},
		       sampleID => $$sampleIDRef,
		       programName => "Chanjo",
		       infile => $infile,
		       outDirectory => $outSampleDirectory,
		       outfileEnding => $infileTag."_chanjoSexCheck.log",
		       outDataType => "infileDependent"
		      });
    }
    close($FILEHANDLE);

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       sampleID => $$sampleIDRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub SambambaDepth { 

##SambambaDepth
    
##Function : Generate coverage bed outfile for each individual.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $sampleIDRef, $alignerOutDirRef, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleIDRef                => The sampleID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $programName                => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $fileName;
    my $nrCores = 1;      

    ## Assign directories
    my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef);
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk");
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "coveragereport");

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{pGATKBaseRecalibration}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{"p".$programName}{fileTag};

    ## Add merged infile name after merging all BAM files per sampleID
    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias

    my $coreCounter=1;	

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					 jobIDHashRef => $jobIDHashRef,
					 FILEHANDLE => $FILEHANDLE,
					 directoryID => $$sampleIDRef,
					 programName => $programName,
					 programDirectory => catfile(lc($$alignerOutDirRef), "coveragereport"),
					 nrofCores => $nrCores,
					 processTime => 10,
					 tempDirectory => $$tempDirectoryRef,
					});
    
    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
			path => catfile($inSampleDirectory, $infile.$infileTag.".b*"),
			tempDirectory => $$tempDirectoryRef
		       });
    say $FILEHANDLE "wait", "\n";
    
    ## SambambaDepth
    say $FILEHANDLE "## Annotating bed from alignment";
    print $FILEHANDLE "sambamba ";  #Program
    print $FILEHANDLE "depth ";  #Sub command
    print $FILEHANDLE "region "; #Mode
    print $FILEHANDLE "--regions ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{sambambaDepthBed})." ";  #Region to calculate coverage on
    print $FILEHANDLE "--fix-mate-overlaps ";
    print $FILEHANDLE "--min-base-quality ".${$scriptParameterHashRef}{sambambaDepthBaseQuality}." ";  #The minimum base quality to include in analysis
    print $FILEHANDLE q?--filter '?;
    print $FILEHANDLE "mapping_quality >= ".${$scriptParameterHashRef}{sambambaDepthMappingQuality}." ";  #The minimum mapping quality to include in analysis
    
    if (${$scriptParameterHashRef}{sambambaDepthNoDuplicates} == 1) {  #Do not include duplicates in coverage calculation
	
	print $FILEHANDLE "and not duplicate ";
    }
    if (${$scriptParameterHashRef}{sambambaDepthNoFailedQualityControl} == 1) {  #Do not include failed quality control reads in coverage calculation
	
	print $FILEHANDLE "and not failed_quality_control";
    }
    
    print $FILEHANDLE q?' ?;
    
    foreach my $cutoff (@{${$scriptParameterHashRef}{sambambaDepthCutOffs}}) {
	
	print $FILEHANDLE "--cov-threshold ".$cutoff." ";  #The “cutoff” is used for the completeness calculation    
    } 
    
    print $FILEHANDLE catfile($$tempDirectoryRef, $infile.$infileTag.".bam")." ";  #InFile
    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $infile.$outfileTag.".bed"). "\n";  #OutFile
    
    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $infile.$outfileTag.".bed"),
			  filePath => $outSampleDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    
    if ( (${$scriptParameterHashRef}{pSambambaDepth} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	${$sampleInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{Program}{$programName}{$infile}{Bed}{Path} = catfile($outSampleDirectory, $infile.$outfileTag.".bed");
    }

    close($FILEHANDLE);

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       sampleID => $$sampleIDRef,
		       dependencies => 5, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub SVRankVariants { 

##SVRankVariants
    
##Function : Annotate and score SV variants depending on mendelian inheritance, frequency and phenotype etc.
##Returns  : "|$xargsFileCounter"
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $callType, $programName, $programInfoPath, $fileName, $FILEHANDLE, $xargsFileCounter
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyIDRef {REF}
##         : $alignerOutDir              => The alignerOutDir used in the analysis
##         : $callType                   => The variant call type
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
##         : $fileName                   => File name
##         : $FILEHANDLE                 => Sbatch filehandle to write to
##         : $xargsFileCounter           => The xargs file counter

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "SV";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $fileName = ${$argHashRef}{fileName};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    
    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 20;

    ## Set the number of cores
    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $genModnrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
					     nrCores => 16
					    });  #Detect the number of cores to use per genmod process.
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script
	
	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    
	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$familyIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
							       nrofCores => $nrCores,
							       processTime => 10,
							       tempDirectory => $$tempDirectoryRef
							      });
    }

    ## Assign directories
    my $inFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    
    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pSVVCFParser}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{"p".$programName}{fileTag};

    my $vcfParserAnalysisType = "";
    my $vcfParserContigsArrayRef = \@{ ${$fileInfoHashRef}{contigsSizeOrdered} };  #Set default

    for (my $vcfParserOutputFileCounter=0;$vcfParserOutputFileCounter<${$scriptParameterHashRef}{VcfParserOutputFileCount};$vcfParserOutputFileCounter++) {
	
	if ($vcfParserOutputFileCounter == 1) {
	    
	    $vcfParserAnalysisType = ".selected";  #SelectFile variants
	    $vcfParserContigsArrayRef = \@{${$fileInfoHashRef}{SelectFileContigs}};  #Selectfile contigs
	}
	
	## Copy file(s) to temporary directory
	say $FILEHANDLE "## Copy file(s) to temporary directory";
	$xargsFileCounter = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
						      XARGSFILEHANDLE => $XARGSFILEHANDLE,
						      arrayRef => $vcfParserContigsArrayRef,
						      fileName => $fileName,
						      programInfoPath => $programInfoPath,
						      nrCores => $nrCores,
						      xargsFileCounter => $xargsFileCounter,
						      infile => $$familyIDRef.$infileTag.$callType,
						      fileEnding => $vcfParserAnalysisType.".vcf*",
						      inDirectory => $inFamilyDirectory,
						      tempDirectory => ${$scriptParameterHashRef}{tempDirectory},
						     });
	
	## Calculate Gene Models
	say $FILEHANDLE "## Calculate Gene Models";   
	
	if (${$scriptParameterHashRef}{analysisType} eq "exomes") {
	    
	    ## Clear trap for signal(s)
	    &ClearTrap({FILEHANDLE => $FILEHANDLE,
		       });
	}
	
	## Create file commands for xargs
	($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							     XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							     fileName => $fileName,
							     programInfoPath => $programInfoPath, 
							     nrCores => $genModnrCores,
							     xargsFileCounter => $xargsFileCounter,
							     firstCommand => "genmod",
							    });
    
	## Process per contig
	for (my $contigsCounter=0;$contigsCounter<scalar(@{$vcfParserContigsArrayRef});$contigsCounter++) {
	    
	    my $contigRef = \${$vcfParserContigsArrayRef}[$contigsCounter];
	    
	    ## Genmod Models
	    print $XARGSFILEHANDLE "-v ";  #Increase output verbosity
	    print $XARGSFILEHANDLE "models ";  #Annotate genetic models for vcf variants
	    print $XARGSFILEHANDLE "--temp_dir ".$$tempDirectoryRef." ";  #Temporary directory
	    print $XARGSFILEHANDLE "--family_file ".${$scriptParameterHashRef}{pedigreeFile}." ";  #Pedigree file
	    print $XARGSFILEHANDLE "--family_type ".${$scriptParameterHashRef}{svGenmodModelsFamilyType}." ";  #Family type
	    
	    if (defined(${$scriptParameterHashRef}{svGenmodModelsReducedPenetranceFile})) {
		
		print $XARGSFILEHANDLE "--reduced_penetrance ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{svGenmodModelsReducedPenetranceFile})." ";  #Use list of genes that have been shown to display reduced penetrance
	    }
	    print $XARGSFILEHANDLE "--processes 4 ";  #Define how many processes that should be use for annotation 
	    
	    if (${$scriptParameterHashRef}{pSVVariantEffectPredictor} > 0) {  #Use VEP annotations in compound models
		
		print $XARGSFILEHANDLE "--vep "; 
	    }
	    if (${$scriptParameterHashRef}{svWholeGene} == 1) {
		
		print $XARGSFILEHANDLE "--whole_gene "; 
	    }
	    
	    print $XARGSFILEHANDLE "-o ".catfile(dirname(devnull()), "stdout")." ";  #OutFile
	    print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.$vcfParserAnalysisType.".vcf")." ";  #InFile
	    print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef."_models.stderr.txt ";  #Redirect xargs output to program specific stderr file
	    print $XARGSFILEHANDLE "| ";  #Pipe
	    
	    
	    ## Genmod Score
	    print $XARGSFILEHANDLE "genmod ";
	    print $XARGSFILEHANDLE "-v ";  #Increase output verbosity
	    print $XARGSFILEHANDLE "score ";  #Score variants in a vcf file using Weighted sums
	    print $XARGSFILEHANDLE "--family_file ".${$scriptParameterHashRef}{pedigreeFile}." ";  #Pedigree file
	    print $XARGSFILEHANDLE "--family_type ".${$scriptParameterHashRef}{svGenmodModelsFamilyType}." ";  #Family type
	    
	    if (defined(${$scriptParameterHashRef}{rankModelFile})) {
		
		print $XARGSFILEHANDLE "--score_config ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{svRankModelFile})." ";  #Rank model config.ini file 
	    }
	    
	    print $XARGSFILEHANDLE "-o ".catfile(dirname(devnull()), "stdout")." ";  #OutFile
	    print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef."_models_score.stderr.txt ";  #Redirect xargs output to program specific stderr file
	    print $XARGSFILEHANDLE "- ";  #InStream
	    print $XARGSFILEHANDLE "| ";  #Pipe
	    
	    ##Genmod Compound
	    print $XARGSFILEHANDLE "genmod ";
	    print $XARGSFILEHANDLE "-v ";  #Increase output verbosity
	    print $XARGSFILEHANDLE "compound ";  #Adjust score for compound variants in a vcf file
	    print $XARGSFILEHANDLE "--temp_dir ".$$tempDirectoryRef." ";  #Temporary directory

	    if (${$scriptParameterHashRef}{pSVVariantEffectPredictor} > 0) {  #Use VEP annotations in compound models
		
		print $XARGSFILEHANDLE "--vep "; 
	    }
	    
	    print $XARGSFILEHANDLE "-o ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.$vcfParserAnalysisType."_models_score_compound.vcf")." ";  #OutFile
	    print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef."_models_score_compound.stderr.txt ";  #Redirect xargs output to program specific stderr file
	    say $XARGSFILEHANDLE "- ";  #InStream
	}
	
	## Writes sbatch code to supplied filehandle to concatenate variants in vcf format. Each array element is combined with the infilePre and Postfix.
	&ConcatenateVariants({scriptParameterHashRef => $scriptParameterHashRef,
			      FILEHANDLE => $FILEHANDLE,
			      arrayRef => $vcfParserContigsArrayRef,
			      infilePrefix => catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_"), 
			      infilePostfix => $vcfParserAnalysisType."_models_score_compound.vcf",
			      outfile => catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_combined".$vcfParserAnalysisType.".vcf"),
			     });

	## Genmod sort
	print $FILEHANDLE "genmod ";
	print $FILEHANDLE "-v ";  #Increase output verbosity
	print $FILEHANDLE "sort ";  #Sort a VCF file based on rank score
	print $FILEHANDLE "--temp_dir ".$$tempDirectoryRef." ";  #Temporary directory
	print $FILEHANDLE "-o ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf")." ";  #Outfile
	say $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_combined".$vcfParserAnalysisType.".vcf")." ";  #infile
	
	if (${$scriptParameterHashRef}{analysisType} eq "exomes") {
	    
	    ## Enable trap for signal(s) and function
	    &EnableTrap({FILEHANDLE => $FILEHANDLE,
			});
	}
	
	## Copies file from temporary directory.
	say $FILEHANDLE "## Copy file from temporary directory";
	&MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf"),
			      filePath => $outFamilyDirectory,
			      FILEHANDLE => $FILEHANDLE,
			     });
	say $FILEHANDLE "wait", "\n";

	if (${$scriptParameterHashRef}{svRankVariantBCFFile} == 1) {
	
	    ## Using GATK combined file directly yields error in bcftools - unclear why 
	    say $FILEHANDLE "\n## Preprocessing for compatibility with bcfTools v1.3\n";

	    print $FILEHANDLE "bcftools view ";
	    print $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf")." ";
	    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType."_tmp.vcf"), "\n";  #Outfile

	    &JavaCore({FILEHANDLE => $FILEHANDLE,
		       memoryAllocation => "Xmx12g",
		       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		       javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
		       javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
		      });
	    print $FILEHANDLE "SortVcf ";
	    print $FILEHANDLE "I=".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType."_tmp.vcf")." ";
	    say $FILEHANDLE "O=".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType."_sorted.vcf"), "\n";

	    &VcfToBcf({infile => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType."_sorted"),
		       FILEHANDLE => $FILEHANDLE,
		       outfile => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType),

		      });

	    ## Copies file from temporary directory.
	    say $FILEHANDLE "## Copy file from temporary directory";
	    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".bcf*"),
				  filePath => $outFamilyDirectory,
				  FILEHANDLE => $FILEHANDLE,
				 });
	    say $FILEHANDLE "wait", "\n";
	}

	if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	    if ($vcfParserOutputFileCounter == 1) {
		
		${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{SVVCFFile}{Clinical}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf");
		${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{SVRankVariants}{Clinical}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf");   #Save clinical candidate list path

		if (${$scriptParameterHashRef}{svRankVariantBCFFile} == 1) {

		    ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{SVBCFFile}{Clinical}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".bcf");
		}
	    }
	    else {
		
		${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{SVVCFFile}{Research}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf");
		${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{SVRankVariants}{Research}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf");   #Save research candidate list path

		if (${$scriptParameterHashRef}{svRankVariantBCFFile} == 1) {

		    ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{SVBCFFile}{Research}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".bcf");
		}
	    }
	}
    }
    close($FILEHANDLE);   
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	if (defined(${$scriptParameterHashRef}{svRankModelFile})) {  #Add to SampleInfo
			    
	    if (${$scriptParameterHashRef}{svRankModelFile}=~/v(\d+\.\d+.\d+|\d+\.\d+)/) {
				
		${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{SVRankVariants}{RankModel}{Version} = $1;
	    }
	    ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{SVRankVariants}{RankModel}{File} = ${$scriptParameterHashRef}{svRankModelFile};
	    ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{SVRankVariants}{RankModel}{Path} = catfile($$referencesDirRef, ${$scriptParameterHashRef}{svRankModelFile});

	}
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => ${$scriptParameterHashRef}{familyID},
		       programName => "SVGenmod",
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf",
		       outDataType => "static"
		      });
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub SVVCFParser {
 
##SVVCFParser
    
##Function : SVVCFParser performs parsing of VariantEffectPredictor annotated variants
##Returns  : "|$xargsFileCounter"
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $callType, $programName, $fileName, $programInfoPath, $FILEHANDLE, $xargsFileCounter
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $callType                   => The variant call type
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
##         : $fileName                   => File name
##         : $FILEHANDLE                 => Sbatch filehandle to write to
##         : $xargsFileCounter           => The xargs file counter

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "SV";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $programName = ${$argHashRef}{programName};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 20;
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script
 
	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle

	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header    
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$familyIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
							       callType => $callType,
							       tempDirectory => $$tempDirectoryRef,
							      });
    }

    ## Assign directories
    my $inFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    ${$parameterHashRef}{"p".$programName}{inDirectory} = $outFamilyDirectory;  #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{pSVVariantEffectPredictor}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{"p".$programName}{fileTag};

    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
    ($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
								    XARGSFILEHANDLE => $XARGSFILEHANDLE,
								    arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
								    fileName =>$fileName,
								    programInfoPath => $programInfoPath,
								    nrCores => $nrCores,
								    xargsFileCounter => $xargsFileCounter,
								    infile => $$familyIDRef.$infileTag.$callType,
								    inDirectory => $inFamilyDirectory,
								    tempDirectory => $$tempDirectoryRef,
								   });
    ## VCFParser
    say $FILEHANDLE "## VCFParser";

    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "perl",
							});

    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {

	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];

	print $XARGSFILEHANDLE catfile(${$scriptParameterHashRef}{inScriptDir}, "vcfParser.pl")." ";  #Parses the VEP output to tab-sep format
	print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_".$$contigRef.".vcf")." ";  #Infile
	
	if (${$scriptParameterHashRef}{pSVVariantEffectPredictor} > 0) {
	    
	    print $XARGSFILEHANDLE "--parseVEP ".${$scriptParameterHashRef}{svVcfParserVepTranscripts}." ";  #Parse VEP transcript specific entries
	}
	if ($$contigRef =~ /MT|M/) {
	    
	    print $XARGSFILEHANDLE "--padding 10 ";  #Special case for mitochondrial contig annotation
	}
	if (${$scriptParameterHashRef}{svVcfParserRangeFeatureFile} ne "noUserInfo") {
	    
	    print $XARGSFILEHANDLE "-rf ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{svVcfParserRangeFeatureFile})." ";  #List of genes to analyse separately	
	    
	    if (@{${$scriptParameterHashRef}{svVcfParserRangeFeatureAnnotationColumns}}) {
		
		print $XARGSFILEHANDLE "-rf_ac ";  #Range annotation columns
		print $XARGSFILEHANDLE join(',', @{${$scriptParameterHashRef}{svVcfParserRangeFeatureAnnotationColumns}})." ";	    
	    }
	}
	if (${$scriptParameterHashRef}{svVcfParserSelectFile} ne "noUserInfo") {
	 
	    if (! &CheckEntryHashofArray({hashRef => $fileInfoHashRef,
					  key => "SelectFileContigs",
					  element => $$contigRef,
					 })
		) {

		print $XARGSFILEHANDLE "-sf ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{svVcfParserSelectFile})." ";  #List of genes to analyse separately
		print $XARGSFILEHANDLE "-sf_mc ".${$scriptParameterHashRef}{svVcfParserSelectFileMatchingColumn}." ";  #Column of HGNC Symbol in SelectFile (-sf)
		
		if (@{${$scriptParameterHashRef}{svVcfParserSelectFeatureAnnotationColumns}}) {
		    
		    print $XARGSFILEHANDLE "-sf_ac ";  #Select annotation columns
		    print $XARGSFILEHANDLE join(',', @{${$scriptParameterHashRef}{svVcfParserSelectFeatureAnnotationColumns}})." ";	    
		}
		print $XARGSFILEHANDLE "-sof ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.".selected.vcf")." ";
	    }
	}
	print $XARGSFILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.".vcf")." ";  #outfile
	say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
    }

    ## QC Data File(s)
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".${$fileInfoHashRef}{contigsSizeOrdered}[0].".vcf"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	## Clear old VCFParser entry if present
	if (defined(${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$programName})) {
	    
	    delete(${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$programName});
	}
	if (${$scriptParameterHashRef}{svVcfParserRangeFeatureFile} ne "noUserInfo") {

	    ## Collect databases(s) from a potentially merged selectFile and adds them to sampleInfo
	    &CollectSubDatabases({sampleInfoHashRef => $sampleInfoHashRef,
				  familyIDRef => $familyIDRef,
				  programNameRef => \$programName,
				  databaseFile => catfile($$referencesDirRef, ${$scriptParameterHashRef}{svVcfParserRangeFeatureFile}),
				  databaseKey => "RangeFile",
				 });

	    if (${$scriptParameterHashRef}{svVcfParserRangeFeatureFile}=~/v(\d+\.\d+.\d+|\d+\.\d+)/) {
		
		${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$programName}{RangeFile}{Version} = $1;
	    }
	    ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$programName}{RangeFile}{Path} = catfile($$referencesDirRef, ${$scriptParameterHashRef}{svVcfParserRangeFeatureFile});
	}
	if (${$scriptParameterHashRef}{svVcfParserSelectFile} ne "noUserInfo") {

	    ## Collect databases(s) from a potentially merged selectFile and adds them to sampleInfo
	    &CollectSubDatabases({sampleInfoHashRef => $sampleInfoHashRef,
				  familyIDRef => $familyIDRef,
				  programNameRef => \$programName,
				  databaseFile => catfile($$referencesDirRef, ${$scriptParameterHashRef}{svVcfParserSelectFile}),
				  databaseKey => "SelectFile",
				 });

	    if (${$scriptParameterHashRef}{svVcfParserSelectFile}=~/v(\d+\.\d+.\d+|\d+\.\d+)/) {
		
		${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$programName}{SelectFile}{Version} = $1;
	    }
	    ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$programName}{SelectFile}{Path} = catfile($$referencesDirRef, ${$scriptParameterHashRef}{svVcfParserSelectFile});
	}

	## Collect QC metadata info for later use
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       programName => $programName,
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.$outfileTag.$callType."_".${$fileInfoHashRef}{contigsSizeOrdered}[0].".vcf",
		       outDataType => "static"
		      });
    }

    close($XARGSFILEHANDLE);
    
    my $vcfParserAnalysisType = "";
    my @vcfParserContigsRef = \@{ ${$fileInfoHashRef}{contigsSizeOrdered} };
    
    for (my $vcfParserOutputFileCounter=0;$vcfParserOutputFileCounter<${$scriptParameterHashRef}{VcfParserOutputFileCount};$vcfParserOutputFileCounter++) {
	    
	if ($vcfParserOutputFileCounter == 1) {
	    
	    $vcfParserAnalysisType = ".selected";  #SelectFile variants
	    @vcfParserContigsRef = \@{${$fileInfoHashRef}{SelectFileContigs}};
	}
	
	## Copies file from temporary directory.
	say $FILEHANDLE "## Copy file(s) from temporary directory";
	($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									XARGSFILEHANDLE => $XARGSFILEHANDLE,
									arrayRef => @vcfParserContigsRef,
									fileName =>$fileName,
									programInfoPath => $programInfoPath,
									nrCores => $nrCores,
									xargsFileCounter => $xargsFileCounter,
									outfile => $$familyIDRef.$outfileTag.$callType,
									fileEnding => $vcfParserAnalysisType.".vcf*",
									outDirectory => $outFamilyDirectory,
									tempDirectory => $$tempDirectoryRef,
								       });
	
	## Adds the most complete vcf file to sampleInfo
	&AddMostCompleteVCF({scriptParameterHashRef => $scriptParameterHashRef,
			     sampleInfoHashRef => $sampleInfoHashRef,
			     programName => $programName,
			     path => catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.$vcfParserAnalysisType.".vcf"),
			     vcfParserOutputFileCounter => $vcfParserOutputFileCounter,
			    });
    }
    close($FILEHANDLE);
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub SVVariantEffectPredictor {
    
##SVVariantEffectPredictor
    
##Function : SV VariantEffectPredictor performs annotation of SV variants.
##Returns  : "|$xargsFileCounter"
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $callType, $programName, $programInfoPath, $fileName, $FILEHANDLE, $xargsFileCounter
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $callType                   => The variant call type
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
##         : $fileName                   => File name
##         : $FILEHANDLE                 => Sbatch filehandle to write to
##         : $xargsFileCounter           => The xargs file counter
##         : $stderrPath                 => The stderr path of the block script

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "SV";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;    

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $stderrPath = ${$argHashRef}{stderrPath};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 20;
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script

	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    }

    my $nrForkes = 4;  #VariantEffectPredictor forks

    ## Set the number of cores to allocate per sbatch job.
    my $nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
				       nrCores => scalar(@{${$fileInfoHashRef}{contigs}})
				      });  #Detect the number of cores to use
    $nrCores = floor($nrCores / $nrForkes);  #Adjust for the number of forks 

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    ($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							   jobIDHashRef => $jobIDHashRef,
							   FILEHANDLE => $FILEHANDLE,
							   directoryID => $$familyIDRef,
							   programName => $programName,
							   programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
							   callType => $callType,
							   nrofCores => ${$scriptParameterHashRef}{maximumCores},
							   processTime => 10,
							   tempDirectory => $$tempDirectoryRef
							  });
    $stderrPath = $programInfoPath.".stderr.txt";

    my ($volume, $directories, $stderrFile) = File::Spec->splitpath($stderrPath);  #Split to enable submission to &SampleInfoQC later

    ## Assign directories
    my $inFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    ${$parameterHashRef}{"p".$programName}{inDirectory} = $outFamilyDirectory;  #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{pSVCombineVariantCallSets}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{"p".$programName}{fileTag};

    my $coreCounter = 1;

    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
			path => catfile($inFamilyDirectory, $$familyIDRef.$infileTag.$callType.".vcf*"),
			tempDirectory => $$tempDirectoryRef
		       });
    say $FILEHANDLE "wait", "\n";

    ## Fix SV with no length as these will fail in the annotation with VEP
    my $perlFixSVNoLengths = q?perl -nae 'my %info; my $start; my $end; my $alt; my @data; ?;  #Set up variables
    $perlFixSVNoLengths .= q?@data=split("\t", $_); ?;  #Split line
    $perlFixSVNoLengths .= q?$start = $data[1]; $start++; ?;  #Add $start position 
    $perlFixSVNoLengths .= q?$alt=$data[4]; ?;  #Add $alt allele
    $perlFixSVNoLengths .= q?foreach my $bit (split /\;/, $data[7]) { my ($key, $value) = split /\=/, $bit; $info{$key} = $value; } ?;  #Add INFO field to %data using $key->$value
    $perlFixSVNoLengths .= q?if(defined($info{END})) { $end = $info{END}; } ?;  #Add $end position
    $perlFixSVNoLengths .= q?if($alt=~ /\<|\[|\]|\>/) { $alt=~ s/\<|\>//g; $alt=~ s/\:.+//g; if($start >= $end && $alt=~ /del/i) {} else {print $_} } ?;  #If SV, strip SV type entry and check if no length, then do not print variant else print 
    $perlFixSVNoLengths .= q?else {print $_}' ?;  #All other line - print

    print $FILEHANDLE $perlFixSVNoLengths." ";
    print $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType.".vcf")." ";
    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_fixedSVLength.vcf")." ", "\n";

    ## VariantEffectPredictor
    say $FILEHANDLE "## VariantEffectPredictor";

    my $assemblyVersion = ${$fileInfoHashRef}{humanGenomeReferenceSource}.${$fileInfoHashRef}{humanGenomeReferenceVersion};

    ## Alias genome source and version to be compatible with VEP
    &AliasAssemblyVersion({assemblyVersion => \$assemblyVersion
			  });

    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "perl",
							});

    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {

	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];

	print $XARGSFILEHANDLE catfile(${$scriptParameterHashRef}{vepDirectoryPath}, "variant_effect_predictor.pl")." ";  #VEP script
	print $XARGSFILEHANDLE "--assembly ".$assemblyVersion." "; 
	print $XARGSFILEHANDLE "--dir_cache ".${$scriptParameterHashRef}{vepDirectoryCache}." ";  #Specify the cache directory to use
	print $XARGSFILEHANDLE "--cache ";  #Enables use of the cache.

	if (${$scriptParameterHashRef}{vepReference} == 1 ) {  #Use reference file for analysis with vep

	    print $XARGSFILEHANDLE "--fasta ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
	}

	print $XARGSFILEHANDLE "--force_overwrite ";  #force the overwrite of the existing file
	print $XARGSFILEHANDLE "--format vcf ";  #Input is in the VCF format
	print $XARGSFILEHANDLE "--vcf ";  #Writes output in VCF format.
	print $XARGSFILEHANDLE "--no_progress ";  #Do not show progress in stderr
	print $XARGSFILEHANDLE "--fork ".$nrForkes." ";  #Enable forking, using the specified number of forks.
	print $XARGSFILEHANDLE "--buffer_size 100 ";  #Sets the internal buffer size, corresponding to the number of variations that are read in to memory simultaneously 
	print $XARGSFILEHANDLE "--offline ";  #Use installed assembly 
	print $XARGSFILEHANDLE "--chr ".$$contigRef." ";

	##VEPPlugins
	foreach my $plugin (@{${$scriptParameterHashRef}{svVepPlugins}}) {

	    if ($plugin eq "LoF") {

		print $XARGSFILEHANDLE "--plugin ".$plugin.",human_ancestor_fa:".catfile(${$scriptParameterHashRef}{vepDirectoryCache}, "human_ancestor.fa,filter_position:0.05")." ";
	    }
	    elsif ($plugin eq "UpDownDistance") {  #Special case for mitochondrial contig annotation
		
		if ($$contigRef =~ /MT|M/) {

		    print $XARGSFILEHANDLE "--plugin UpDownDistance,10,10 ";
		}
	    }
	    else {

		print $XARGSFILEHANDLE "--plugin ".$plugin." ";
	    }
	}

	##VEPFeatures
	foreach my $vepFeature (@{${$scriptParameterHashRef}{svVepFeatures}}) {

	    print $XARGSFILEHANDLE "--".$vepFeature." ";  #Add VEP features to the output.

	    if ( ($$contigRef =~ /MT|M/) && ($vepFeature eq "refseq") ) {  #Special case for mitochondrial contig annotation

		print $XARGSFILEHANDLE "--all_refseq ";
	    }
	    if ( ($vepFeature eq "sift") || ($vepFeature eq "polyphen") )  {  #Protein predictions
		
		print $XARGSFILEHANDLE "p ";  #Add prediction term 
	    }
	}
	print $XARGSFILEHANDLE "-i ".catfile($$tempDirectoryRef, $$familyIDRef.$infileTag.$callType."_fixedSVLength.vcf")." ";  #InFile (family vcf)
	print $XARGSFILEHANDLE "-o ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.".vcf")." ";  #OutFile
	print $XARGSFILEHANDLE "1> ".$xargsFileName.".".$$contigRef.".stdout.txt ";  #Redirect xargs output to program specific stdout file
	say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
    }

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	## Collect QC metadata info for later use                     	
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       programName => $programName."Summary",
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.$outfileTag.$callType."_".${$fileInfoHashRef}{contigsSizeOrdered}[0].".vcf_summary.html",
		       outDataType => "static"
		      });
	## Collect QC metadata info for later use                     	
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       programName => $programName,
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.$outfileTag.$callType."_".${$fileInfoHashRef}{contigsSizeOrdered}[0].".vcf",
		       outDataType => "static"
		      });
    }

    ## QC Data File(s)
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_*.vcf_s*"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";

    close($XARGSFILEHANDLE);

    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_*.vcf*"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    
    close($FILEHANDLE);

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	## Submitt job
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub SVCombineVariantCallSets { 

##SVCombineVariantCallSets
    
##Function : CombineVariants to combine all structural variants call from different callers.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $callType, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $callType                   => The variant call type
##         : $programName                => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "SV";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] }, #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);
    
    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my @structuralVariantCallers;  #Stores callers that have been executed
    my @parallelChains;  #Stores the parallel chains that jobIds should be inherited from
    
    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header    
    my ($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							      jobIDHashRef => $jobIDHashRef,
							      FILEHANDLE => $FILEHANDLE,
							      directoryID => $$familyIDRef,
							      programName => $programName,
							      programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
							      callType => $callType,
							      processTime => 2,
							      tempDirectory => $$tempDirectoryRef,
							     });
    my ($volume, $directories, $stderrFile) = File::Spec->splitpath($programInfoPath.".stderr.txt");  #Split to enable submission to &SampleInfoQC later

    ## Assign directories
    my $outFamilyDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk");
    ${$parameterHashRef}{"p".$programName}{inDirectory} = $outFamilyDirectory;  #Used downstream

    ## Assign fileTags
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{"p".$programName}{fileTag}; 
    
    ## Collect infiles for all sampleIDs to enable migration to temporary directory
    foreach my $sampleID (@{${$scriptParameterHashRef}{sampleIDs}}) {
	
	## Add merged infile name after merging all BAM files per sampleID
	my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$sampleID}{MergeInfile};  #Alias
	
	foreach my $structuralVariantCaller (@{${$parameterHashRef}{dynamicParameters}{structuralVariantCaller}}) {
	    
	    if ( (${$scriptParameterHashRef}{$structuralVariantCaller} > 0) && ($structuralVariantCaller ne "pManta") ) {  #Expect vcf. Special case: Manta is processed by joint calling and per family
		
		my $programOutDirectoryName = ${$parameterHashRef}{$structuralVariantCaller}{outDirectoryName};
		my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $sampleID, $$alignerOutDirRef, "gatk", $programOutDirectoryName);
		my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$sampleID}{$structuralVariantCaller}{fileTag};
		
		if (! ( any {$_ eq ${$parameterHashRef}{$structuralVariantCaller}{chain}} @parallelChains ) ) { #If element is not part of array

		    push(@parallelChains, ${$parameterHashRef}{$structuralVariantCaller}{chain});
		}
		
		## Copy file(s) to temporary directory
		say $FILEHANDLE "## Copy file(s) to temporary directory"; 
		&MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
				    path => catfile($inSampleDirectory, $infile.$infileTag.".vcf*"),
				    tempDirectory => $$tempDirectoryRef
				   });
		
		say $FILEHANDLE "wait", "\n";
		
		## Compress or decompress original file or stream to outfile (if supplied)
		&Bgzip({FILEHANDLE => $FILEHANDLE,
			infilePath => catfile($$tempDirectoryRef, $infile.$infileTag.".vcf"),
			outfilePath => catfile($$tempDirectoryRef, $infile.$infileTag.".vcf.gz"),
		       });
		print $FILEHANDLE "\n";
		
		## Index file using tabix 
		&Tabix({FILEHANDLE => $FILEHANDLE,
			infilePath => catfile($$tempDirectoryRef, $infile.$infileTag.".vcf.gz"),
		       });
	    }
	}
	say $FILEHANDLE "wait", "\n";
    }

    ## Merge all structural variant caller's vcf files per sampleID
    say $FILEHANDLE "## Merge all structural variant caller's vcf files per sampleID";
    foreach my $structuralVariantCaller (@{${$parameterHashRef}{dynamicParameters}{structuralVariantCaller}}) {
	
	if (${$scriptParameterHashRef}{$structuralVariantCaller} > 0 && ($structuralVariantCaller ne "pManta") ) {  #Expect vcf. Special case: Manta is processed by joint calling and per family
	    
	    print $FILEHANDLE "bcftools merge ";

	    foreach my $sampleID (@{${$scriptParameterHashRef}{sampleIDs}}) {  #Collapse all structural variant calls to one vcf file per variant caller and sampleID
				
		## Add merged infile name after merging all BAM files per sampleID
		my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$sampleID}{MergeInfile};  #Alias
		
		my $programOutDirectoryName = ${$parameterHashRef}{$structuralVariantCaller}{outDirectoryName};   
		my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $sampleID, $$alignerOutDirRef, "gatk", $programOutDirectoryName);
		my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$sampleID}{$structuralVariantCaller}{fileTag};
		
		print $FILEHANDLE catfile($$tempDirectoryRef, $infile.$infileTag.".vcf.gz")." ";  #InFile
	    } 
	    
	    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef."_".$structuralVariantCaller.".vcf"), "\n";  #OutFile

	    ## Compress or decompress original file or stream to outfile (if supplied)
	    &Bgzip({FILEHANDLE => $FILEHANDLE,
		    infilePath => catfile($$tempDirectoryRef, $$familyIDRef."_".$structuralVariantCaller.".vcf"),
		    outfilePath => catfile($$tempDirectoryRef, $$familyIDRef."_".$structuralVariantCaller.".vcf.gz"),
		   });
	    
	    ## Index file using tabix 
	    &Tabix({FILEHANDLE => $FILEHANDLE,
		    infilePath => catfile($$tempDirectoryRef, $$familyIDRef."_".$structuralVariantCaller.".vcf.gz"),
		   });
	}
    }

    ## Add joint calling per family callers like MANTA
    foreach my $structuralVariantCaller (@{${$parameterHashRef}{dynamicParameters}{structuralVariantCaller}}) {

	if (${$scriptParameterHashRef}{$structuralVariantCaller} > 0  && ($structuralVariantCaller eq "pManta") ) {  #Expect vcf. Special case: Manta is processed by joint calling and per family
	    
	    my $programOutDirectoryName = ${$parameterHashRef}{$structuralVariantCaller}{outDirectoryName};   
	    my $inFamilyDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, "gatk", $programOutDirectoryName);
	    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$structuralVariantCaller}{fileTag};
	    
	    if (! ( any {$_ eq ${$parameterHashRef}{$structuralVariantCaller}{chain}} @parallelChains ) ) { #If element is not part of array
		
		push(@parallelChains, ${$parameterHashRef}{$structuralVariantCaller}{chain});
	    }
		
	    ## Copy file(s) to temporary directory
	    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
	    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
				path => catfile($inFamilyDirectory, $$familyIDRef.$infileTag."_".$callType.".vcf*"),
				tempDirectory => $$tempDirectoryRef
			       });
	    
	    say $FILEHANDLE "wait", "\n";
	    
	    ## Compress or decompress original file or stream to outfile (if supplied)
	    &Bgzip({FILEHANDLE => $FILEHANDLE,
		    infilePath => catfile($$tempDirectoryRef, $$familyIDRef.$infileTag."_".$callType.".vcf"),
		    outfilePath => catfile($$tempDirectoryRef, $$familyIDRef."_".$structuralVariantCaller.".vcf.gz"),
		   });
	    print $FILEHANDLE "\n";
	    
	    ## Index file using tabix 
	    &Tabix({FILEHANDLE => $FILEHANDLE,
		    infilePath => catfile($$tempDirectoryRef, $$familyIDRef."_".$structuralVariantCaller.".vcf.gz"),
		   });
	}
    }

    ## Concatenate structural variant caller's family vcf files
    say $FILEHANDLE "## Concatenate structural variant caller's family vcf files";
    print $FILEHANDLE "bcftools concat ";
    print $FILEHANDLE "-a ";  #First coordinate of the next file can precede last record of the current file
    
    foreach my $structuralVariantCaller (@{${$parameterHashRef}{dynamicParameters}{structuralVariantCaller}}) {
	
	if (${$scriptParameterHashRef}{$structuralVariantCaller} > 0) {  #Expect vcf
	    
	    print $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef."_".$structuralVariantCaller.".vcf.gz")." "; 
	}
    }
    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef."_".$callType.".vcf"), "\n";

    ## Writes sbatch code to supplied filehandle to sort variants in vcf format
    &SortVcf({scriptParameterHashRef => $scriptParameterHashRef,
	      fileInfoHashRef => $fileInfoHashRef,
	      FILEHANDLE => $FILEHANDLE,
	      sequenceDictFile => catfile($$referencesDirRef, ${$fileInfoHashRef}{humanGenomeReferenceNameNoEnding}.".dict"),
	      infile => catfile($$tempDirectoryRef, $$familyIDRef."_".$callType.".vcf")." ",
	      outfile => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_sorted.vcf")." ",
	     });

    print $FILEHANDLE "\n";

    my $altFileEnding = "";  #Alternative ending
    if (${$scriptParameterHashRef}{svVTDecompose} > 0) {

	$altFileEnding .= "_VT";

	## Split multiallelic variants
	say $FILEHANDLE "## Split multiallelic variants";
	print $FILEHANDLE "vt decompose ";
	print $FILEHANDLE "-s ";
	print $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_sorted.vcf")." ";
	say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$altFileEnding.".vcf"), "\n";
    }
    
    ## Remove FILTER ne PASS
    if (${$scriptParameterHashRef}{svBcfToolsViewFilter} > 0) {
	
	say $FILEHANDLE "## Remove FILTER ne PASS";
	print $FILEHANDLE "bcftools view ";
	print $FILEHANDLE "-f PASS ";
	print $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$altFileEnding.".vcf")." ";

	$altFileEnding .= "_filt";

	say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$altFileEnding.".vcf"), "\n";
    }

    ## Remove common variants
    if (${$scriptParameterHashRef}{svGenmodFilter} > 0) {
	
	say $FILEHANDLE "## Remove common variants";
	print $FILEHANDLE "genmod ";  #Program
	print $FILEHANDLE "-v ";  #Increase output verbosity
	print $FILEHANDLE "annotate ";  #Command
	print $FILEHANDLE "--thousand_g ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{svGenmodFilter1000G})." ";  #1000G reference
	print $FILEHANDLE "-o ".catfile(dirname(devnull()), "stdout")." ";  #OutStream
	print $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$altFileEnding.".vcf")." ";
	print $FILEHANDLE "| ";
	
	$altFileEnding .= "_genmodFilter";  #Update ending
	
	print $FILEHANDLE "genmod ";  #Program
	print $FILEHANDLE "-v ";  #Increase output verbosity
	print $FILEHANDLE "filter ";  #Command
	print $FILEHANDLE "-t ".${$scriptParameterHashRef}{svGenmodFilterThreshold}." ";  #Threshold for filtering variants
	print $FILEHANDLE "- ";  #InStream
	say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$altFileEnding.".vcf"), "\n";  #OutFile
    }

    ## Annotate 1000G structural variants
    if (${$scriptParameterHashRef}{svVCFAnno} > 0) {
	
	say $FILEHANDLE "## Annotate 1000G structural variants";
	print $FILEHANDLE "vcfanno ";  #Program
	print $FILEHANDLE "-lua ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{svVCFAnnoLua})." ";  #Increase output verbosity
	print $FILEHANDLE "-ends ";  #Annotate the start and end as well as the interval itself
	print $FILEHANDLE catfile($$referencesDirRef, ${$scriptParameterHashRef}{svVCFAnnoConfig})." ";  #Config
	print $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$altFileEnding.".vcf")." ";
	print $FILEHANDLE "| ";
	print $FILEHANDLE q?perl -nae 'if($_=~/^#/) {print $_} else {$F[7]=~s/\[||\]//g; print join("\t", @F), "\n"}' ?;  #Remove "[" and "]" from INFO as it breaks vcf format

	$altFileEnding .= "_vcfAnno";  #Update ending

	say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$altFileEnding.".vcf"), "\n";
	
	if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	    &SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
			   familyID => ${$scriptParameterHashRef}{familyID},
			   programName => "SVCombineVariantCallSets",
			   outDirectory => $directories,
			   outfileEnding => $stderrFile,
			   outDataType => "infoDirectory"
			  });
	}

	say $FILEHANDLE "## Add header for 1000G annotation of structural variants";
	print $FILEHANDLE "bcftools annotate ";
	print $FILEHANDLE "--header-lines ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{svVCFAnnotationHeaderLinesFile})." ";
	print $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$altFileEnding.".vcf")." ";

	$altFileEnding .= "_bcfToolsAnnotate";  #Update ending

	say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$altFileEnding.".vcf"), "\n";

    }

    if ($altFileEnding ne "") {  #Then we have something to rename 

	say $FILEHANDLE "## Rename outfile";
	print $FILEHANDLE "mv ";
	print $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.$altFileEnding.".vcf")." ";
	say $FILEHANDLE catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".vcf"), "\n";
    }
    
    if (${$scriptParameterHashRef}{svCombineVariantCallSetsBCFFile} == 1) {
	
	&VcfToBcf({infile => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType),
		   FILEHANDLE => $FILEHANDLE,
		  });
	
	## Copies file from temporary directory.
	say $FILEHANDLE "## Copy file from temporary directory";
	&MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".bcf*"),
			      filePath => $outFamilyDirectory,
			      FILEHANDLE => $FILEHANDLE,
			     });
    }

    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".vcf"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    
    close($FILEHANDLE);   

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{SVVCFFile}{ReadyVcf}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.".vcf");	

	if (${$scriptParameterHashRef}{svCombineVariantCallSetsBCFFile} eq 1) {

	    ${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{SVBCFFile}{Path} = catfile($outFamilyDirectory, $$familyIDRef.$outfileTag.$callType.".bcf");
	}

	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 7, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName,
		       parallelChainsArrayRef => \@parallelChains,
		      });
    }
}

sub CNVnator { 
    
##CNVnator
    
##Function : Call structural variants using CNVnator
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $sampleID, $alignerOutDir, $programName, $programInfoPath
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleID                   => The sampleID
##         : $alignerOutDir              => The alignerOutDir used in the analysis
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
    
    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $programOutDirectoryName = ${$parameterHashRef}{"p".$programName}{outDirectoryName};

    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 30;
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script
 
	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
	
	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$sampleIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), "gatk", lc($programOutDirectoryName)),
							       nrofCores => $nrCores,
							       processTime => $time,
							       tempDirectory => $$tempDirectoryRef
							      });
    }

    ## Assign directories
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk");
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk", $programOutDirectoryName);
    ${$parameterHashRef}{"p".$programName}{$$sampleIDRef}{inDirectory} = $outSampleDirectory; #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{ $$familyIDRef }{$$sampleIDRef}{pGATKBaseRecalibration}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{ $$familyIDRef }{$$sampleIDRef}{"p".$programName}{fileTag};

    my $coreCounter=1;

    ## Add merged infile name after merging all BAM files per sampleID
    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias

    my $rootFile;
    my $phenoTypeInfo = ${$sampleInfoHashRef}{${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{Phenotype}; #Alias
    
    my $perlVcfFix = q&perl -nae 'chomp($_); if($_=~/^##/) {print $_, "\n"} elsif($_=~/^#CHROM/) {print q?##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">?, "\n"; print $_."\t".FORMAT."\t&.$$sampleIDRef.q&", "\n"} else {print $_."\tGT\t&;
    if ($phenoTypeInfo eq 2) {  #Affected
	
	$perlVcfFix .= q&1/1"&;
    }
    if ($phenoTypeInfo ne 2) {  #Unaffected
	
	$perlVcfFix .= q&0/1"&;
    }
    $perlVcfFix .= q&, "\n"}' &;
    
    my $perlAddContigs = q?perl -nae '{print "##contig=<ID=".$F[0].",length=".$F[1].">", "\n"}'?;
    
    ## Add contigs to vcfheader
    print $FILEHANDLE $perlAddContigs." ";
    print $FILEHANDLE catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference}).".fai "; #Reference fai file
    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, "contigHeader.txt")." ";

    ## Create by CNVnator required "chr.fa" files
    say $FILEHANDLE "## Create by CNVnator required 'chr.fa' files";
    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigs}});$contigsCounter++) {

	my $contigRef = \${$fileInfoHashRef}{contigs}[$contigsCounter];

	&PrintWait({counterRef => \$contigsCounter,
		    nrCoresRef => \$nrCores,
		    coreCounterRef => \$coreCounter,
		    FILEHANDLE => $FILEHANDLE,
		   });

	print $FILEHANDLE "samtools faidx ";
	print $FILEHANDLE catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";
	print $FILEHANDLE $$contigRef." ";
	say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$contigRef.".fa")." &";
    }
    say $FILEHANDLE "wait", "\n";
    
    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory";
    ($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
								    XARGSFILEHANDLE => $XARGSFILEHANDLE,
								    arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
								    fileName =>$fileName,
								    programInfoPath => $programInfoPath,
								    nrCores => $nrCores,
								    xargsFileCounter => $xargsFileCounter,
								    infile => $infile.$infileTag,
								    inDirectory => $inSampleDirectory,
								    fileEnding => ".b*",
								    tempDirectory => $$tempDirectoryRef,
								   });
    
    ## CNVnator
    say $FILEHANDLE "## CNVnator";
    
    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "cnvnator",
							});
    
    ## Process per contig
    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {
	
	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];
	
	print $XARGSFILEHANDLE "-chrom ".$$contigRef." ";  #chromosome name
	print $XARGSFILEHANDLE "-unique ";  #To have correct q0 field for CNV calls
	
	$rootFile = catfile($$tempDirectoryRef, $infile.$infileTag."_".$$contigRef.".root");  #Output ROOT file
	
	print $XARGSFILEHANDLE "-root ".$rootFile." ";  
	print $XARGSFILEHANDLE "-tree ".catfile($$tempDirectoryRef, $infile.$infileTag."_".$$contigRef.".bam")." ";  #InFile
	print $XARGSFILEHANDLE "1> ".$xargsFileName.".".$$contigRef.".stdout.txt ";  #Redirect xargs output to program specific stdout file
	print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	print $XARGSFILEHANDLE "; ";
	
	&CNVnatorHis({rootFile => $rootFile,
		      contigRef => $contigRef,
		      cnvBinSizeRef => \${$scriptParameterHashRef}{cnvBinSize},
		      chromosomeReference => catfile($$tempDirectoryRef, $$contigRef.".fa"),
		      FILEHANDLE => $XARGSFILEHANDLE,
		      stdoutfile => $xargsFileName.".".$$contigRef.".stdout.txt",
		      stderrFile => $xargsFileName.".".$$contigRef.".stderr.txt",
		     });
	&CNVnatorStat({rootFile => $rootFile,
		       contigRef => $contigRef,
		       cnvBinSizeRef => \${$scriptParameterHashRef}{cnvBinSize},
		       FILEHANDLE => $XARGSFILEHANDLE,
		       stdoutfile => $xargsFileName.".".$$contigRef.".stdout.txt",
		       stderrFile => $xargsFileName.".".$$contigRef.".stderr.txt",
		      });
	&CNVnatorPartition({rootFile => $rootFile,
			    contigRef => $contigRef,
			    cnvBinSizeRef => \${$scriptParameterHashRef}{cnvBinSize},
			    FILEHANDLE => $XARGSFILEHANDLE,
			    stdoutfile => $xargsFileName.".".$$contigRef.".stdout.txt",
			    stderrFile => $xargsFileName.".".$$contigRef.".stderr.txt",
			   });
	&CNVnatorCalling({rootFile => $rootFile,
			  contigRef => $contigRef,
			  cnvBinSizeRef => \${$scriptParameterHashRef}{cnvBinSize},
			  chromosomeReference => $$referencesDirRef,
			  FILEHANDLE => $XARGSFILEHANDLE,
			  stderrFile => $xargsFileName.".".$$contigRef.".stderr.txt",
			  outfile => catfile($$tempDirectoryRef, $infile.$outfileTag."_".$$contigRef.".vcf"), #OutFile
			 });
	print $XARGSFILEHANDLE "\n";
    }
    
    ## Writes sbatch code to supplied filehandle to concatenate variants in vcf format. Each array element is combined with the infilePre and Postfix.
    &ConcatenateVariants({scriptParameterHashRef => $scriptParameterHashRef,
			  FILEHANDLE => $FILEHANDLE,
			  arrayRef => \@{${$fileInfoHashRef}{contigs}},
			  infilePrefix => catfile($$tempDirectoryRef, $infile.$outfileTag."_"), 
			  infilePostfix => ".vcf",
			  outfile => catfile($$tempDirectoryRef, $infile.$outfileTag."_concat.vcf"),
			 });
    
    ## Fix GT FORMAT in header and SampleID and GT and Genotype call
    print $FILEHANDLE $perlVcfFix." ";
    print $FILEHANDLE catfile($$tempDirectoryRef, $infile.$outfileTag."_concat.vcf")." ";
    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $infile.$outfileTag."_concat_fix.vcf")." ";
    
    ##Add contigs to header
    print $FILEHANDLE "bcftools annotate ";
    print $FILEHANDLE "-h ".catfile($$tempDirectoryRef, "contigHeader.txt")." ";
    print $FILEHANDLE catfile($$tempDirectoryRef, $infile.$outfileTag."_concat_fix.vcf")." ";
    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $infile.$outfileTag.".vcf")." ";
    
    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $infile.$outfileTag.".vcf*"),
			  filePath => $outSampleDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";   
  
    close($FILEHANDLE);     

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       programName => "CNVnator",
		       outDirectory => $outSampleDirectory,
		       outfileEnding => $infile.$outfileTag.".vcf",
		       outDataType => "static"
		      });	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       sampleID => $$sampleIDRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName,
		      });
    }
}


sub Delly { 
    
##Delly
    
##Function : Call structural variants using Delly
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $sampleID, $alignerOutDir, $programName, $programInfoPath
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleID                   => The sampleID
##         : $alignerOutDir              => The alignerOutDir used in the analysis
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
    
    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $programOutDirectoryName = ${$parameterHashRef}{"p".$programName}{outDirectoryName};

    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 30;
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script
 
	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
	
	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$sampleIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), "gatk", lc($programOutDirectoryName)),
							       nrofCores => $nrCores,
							       processTime => $time,
							       tempDirectory => $$tempDirectoryRef
							      });
    }

    ## Assign directories
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk");
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk", $programOutDirectoryName);
    ${$parameterHashRef}{"p".$programName}{$$sampleIDRef}{inDirectory} = $outSampleDirectory; #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{ $$familyIDRef }{$$sampleIDRef}{pGATKBaseRecalibration}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{ $$familyIDRef }{$$sampleIDRef}{"p".$programName}{fileTag};

    ## Removes an element from array and return new array while leaving orginal arrayRef untouched
    my @contigs = &RemoveElementFromArray({arrayRef => \@{${$fileInfoHashRef}{contigsSizeOrdered}},
					   element => "MT",
					   contigSwitch => "yes",
					  });
    
    ## Add merged infile name after merging all BAM files per sampleID
    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias
    
    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory";
    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
			path => catfile($inSampleDirectory, $infile.$infileTag.".b*"),
			tempDirectory => ${$scriptParameterHashRef}{tempDirectory}
		       });
    say $FILEHANDLE "wait", "\n";
    
    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory";
    ($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
								    XARGSFILEHANDLE => $XARGSFILEHANDLE,
								    arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
								    fileName =>$fileName,
								    programInfoPath => $programInfoPath,
								    nrCores => $nrCores,
								    xargsFileCounter => $xargsFileCounter,
								    infile => $infile.$infileTag,
								    inDirectory => $inSampleDirectory,
								    fileEnding => ".b*",
								    tempDirectory => $$tempDirectoryRef,
								   });
    
    ## Delly
    say $FILEHANDLE "## Delly";
    
    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "delly",
							});
    
    foreach my $svType (@{${$scriptParameterHashRef}{dellyType}}) {  #Sacrifice inter translocations due to performance
	
	if($svType ne "TRA") {
	    
	    ## Process per contig
	    foreach my $contig (@contigs) {
		
		print $XARGSFILEHANDLE "-t ".$svType." ";  #The SV to call
		print $XARGSFILEHANDLE "-o ".catfile($$tempDirectoryRef, $infile.$outfileTag."_".$contig."_".$svType.".vcf")." ";
		print $XARGSFILEHANDLE "-x human.hg19.excl.tsv ";  #to exclude telomere and centromere regions
		print $XARGSFILEHANDLE "-g ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." "; #Reference file
		print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $infile.$infileTag."_".$contig.".bam")." ";  #InFile
		print $XARGSFILEHANDLE "1> ".$xargsFileName.".".$contig.".".$svType.".stdout.txt ";  #Redirect xargs output to program specific stdout file
		say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$contig.".".$svType.".stderr.txt ";  #Redirect xargs output to program specific stderr file	    
	    }
	}
	else {
	    
	    print $XARGSFILEHANDLE "-t ".$svType." ";  #The SV to call
	    print $XARGSFILEHANDLE "-o ".catfile($$tempDirectoryRef, $infile.$outfileTag."_".$svType.".vcf")." ";
	    print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $infile.$infileTag.".bam")." ";  #InFile
	    print $XARGSFILEHANDLE "1> ".$xargsFileName.".".$svType.".stdout.txt ";  #Redirect xargs output to program specific stdout file
	    say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$svType.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	}
    }
    
    ## Concatenate contigs per svType
    foreach my $svType (@{${$scriptParameterHashRef}{dellyType}}) {
	
	if($svType ne "TRA") {
	    
	    ## Writes sbatch code to supplied filehandle to concatenate variants in vcf format. Each array element is combined with the infilePre and Postfix.
	    &ConcatenateVariants({scriptParameterHashRef => $scriptParameterHashRef,
				  FILEHANDLE => $FILEHANDLE,
				  arrayRef => \@contigs,
				  infilePrefix => catfile($$tempDirectoryRef, $infile.$outfileTag."_"), 
				  infilePostfix => "_".$svType.".vcf",
				  outfile => catfile($$tempDirectoryRef, $infile.$outfileTag."_".$svType."_concat.vcf"),
				 });
	}
    }
    
    ## Writes sbatch code to supplied filehandle to concatenate variants in vcf format. Each array element is combined with the infilePre and Postfix.
    &ConcatenateVariants({scriptParameterHashRef => $scriptParameterHashRef,
			  FILEHANDLE => $FILEHANDLE,
			  arrayRef => \@{${$scriptParameterHashRef}{dellyType}},
			  infilePrefix => catfile($$tempDirectoryRef, $infile.$outfileTag."_"), 
			  infilePostfix => "_concat.vcf",
			  outfile => catfile($$tempDirectoryRef, $infile.$outfileTag."_concat.vcf"),
			 });
    
    ## Writes sbatch code to supplied filehandle to sort variants in vcf format
    &SortVcf({scriptParameterHashRef => $scriptParameterHashRef,
	      fileInfoHashRef => $fileInfoHashRef,
	      FILEHANDLE => $FILEHANDLE,
	      sequenceDictFile => catfile($$referencesDirRef, ${$fileInfoHashRef}{humanGenomeReferenceNameNoEnding}.".dict"),
	      infile => catfile($$tempDirectoryRef, $infile.$outfileTag."_concat.vcf"),
	      outfile => catfile($$tempDirectoryRef, $infile.$outfileTag."_concat_sorted.vcf"),
	     });
    
    ## Rename vcf samples. The samples array will replace the sample names in the same order as supplied.
    &RenameVCFSamples({sampleIDArrayRef => [$$sampleIDRef],
		       tempDirectoryRef => $tempDirectoryRef,
		       infile => catfile($$tempDirectoryRef, $infile.$outfileTag."_concat_sorted.vcf"),
		       outfile => catfile($$tempDirectoryRef, $infile.$outfileTag.".vcf"),
		       FILEHANDLE => $FILEHANDLE,
		      });
    
    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $infile.$outfileTag.".vcf"),
			  filePath => $outSampleDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    
	if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	    &SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
			   familyID => $$familyIDRef,
			   sampleID => $$sampleIDRef,
			   programName => "Delly",
			   infile => $infile,
			   outDirectory => $outSampleDirectory,
			   outfileEnding => $infile.$outfileTag.".vcf",
			   outDataType => "static"
			  });
	}  
    close($FILEHANDLE);     
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       sampleID => $$sampleIDRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName,
		      });
    }
}


sub Manta { 

##Manta
    
##Function : Joint analysis
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDirRef, $callType, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $callType                   => The variant call type
##         : $programName                => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "SV";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] }, #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $time = 30;
    my $programOutDirectoryName = ${$parameterHashRef}{"p".$programName}{outDirectoryName};
    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    
    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header    
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$familyIDRef,
					    programName => $programName,
					    programDirectory => catfile(lc($$alignerOutDirRef), "gatk", lc($programOutDirectoryName)),
					    processTime => $time,
					    nrofCores => $nrCores,
					    tempDirectory => $$tempDirectoryRef,
					   });
    
    ## Assign directories
    my $outFamilyDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, lc($$alignerOutDirRef), "gatk", lc($programOutDirectoryName));
    ${$parameterHashRef}{"p".$programName}{inDirectory} = $outFamilyDirectory;  #Used downstream

    ## Assign fileTags
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{"p".$programName}{fileTag}; 

    my $coreCounter=1;
    ## Collect infiles for all sampleIDs to enable migration to temporary directory
    for (my $sampleIDCounter=0;$sampleIDCounter < scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {
	
	my $sampleID = ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter];  #Alias
	
	&PrintWait({counterRef => \$sampleIDCounter,
		    nrCoresRef => \$nrCores,
		    coreCounterRef => \$coreCounter,
		    FILEHANDLE => $FILEHANDLE,
		   });
	
	## Assign directories
	my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $sampleID, $$alignerOutDirRef, "gatk");

	## Assign fileTags
	my $infileTag = ${$fileInfoHashRef}{ $$familyIDRef }{$sampleID}{pGATKBaseRecalibration}{fileTag};

	## Add merged infile name after merging all BAM files per sampleID
	my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$sampleID}{MergeInfile};  #Alias

	## Copy file(s) to temporary directory
	say $FILEHANDLE "## Copy file(s) to temporary directory";
	&MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
			    path => catfile($inSampleDirectory, $infile.$infileTag.".b*"),
			    tempDirectory => $$tempDirectoryRef,
			   });
    }
    say $FILEHANDLE "wait", "\n";

    ## Manta
    say $FILEHANDLE "## Manta";
    print $FILEHANDLE "configManta.py ";
    
    foreach my $sampleID (@{${$scriptParameterHashRef}{sampleIDs}}) {

	## Assign fileTags
	my $infileTag = ${$fileInfoHashRef}{ $$familyIDRef }{$sampleID}{pGATKBaseRecalibration}{fileTag};

	## Add merged infile name after merging all BAM files per sampleID
	my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$sampleID}{MergeInfile};  #Alias

	print $FILEHANDLE "--bam ".catfile($$tempDirectoryRef, $infile.$infileTag.".bam")." ";  #Infile
    }
    print $FILEHANDLE "--referenceFasta ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file

    if (${$scriptParameterHashRef}{analysisType} ne "genomes") {
	
	print $FILEHANDLE "--exome ";
    }
    say $FILEHANDLE "--runDir ".$$tempDirectoryRef, "\n";
    
    say $FILEHANDLE "## Manta WorkFlow";
    print $FILEHANDLE catfile($$tempDirectoryRef, "runWorkflow.py")." ";
    say $FILEHANDLE "--mode local ", "\n";
    
    print $FILEHANDLE "gzip ";
    print $FILEHANDLE "-d ";
    print $FILEHANDLE "-c ";
    print $FILEHANDLE catfile($$tempDirectoryRef, "results", "variants", "diploidSV.vcf.gz")." ";
    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag."_".$callType.".vcf"), "\n";
    
    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag."_".$callType.".vcf*"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       programName => "Manta",
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.$outfileTag."_".$callType.".vcf",
		       outDataType => "static"
		      });
    }
    close($FILEHANDLE);     

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName,
		      });
    }
}


sub FindTranslocations { 
    
##FindTranslocations
    
##Function : Call structural variants using FindTranslocations
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $sampleID, $alignerOutDir, $programName, $programInfoPath
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleID                   => The sampleID
##         : $alignerOutDir              => The alignerOutDir used in the analysis
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
    
    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $nrCores = 2;
    my $programOutDirectoryName = ${$parameterHashRef}{"p".$programName}{outDirectoryName};

    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 30;
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script
 
	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
	
	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$sampleIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), "gatk", lc($programOutDirectoryName)),
							       nrofCores => $nrCores,
							       processTime => $time,
							       tempDirectory => $$tempDirectoryRef
							      });
    }

    ## Assign directories
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk");
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk", $programOutDirectoryName);
    ${$parameterHashRef}{"p".$programName}{$$sampleIDRef}{inDirectory} = $outSampleDirectory; #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{ $$familyIDRef }{$$sampleIDRef}{pGATKBaseRecalibration}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{ $$familyIDRef }{$$sampleIDRef}{"p".$programName}{fileTag};

    my $coreCounter=1;

    ## Add merged infile name after merging all BAM files per sampleID
    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias

    my @findTranslocationsTypes = ("intra", "inter");
    my $perlVcfFix = q&perl -nae 'chomp($_); if($_=~/^##/) {print $_, "\n"} elsif($_=~/^#CHROM/) {print q?##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">?, "\n"; print $_."\t".FORMAT."\t&.$$sampleIDRef.q&", "\n"} else {print $_."\tGT\t1/1", "\n"}' &;
    my $perlAddContigs = q?perl -nae '{print "##contig=<ID=".$F[0].",length=".$F[1].">", "\n"}'?;

    ## Add contigs to vcfheader
    print $FILEHANDLE $perlAddContigs." ";
    print $FILEHANDLE catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference}).".fai "; #Reference fai file
    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, "contigHeader.txt")." ";

    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory";
    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
			path => catfile($inSampleDirectory, $infile.$infileTag.".b*"),
			tempDirectory => ${$scriptParameterHashRef}{tempDirectory}
		       });
    say $FILEHANDLE "wait", "\n";
    
    ## FindTranslocations
    say $FILEHANDLE "## FindTranslocations";
    print $FILEHANDLE "FindTranslocations ";
    print $FILEHANDLE "--sv ";
    print $FILEHANDLE "--auto ";
    print $FILEHANDLE "--bam ".catfile($$tempDirectoryRef, $infile.$infileTag.".bam")." ";  #Infile
    print $FILEHANDLE "--bai ".catfile($$tempDirectoryRef, $infile.$infileTag.".bai")." ";  #Infile index
    print $FILEHANDLE "--minimum-supporting-pairs ".${$scriptParameterHashRef}{findTranslocationsMinimumSuppotingPairs}." ";
    say $FILEHANDLE "--output ".catfile($$tempDirectoryRef, $infile.$outfileTag)." ";
    
    foreach my $svType (@findTranslocationsTypes) {
	
	## Fix GT FORMAT in header and SampleID and GT and Genotype call
	print $FILEHANDLE $perlVcfFix." ";
	print $FILEHANDLE catfile($$tempDirectoryRef, $infile.$outfileTag."_".$svType."_chr_events.vcf")." ";
	say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $infile.$outfileTag."_".$svType."_glfixed.vcf")." ";
	
	##Add contigs to header
	print $FILEHANDLE "bcftools annotate ";
	print $FILEHANDLE "-h ".catfile($$tempDirectoryRef, "contigHeader.txt")." ";
	print $FILEHANDLE catfile($$tempDirectoryRef, $infile.$outfileTag."_".$svType."_glfixed.vcf")." ";
	say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $infile.$outfileTag."_".$svType."_glfixed_contigHeader.vcf")." ";
    }

    ## Writes sbatch code to supplied filehandle to concatenate variants in vcf format. Each array element is combined with the infilePre and Postfix.
    &ConcatenateVariants({scriptParameterHashRef => $scriptParameterHashRef,
			  FILEHANDLE => $FILEHANDLE,
			  arrayRef => \@findTranslocationsTypes,
			  infilePrefix => catfile($$tempDirectoryRef, $infile.$outfileTag."_"), 
			  infilePostfix => "_glfixed_contigHeader.vcf",
			  outfile => catfile($$tempDirectoryRef, $infile.$outfileTag."_glfixed_contigHeader_concat.vcf"),
			 });
    
    ## Writes sbatch code to supplied filehandle to sort variants in vcf format
    &SortVcf({scriptParameterHashRef => $scriptParameterHashRef,
	      fileInfoHashRef => $fileInfoHashRef,
	      FILEHANDLE => $FILEHANDLE,
	      sequenceDictFile => catfile($$referencesDirRef, ${$fileInfoHashRef}{humanGenomeReferenceNameNoEnding}.".dict"),
	      infile => catfile($$tempDirectoryRef, $infile.$outfileTag."_glfixed_contigHeader_concat.vcf"),
	      outfile => catfile($$tempDirectoryRef, $infile.$outfileTag.".vcf")." ",
	     });
    
    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $infile.$outfileTag.".vcf*"),
			  filePath => $outSampleDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    close($FILEHANDLE);     
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       programName => "FindTranslocations",
		       outDirectory => $outSampleDirectory,
		       outfileEnding => $infile.$outfileTag.".vcf",
		       outDataType => "static"
		      });	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       sampleID => $$sampleIDRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName,
		      });
    }
}


sub SamToolsMpileUp { 
    
##SamToolsMpileUp
    
##Function : SamToolsMpileUp
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $sampleID, $alignerOutDir, $callType, $programName, $programInfoPath
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleID                   => The sampleID
##         : $alignerOutDir              => The alignerOutDir used in the analysis
##         : $callType                   => The variant call type
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
    
    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $programOutDirectoryName = ${$parameterHashRef}{"p".$programName}{outDirectoryName};

    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 30;
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script
 
	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
	
	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$familyIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), $programOutDirectoryName),
							       nrofCores => $nrCores,
							       processTime => $time,
							       tempDirectory => $$tempDirectoryRef
							      });
    }

    $nrCores = floor(${$scriptParameterHashRef}{nodeRamMemory} / 4);  #Division by X according to the java heap
    $nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
				    nrCores => $nrCores
				   });  #To not exceed maximum

    ## Assign directories
    my $outFamilyFileDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, $programOutDirectoryName);  #For ".fam" file
    my $outFamilyDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, $programOutDirectoryName);
    ${$parameterHashRef}{"p".$programName}{inDirectory} = $outFamilyDirectory;  #Used downstream

    ## Assign fileTags
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{"p".$programName}{fileTag};

    my $coreCounter=1;

    ## Create .fam file to be used in variant calling analyses
    &CreateFamFile({scriptParameterHashRef => $scriptParameterHashRef,
		    FILEHANDLE => $FILEHANDLE,
		    famFilePath => catfile($outFamilyFileDirectory, $$familyIDRef.".fam"),
		    includeHeader => 0,
		   });

    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) { #Collect infiles for all sampleIDs
	
	    my $sampleIDRef = \${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter];  #Alias
	    
	    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk");
	    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{pGATKBaseRecalibration}{fileTag};
	    
	    ## Add merged infile name after merging all BAM files per sampleID
	    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias
	    
	    ## Copy file(s) to temporary directory
	    say $FILEHANDLE "## Copy file(s) to temporary directory";
	    ($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									    XARGSFILEHANDLE => $XARGSFILEHANDLE,
									    arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
									    fileName =>$fileName,
									    programInfoPath => $programInfoPath,
									    nrCores => $nrCores,
									    xargsFileCounter => $xargsFileCounter,
									    infile => $infile.$infileTag,
									    inDirectory => $inSampleDirectory,
									    fileEnding => ".b*",
									    tempDirectory => $$tempDirectoryRef,
									   });
    }

    ## SamTools mpileup
    say $FILEHANDLE "## SamTools mpileup";

    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "samtools",
							});
    
    ## Split per contig
    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {

	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];

	print $XARGSFILEHANDLE "mpileup ";  #Type of analysis to run    
	print $XARGSFILEHANDLE "-g ";  #Generate genotype likelihoods in BCF format
	print $XARGSFILEHANDLE "-C 50 ";  #Adjust mapping quality
	print $XARGSFILEHANDLE "-p ";  #Apply -m and -F per-sample for increased sensitivity
	print $XARGSFILEHANDLE "-t DV,AD "; #Optional tags to output; Allelic depth
	print $XARGSFILEHANDLE "-f ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file

	for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) { #Collect infiles for all sampleIDs

	    my $sampleIDRef = \${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter];  #Alias

	    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{pGATKBaseRecalibration}{fileTag};

	    ## Add merged infile name after merging all BAM files per sampleID
	    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias

	    print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $infile.$infileTag."_".$$contigRef.".bam")." ";  #InFile
	}
	
	print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	print $XARGSFILEHANDLE "| ";  #Pipe
	print $XARGSFILEHANDLE "bcftools "; 
	print $XARGSFILEHANDLE "call ";  #SNP/indel variant calling from VCF/BCF.
	print $XARGSFILEHANDLE "--format-fields GQ ";  #Comma-separated list of FORMAT fields to output for each sample
	print $XARGSFILEHANDLE "-v ";  #Output variant sites only
	print $XARGSFILEHANDLE "-m ";  #Alternative model for multiallelic and rare-variant calling

	if (${$parameterHashRef}{dynamicParameters}{trio}) {

	    print $XARGSFILEHANDLE "--samples-file ".catfile($outFamilyFileDirectory, $$familyIDRef.".fam")." "; 
	    print $XARGSFILEHANDLE "--constrain trio "; 
	}
	print $XARGSFILEHANDLE "2>> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	print $XARGSFILEHANDLE "| ";  #Pipe
	print $XARGSFILEHANDLE "bcftools "; 
	print $XARGSFILEHANDLE "filter ";  #SNP/indel variant calling filtering.
	print $XARGSFILEHANDLE "-sLowQual ";  #Filter on lowQual
	print $XARGSFILEHANDLE "-g3 ";  #Filter SNPs within <int> base pairs of an indel
	print $XARGSFILEHANDLE "-G10 ";  #Filter clusters of indels separated by <int> or fewer base pairs allowing only one to pass
	print $XARGSFILEHANDLE q?-e \'%QUAL<10 || (RPB<0.1 && %QUAL<15) || (AC<2 && %QUAL<15) || %MAX(DV)<=3 || %MAX(DV)/%MAX(DP)<=0.25\' ?;  #exclude sites for which the expression is true
	print $XARGSFILEHANDLE "2>> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file

	if (${$scriptParameterHashRef}{replaceIUPAC} eq 1) {
	    
	    ## Replace the IUPAC code in alternative allels with N for input stream and writes to stream
	    &ReplaceIUPAC({stderrPath => $xargsFileName.".".$$contigRef.".stderr.txt",
			   FILEHANDLE => $XARGSFILEHANDLE
			  });
	}

	print $XARGSFILEHANDLE "| ";  #Pipe
	print $XARGSFILEHANDLE "bcftools "; 
	print $XARGSFILEHANDLE "norm ";  #
	print $XARGSFILEHANDLE "-f ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
	print $XARGSFILEHANDLE "-o ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.".vcf")." "; #OutFile
	say $XARGSFILEHANDLE "2>> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
    }

    ## Writes sbatch code to supplied filehandle to concatenate variants in vcf format. Each array element is combined with the infilePre and Postfix.
    &ConcatenateVariants({scriptParameterHashRef => $scriptParameterHashRef,
			  FILEHANDLE => $FILEHANDLE,
			  arrayRef => \@{${$fileInfoHashRef}{contigs}},
			  infilePrefix => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_"), 
			  infilePostfix => ".vcf",
			  outfile => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".vcf"),
			 });
    
    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".vcf*"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
  
    close($FILEHANDLE);     
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       programName => "Samtools",
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.$outfileTag.$callType.".vcf",
		       outDataType => "static"
		      });
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       programName => "Bcftools",
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.$outfileTag.$callType.".vcf",
		       outDataType => "static"
		      });
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName,
		      });
    }
}

sub Freebayes { 
    
##Freebayes
    
##Function : Call snv/small indels usig Freebayes
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $sampleID, $alignerOutDir, $callType, $programName, $programInfoPath, $FILEHANDLE
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleID                   => The sampleID
##         : $alignerOutDir              => The alignerOutDir used in the analysis
##         : $callType                   => The variant call type
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
##         : $FILEHANDLE                 => Sbatch filehandle to write to
    
    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $programOutDirectoryName = ${$parameterHashRef}{"p".$programName}{outDirectoryName};

    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 30;
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script
 
	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
	
	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$familyIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), $programOutDirectoryName),
							       nrofCores => $nrCores,
							       processTime => $time,
							       tempDirectory => $$tempDirectoryRef
							      });
    }

    $nrCores = floor(${$scriptParameterHashRef}{nodeRamMemory} / 4);  #Division by X according to the java heap
    $nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
				    nrCores => $nrCores,
				   });  #To not exceed maximum

    ## Assign directories
    my $outFamilyFileDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, $programOutDirectoryName);  #For ".fam" file
    my $outFamilyDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, $$alignerOutDirRef, $programOutDirectoryName);
    ${$parameterHashRef}{"p".$programName}{inDirectory} = $outFamilyDirectory;  #Used downstream

    ## Assign fileTags
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{"p".$programName}{fileTag};

    my $coreCounter=1;

    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) { #Collect infiles for all sampleIDs
	
	    my $sampleIDRef = \${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter];  #Alias
	    
	    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk");
	    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{pGATKBaseRecalibration}{fileTag};
	    
	    ## Add merged infile name after merging all BAM files per sampleID
	    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias

	    ## Copy file(s) to temporary directory
	    say $FILEHANDLE "## Copy file(s) to temporary directory";
	    ($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									    XARGSFILEHANDLE => $XARGSFILEHANDLE,
									    arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
									    fileName =>$fileName,
									    programInfoPath => $programInfoPath,
									    nrCores => $nrCores,
									    xargsFileCounter => $xargsFileCounter,
									    infile => $infile.$infileTag,
									    inDirectory => $inSampleDirectory,
									    fileEnding => ".b*",
									    tempDirectory => $$tempDirectoryRef,
									   });
    }

    ## Freebayes
    say $FILEHANDLE "## Freebayes";

    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "freebayes",
							});
    
    ## Split per contig
    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {

	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];

	print $XARGSFILEHANDLE "--standard-filters "; #Equivalent to -m 30 -q 20 -R 0 -S 0
	print $XARGSFILEHANDLE "--genotype-qualities ";  #Calculate the marginal probability of genotypes and report as GQ 
	print $XARGSFILEHANDLE "--fasta-reference ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file

	for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) { #Collect infiles for all sampleIDs

	    my $sampleIDRef = \${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter];  #Alias

	    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{pGATKBaseRecalibration}{fileTag};

	    ## Add merged infile name after merging all BAM files per sampleID
	    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias

	    print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $infile.$infileTag."_".$$contigRef.".bam")." ";  #InFile
	}

	print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	print $XARGSFILEHANDLE "| ";  #Pipe
	print $XARGSFILEHANDLE "bcftools "; 
	print $XARGSFILEHANDLE "filter ";  #SNP/indel variant calling filtering.
	print $XARGSFILEHANDLE "-sLowQual ";  #Filter on lowQual
	print $XARGSFILEHANDLE "-g3 ";  #Filter SNPs within <int> base pairs of an indel
	print $XARGSFILEHANDLE "-G10 ";  #Filter clusters of indels separated by <int> or fewer base pairs allowing only one to pass
	print $XARGSFILEHANDLE q?-e \'%QUAL<10 || (AC<2 && %QUAL<15)\' ?;  #exclude sites for which the expression is true
	print $XARGSFILEHANDLE "2>> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file

	if (${$scriptParameterHashRef}{replaceIUPAC} eq 1) {
	    
	    ## Replace the IUPAC code in alternative allels with N for input stream and writes to stream
	    &ReplaceIUPAC({stderrPath => $xargsFileName.".".$$contigRef.".stderr.txt",
			   FILEHANDLE => $XARGSFILEHANDLE
			  });
	}
	print $XARGSFILEHANDLE "| ";  #Pipe
	print $XARGSFILEHANDLE "bcftools "; 
	print $XARGSFILEHANDLE "norm ";  #
	print $XARGSFILEHANDLE "-f ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
	print $XARGSFILEHANDLE "-o ".catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_".$$contigRef.".vcf")." "; #OutFile
	say $XARGSFILEHANDLE "2>> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
    }

    ## Writes sbatch code to supplied filehandle to concatenate variants in vcf format. Each array element is combined with the infilePre and Postfix.
    &ConcatenateVariants({scriptParameterHashRef => $scriptParameterHashRef,
			  FILEHANDLE => $FILEHANDLE,
			  arrayRef => \@{${$fileInfoHashRef}{contigs}},
			  infilePrefix => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType."_"),
			  infilePostfix => ".vcf",
			  outfile => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".vcf"),
			 });
    
    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $$familyIDRef.$outfileTag.$callType.".vcf*"),
			  filePath => $outFamilyDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
  
    close($FILEHANDLE);     
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       programName => "Freebayes",
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.$outfileTag.$callType.".vcf",
		       outDataType => "static"
		      });
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       programName => "Bcftools",
		       outDirectory => $outFamilyDirectory,
		       outfileEnding => $$familyIDRef.$outfileTag.$callType.".vcf",
		       outDataType => "static"
		      });
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName,
		      });
    }
}


sub GATKHaploTypeCaller { 

##GATKHaploTypeCaller
    
##Function : GATKHaploTypeCaller. 
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $sampleID, $alignerOutDir, $programName, $programInfoPath
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleID                   => The sampleID
##         : $alignerOutDir              => The alignerOutDir used in the analysis
##         : $programName                => The program name
##         : $programInfoPath            => The program info path

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $reduceIORef = \${$scriptParameterHashRef}{reduceIO};

    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 30;
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script
 
	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
	
	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$sampleIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
							       nrofCores => $nrCores,
							       processTime => $time,
							       tempDirectory => $$tempDirectoryRef
							      });
    }

    $nrCores = floor(${$scriptParameterHashRef}{nodeRamMemory} / 4);  #Division by X according to the java heap
    $nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
				    nrCores => $nrCores,
				   });  #To not exceed maximum

    ## Assign directories
    my $outFamilyFileDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef);  #For ".fam" file
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk");
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk");
    ${$parameterHashRef}{"p".$programName}{$$sampleIDRef}{inDirectory} = $outSampleDirectory;  #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{pGATKBaseRecalibration}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{"p".$programName}{fileTag};

    ## Create .fam file to be used in variant calling analyses
    &CreateFamFile({scriptParameterHashRef => $scriptParameterHashRef,
		    FILEHANDLE => $FILEHANDLE,
		    famFilePath => catfile($outFamilyFileDirectory, $$familyIDRef.".fam"),
		   });
    ## Get exomeTargetBed file for specfic sampleID and add fileEnding from fileInfoHash if supplied
    my $exomeTargetBedFile = &GetExomTargetBEDFile({scriptParameterHashRef => $scriptParameterHashRef,
						    sampleIDRef => $sampleIDRef,
						    fileEndingRef => \${$fileInfoHashRef}{exomeTargetBed}[2],
						   });
    if ( (${$scriptParameterHashRef}{analysisType} eq "exomes") || (${$scriptParameterHashRef}{analysisType} eq "rapid") ) { #Exome/rapid analysis
	
	## Generate contig specific interval_list
	&GenerateContigSpecificTargetBedFile({scriptParameterHashRef => $scriptParameterHashRef,
					      fileInfoHashRef => $fileInfoHashRef,
					      FILEHANDLE => $FILEHANDLE,
					      exomeTargetBedFileRef => \$exomeTargetBedFile,
					     });
	
    }

    ## Add merged infile name after merging all BAM files per sampleID
    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias
    
    ## Copy file(s) to temporary directory
    say $FILEHANDLE "## Copy file(s) to temporary directory";
    ($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
								    XARGSFILEHANDLE => $XARGSFILEHANDLE,
								    arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
								    fileName =>$fileName,
								    programInfoPath => $programInfoPath,
								    nrCores => $nrCores,
								    xargsFileCounter => $xargsFileCounter,
								    infile => $infile.$infileTag,
								    inDirectory => $inSampleDirectory,
								    fileEnding => ".b*",
								    tempDirectory => $$tempDirectoryRef,
								   });
    
    ## GATK HaplotypeCaller
    say $FILEHANDLE "## GATK HaplotypeCaller";
    
    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "java",
							 memoryAllocation => "Xmx8g",
							 javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
							 javaTemporaryDirectory => $$tempDirectoryRef,
							 javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
							});
    
    ## Split per contig
    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {

	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];

	print $XARGSFILEHANDLE "-T HaplotypeCaller ";  #Type of analysis to run    
	print $XARGSFILEHANDLE "-l INFO ";  #Set the minimum level of logging
	print $XARGSFILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
	print $XARGSFILEHANDLE "-D ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{GATKHaploTypeCallerSNPKnownSet})." ";  #Known SNPs to use for annotation SNPs
	print $XARGSFILEHANDLE "-stand_call_conf 30.0 ";  #The minimum phred-scaled confidence threshold at which variants should be called
	print $XARGSFILEHANDLE "-stand_emit_conf 30.0 ";  #The minimum phred-scaled confidence threshold at which variants should be emitted
	print $XARGSFILEHANDLE "-nct 1 ";  #Number of CPU Threads per data thread

	## Check if "--pedigree" and "--pedigreeValidationType" should be included in analysis
	&GATKPedigreeFlag({scriptParameterHashRef => $scriptParameterHashRef,
			   FILEHANDLE => $XARGSFILEHANDLE,
			   outFamilyFileDirectory => $outFamilyFileDirectory,
			   pedigreeValidationType => "SILENT",
			   programName => $programName,
			  });

	## Filter
	if (${$scriptParameterHashRef}{GATKHaploTypeCallerSoftClippedBases} == 1) { #Do not analyze soft clipped bases in the reads

	    print $XARGSFILEHANDLE "--dontUseSoftClippedBases ";  #Do not analyze soft clipped bases in the reads
	}
	if ( (${$scriptParameterHashRef}{analysisType} eq "genomes") && (${$scriptParameterHashRef}{GATKHaploTypeCallerPcrIndelModel} ne 0) ) {

	    print $XARGSFILEHANDLE "--pcr_indel_model ".${$scriptParameterHashRef}{GATKHaploTypeCallerPcrIndelModel}." ";  #Assume that we run pcr-free sequencing (true for Rapid WGS and X-ten) 
	}

	## Annotations to apply to variant calls
	print $XARGSFILEHANDLE "--annotation ".join(" --annotation ", (@{${$scriptParameterHashRef}{GATKHaploTypeCallerAnnotation}}) )." ";

	if (scalar(@{$scriptParameter{sampleIDs}}) >= 10) {

	    print $XARGSFILEHANDLE "--annotation InbreedingCoeff ";  #Likelihood-based test for the inbreeding among samples (Only meningful with at least 10 founder samples)
	}
	print $XARGSFILEHANDLE "--emitRefConfidence GVCF ";  #Mode for emitting experimental reference confidence scores. GVCF generates block summarized version of the BP_RESOLUTION data 
	print $XARGSFILEHANDLE "--variant_index_type LINEAR "; 
	print $XARGSFILEHANDLE "--variant_index_parameter 128000 ";

	if ( (${$scriptParameterHashRef}{analysisType} eq "exomes") || (${$scriptParameterHashRef}{analysisType} eq "rapid") ) { #Exome/rapid analysis
	    
	    print $XARGSFILEHANDLE "-L ".catfile($$tempDirectoryRef, $$contigRef."_".$exomeTargetBedFile)." "; #Limit to targets kit target file
	}
	else {  #genomes
	    
	    print $XARGSFILEHANDLE "-L ".$$contigRef." ";  #Per contig
	}
	
	print $XARGSFILEHANDLE "-I ".catfile($$tempDirectoryRef, $infile.$infileTag."_".$$contigRef.".bam")." ";  #InFile
	print $XARGSFILEHANDLE "-o ".catfile($$tempDirectoryRef, $infile.$outfileTag."_".$$contigRef.".vcf")." ";  #OutFile
	say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
    }

    ## Copies file from temporary directory. Per contig
    say $FILEHANDLE "## Copy file from temporary directory";
    ($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
								    XARGSFILEHANDLE => $XARGSFILEHANDLE,
								    arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
								    fileName =>$fileName,
								    programInfoPath => $programInfoPath,
								    nrCores => $nrCores,
								    xargsFileCounter => $xargsFileCounter,
								    outfile => $infile.$outfileTag,
								    outDirectory => $outSampleDirectory,
								    tempDirectory => $$tempDirectoryRef,
								    fileEnding => ".vcf*",
								   });
    close($FILEHANDLE);  
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       sampleID => $$sampleIDRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub GATKBaseReCalibration { 

##GATKBaseReCalibration
    
##Function : GATK BaseRecalibrator/PrintReads to recalibrate bases before variant calling. Both BaseRecalibrator/PrintReads will be executed within the same sbatch script.
##Returns  : "|$xargsFileCounter"
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $laneHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $sampleID, $alignerOutDir, $programName, $programInfoPath, $fileName, $FILEHANDLE, $xargsFileCounter
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleIDRef                => The sampleID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
##         : $fileName                   => File name
##         : $FILEHANDLE                 => Filehandle to write to
##         : $xargsFileCounter           => The xargs file counter


    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $reduceIORef = \${$scriptParameterHashRef}{reduceIO};
    my $gatkTemporaryDirectory = catfile($$tempDirectoryRef, "gatk", "intermediary");

    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 20;
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script

	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
	
	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$sampleIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
							       nrofCores => $nrCores,
							       processTime => 50,
							       tempDirectory => $gatkTemporaryDirectory,
							      });
    }
    else {
	
	## Create GATK intermediary directory
	say $FILEHANDLE "## Create GATK intermediary directory";
	say $FILEHANDLE "mkdir -p ".$gatkTemporaryDirectory;
    }

    ## Assign directories
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk");
    my $intermediarySampleDirectory = $gatkTemporaryDirectory;
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk");
    ${$parameterHashRef}{"p".$programName}{$$sampleIDRef}{inDirectory} = $outSampleDirectory;  #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{pGATKRealigner}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{"p".$programName}{fileTag};

    ## Alias exomeTargetBed endings
    my $infileListEndingRef = \${$fileInfoHashRef}{exomeTargetBed}[0];

    ## Get exomeTargetBed file for specfic sampleID and add fileEnding from fileInfoHash if supplied
    my $exomeTargetBedFile = &GetExomTargetBEDFile({scriptParameterHashRef => $scriptParameterHashRef,
						    sampleIDRef => $sampleIDRef,
						    fileEndingRef => \${$fileInfoHashRef}{exomeTargetBed}[0],
						   });
    if ( (${$scriptParameterHashRef}{analysisType} eq "exomes") || (${$scriptParameterHashRef}{analysisType} eq "rapid") ) { #Exome/rapid analysis
	
	## Generate contig specific interval_list
	&GenerateContigSpecificTargetBedFile({scriptParameterHashRef => $scriptParameterHashRef,
					      fileInfoHashRef => $fileInfoHashRef,
					      FILEHANDLE => $FILEHANDLE,
					      exomeTargetBedFileRef => \$exomeTargetBedFile,
					      fileEnding => ".intervals",
					     });
	
    }
    $exomeTargetBedFile .= ".intervals";  #Add required GATK ending

    ## Add merged infile name after merging all BAM files per sampleID
    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias

    my $coreCounter = 1;
    
    if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	## Copy file(s) to temporary directory
	say $FILEHANDLE "## Copy file(s) to temporary directory";
	($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									XARGSFILEHANDLE => $XARGSFILEHANDLE,
									arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
									fileName =>$fileName,
									programInfoPath => $programInfoPath,
									nrCores => $nrCores,
									xargsFileCounter => $xargsFileCounter,
									infile => $infile.$infileTag,
									inDirectory => $inSampleDirectory,
									fileEnding => ".b*",
									tempDirectory => $$tempDirectoryRef,
								       });
    }
    
    $nrCores = floor(${$scriptParameterHashRef}{nodeRamMemory} / 4);  #Division by X according to the java heap
    $nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
				    nrCores => $nrCores
				   });  #To not exceed maximum
    
    ## GATK BaseRecalibrator
    say $FILEHANDLE "## GATK BaseRecalibrator";
    
    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "java",
							 memoryAllocation => "Xmx4g",
							 javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
							 javaTemporaryDirectory => $$tempDirectoryRef,
							 javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
							});
    
    ## Process per contig
    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {
	
	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];
	
	print $XARGSFILEHANDLE "-T BaseRecalibrator ";  #Type of analysis to run
	print $XARGSFILEHANDLE "-l INFO ";  #Set the minimum level of logging
	print $XARGSFILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
	print $XARGSFILEHANDLE "-cov ".join(" -cov ", (@{${$scriptParameterHashRef}{GATKBaseReCalibrationCovariate}}) )." ";  #Covariates to be used in the recalibration
	print $XARGSFILEHANDLE "-knownSites ".join(" -knownSites ", map { catfile($$referencesDirRef, $_) } (@{${$scriptParameterHashRef}{GATKBaseReCalibrationKnownSite}}) )." ";
	print $XARGSFILEHANDLE "-nct ".${$scriptParameterHashRef}{maximumCores}." ";  #How many CPU threads should be allocated per data thread to running this analysis
	print $XARGSFILEHANDLE "-dcov ".${$scriptParameterHashRef}{GATKDownSampleToCoverage}." ";  #Coverage to downsample to at any given locus	

	if ( (${$scriptParameterHashRef}{analysisType} eq "exomes") || (${$scriptParameterHashRef}{analysisType} eq "rapid") ) { #Exome/rapid analysis
	    
	    print $XARGSFILEHANDLE "-L ".catfile($$tempDirectoryRef, $$contigRef."_".$exomeTargetBedFile)." "; #Limit to targets kit target file
	}
	else {  #genomes

	    print $XARGSFILEHANDLE "-L ".$$contigRef." ";  #Per contig
	}    	    
	
	print $XARGSFILEHANDLE "-I ".catfile($$tempDirectoryRef, $infile.$infileTag."_".$$contigRef.".bam")." ";  #InFile
	print $XARGSFILEHANDLE "-o ".catfile($intermediarySampleDirectory, $infile.$infileTag."_".$$contigRef.".grp")." ";  #Recalibration table file
	say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
    }
    
    ## GATK PrintReads
    say $FILEHANDLE "## GATK PrintReads";
    
    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "java",
							 memoryAllocation => "Xmx4g",
							 javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
							 javaTemporaryDirectory => $$tempDirectoryRef,
							 javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
							});
    
    ## Process per contig
    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {
	
	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];
	
	print $XARGSFILEHANDLE "-T PrintReads ";  #Type of analysis to run	
	print $XARGSFILEHANDLE "-l INFO ";  #Set the minimum level of logging"
	print $XARGSFILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
	print $XARGSFILEHANDLE "-nct ".${$scriptParameterHashRef}{maximumCores}." ";  #How many CPU threads should be allocated per data thread to running this analysis
	print $XARGSFILEHANDLE "-dcov ".${$scriptParameterHashRef}{GATKDownSampleToCoverage}." ";  #Coverage to downsample to at any given locus
	print $XARGSFILEHANDLE "-BQSR ".catfile($intermediarySampleDirectory, $infile.$infileTag."_".$$contigRef.".grp")." ";  #Recalibration table file
	
	##Extra read filters
	if (${$scriptParameterHashRef}{GATKBaseReCalibrationOverClippedRead} == 1) {
	    
	    print $XARGSFILEHANDLE "-rf OverclippedRead ";  #Filter out reads that are over-soft-clipped
	}
	foreach my $level (@{${$scriptParameterHashRef}{GATKBaseReCalibrationStaticQuantizedQuals}}) {
	    
	    print $XARGSFILEHANDLE "--static_quantized_quals ".$level." ";  #Use discrete levels of quality base recalibration
	}
	if (${$scriptParameterHashRef}{GATKBaseReCalibrationDisableIndelQual} == 1) {
	    
	    print $XARGSFILEHANDLE "--disable_indel_quals  ";  #Do not recalibrate indel base quality (should be done for Pacbio reads)
	}
	if ( (${$scriptParameterHashRef}{analysisType} eq "exomes") || (${$scriptParameterHashRef}{analysisType} eq "rapid") ) { #Exome/rapid analysis
	    
	    print $XARGSFILEHANDLE "-L ".catfile($$tempDirectoryRef, $$contigRef."_".$exomeTargetBedFile)." "; #Limit to targets kit target file
	}
	else {  #genomes

	    print $XARGSFILEHANDLE "-L ".$$contigRef." ";  #Per contig
	}  
	
	print $XARGSFILEHANDLE "-I ".catfile($$tempDirectoryRef, $infile.$infileTag."_".$$contigRef.".bam")." ";  #InFile per contig
	print $XARGSFILEHANDLE "-o ".catfile($$tempDirectoryRef, $infile.$outfileTag."_".$$contigRef.".bam")." ";  #OutFile
	say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
    }
    
    ## Copies file from temporary directory. Per contig for variant callers.
    say $FILEHANDLE "## Copy file from temporary directory";
    ($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
								    XARGSFILEHANDLE => $XARGSFILEHANDLE,
								    arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
								    fileName =>$fileName,
								    programInfoPath => $programInfoPath,
								    nrCores => $nrCores,
								    xargsFileCounter => $xargsFileCounter,
								    outfile => $infile.$outfileTag,
								    outDirectory => $outSampleDirectory,
								    tempDirectory => $$tempDirectoryRef,
								    fileEnding => ".b*",
								   });
    
    if ($$reduceIORef) {  #Run as block sbatch script
	
	## Remove file at temporary Directory
	&RemoveContigFileAtTempDirectory({arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
					  FILEHANDLE => $FILEHANDLE,
					  nrCores => $nrCores,
					  fileName => $infile.$infileTag,
					  fileEnding => ".b*",
					  tempDirectory => $$tempDirectoryRef,
					 });
    }
    
    ## Concatenates BAMs
    &GatherBamFiles({scriptParameterHashRef => $scriptParameterHashRef,
		     arrayRef => \@{${$fileInfoHashRef}{contigs}},
		     FILEHANDLE => $FILEHANDLE,
		     infile => $infile.$outfileTag,
		     createIndex => "FALSE",
		    });

    ## Create BAM index (temporary fix to accomodate Pilup.Js bug)
    print $FILEHANDLE "\nsamtools index ";
    say $FILEHANDLE catfile($$tempDirectoryRef, $infile.$outfileTag.".bam")."\n";
    
    ## Copies file from temporary directory.
    say $FILEHANDLE "## Copy file from temporary directory";
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $infile.$outfileTag.".b*"),
			  filePath => $outSampleDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    
    ## Remove Concatenated BAM file at temporary Directory
    say $FILEHANDLE "rm ".catfile($$tempDirectoryRef, $infile.$outfileTag.".b*");
    
    if ( (${$scriptParameterHashRef}{pGATKBaseRecalibration} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) { 
	
	${$sampleInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MostCompleteBAM}{Path} = catfile($outSampleDirectory, $infile.$outfileTag.".bam");
    }

    close($XARGSFILEHANDLE);
    
    close($FILEHANDLE);
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) { 
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       sampleID => $$sampleIDRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub GATKReAligner { 

##GATKReAligner
    
##Function : GATK ReAlignerTargetCreator/IndelRealigner to rearrange reads around INDELs. Both ReAlignerTargetCreator and IndelRealigner will be executed within the same sbatch script.
##Returns  : "|$xargsFileCounter"
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $laneHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $sampleID, $alignerOutDir, $programName, $fileName, $programInfoPath, $FILEHANDLE, $xargsFileCounter
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleIDRef                => The sampleID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
##         : $fileName                   => File name
##         : $FILEHANDLE                 => Filehandle to write to
##         : $xargsFileCounter           => The xargs file counter

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $programName = ${$argHashRef}{programName};
    my $fileName = ${$argHashRef}{fileName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $reduceIORef = \${$scriptParameterHashRef}{reduceIO};
    my $gatkTemporaryDirectory = catfile($$tempDirectoryRef, "gatk", "intermediary");

    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 20;
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script

	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle

	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$sampleIDRef,
							       programName => $programName,
							       programDirectory => catfile(lc($$alignerOutDirRef), "gatk"),
							       nrofCores => $nrCores,
							       processTime => 40,
							       tempDirectory => $gatkTemporaryDirectory
							      });
    }
    else {

	## Create GATK intermediary directory
	say $FILEHANDLE "## Create GATK intermediary directory";
	say $FILEHANDLE "mkdir -p ".$gatkTemporaryDirectory;
    }

    ## Assign directories
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef);
    my $intermediarySampleDirectory = $gatkTemporaryDirectory;
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef, "gatk");
    ${$parameterHashRef}{"p".$programName}{$$sampleIDRef}{inDirectory} = $outSampleDirectory;  #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{pSambambaMarkduplicates}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{"p".$programName}{fileTag};
    
    ## Get exomeTargetBed file for specfic sampleID and add fileEnding from fileInfoHash if supplied
    my $exomeTargetBedFile = &GetExomTargetBEDFile({scriptParameterHashRef => $scriptParameterHashRef,
						    sampleIDRef => $sampleIDRef,
						    fileEndingRef => \${$fileInfoHashRef}{exomeTargetBed}[2],
						   });
    
    if ( (${$scriptParameterHashRef}{analysisType} eq "exomes") || (${$scriptParameterHashRef}{analysisType} eq "rapid") ) { #Exome/rapid analysis
	
	## Generate contig specific interval_list
	&GenerateContigSpecificTargetBedFile({scriptParameterHashRef => $scriptParameterHashRef,
					      fileInfoHashRef => $fileInfoHashRef,
					      FILEHANDLE => $FILEHANDLE,
					      exomeTargetBedFileRef => \$exomeTargetBedFile,
					     });
	
    }

    ## Add merged infile name after merging all BAM files per sampleID
    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias
    
    if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	## Copy file(s) to temporary directory
	say $FILEHANDLE "## Copy file(s) to temporary directory";
	($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									XARGSFILEHANDLE => $XARGSFILEHANDLE,
									arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
									fileName =>$fileName,
									programInfoPath => $programInfoPath,
									nrCores => $nrCores,
									xargsFileCounter => $xargsFileCounter,
									infile => $infile.$infileTag,
									inDirectory => $inSampleDirectory,
									fileEnding => ".b*",
									tempDirectory => $$tempDirectoryRef,
								       });
    }
    
    ## GATK ReAlignerTargetCreator
    say $FILEHANDLE "## GATK ReAlignerTargetCreator";
    
    $nrCores = floor(${$scriptParameterHashRef}{nodeRamMemory} / 4);  #Division by 4 since the java heap is 4GB
    $nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
				    nrCores => $nrCores
				   });  #To not exceed maximum
    
    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "java",
							 memoryAllocation => "Xmx4g",
							 javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
							 javaTemporaryDirectory => $$tempDirectoryRef,
							 javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
							});
    
    ## Process per contig
    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {
	
	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];
	
	print $XARGSFILEHANDLE "-T RealignerTargetCreator ";  #Type of analysis to run
	print $XARGSFILEHANDLE "-l INFO ";  #Set the minimum level of logging
	print $XARGSFILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file 
	print $XARGSFILEHANDLE "-known ".join(" -known ", map { catfile($$referencesDirRef, $_) } (@{${$scriptParameterHashRef}{GATKReAlignerINDELKnownSite}}) )." ";  #Input VCF file(s) with known indels
	print $XARGSFILEHANDLE "-dcov ".${$scriptParameterHashRef}{GATKDownSampleToCoverage}." ";  #Coverage to downsample to at any given locus	    
	
	if ( (${$scriptParameterHashRef}{analysisType} eq "exomes") || (${$scriptParameterHashRef}{analysisType} eq "rapid") ) { #Exome/rapid analysis
	    
	    print $XARGSFILEHANDLE "-L ".catfile($$tempDirectoryRef, $$contigRef."_".$exomeTargetBedFile)." "; #Limit to targets kit target file
	}
	else {  #genomes

	    print $XARGSFILEHANDLE "-L ".$$contigRef." ";  #Per contig
	}
	print $XARGSFILEHANDLE "-I ".catfile($$tempDirectoryRef, $infile.$infileTag."_".$$contigRef.".bam")." ";  #InFile	    
	print $XARGSFILEHANDLE "-o ".catfile($intermediarySampleDirectory, $infile.$outfileTag."_".$$contigRef.".intervals")." ";  #Interval outfile
	say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
    }
    
    ## GATK IndelRealigner
    say $FILEHANDLE "## GATK IndelRealigner";
    
    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "java",
							 memoryAllocation => "Xmx4g",
							 javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
							 javaTemporaryDirectory => $$tempDirectoryRef,
							 javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
							});
    
    ## Process per contig
    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {
	
	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];
	
	print $XARGSFILEHANDLE "-T IndelRealigner ";
	print $XARGSFILEHANDLE "-l INFO ";
	print $XARGSFILEHANDLE "-R ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
	print $XARGSFILEHANDLE "-known ".join(" -known ", map { catfile($$referencesDirRef, $_) } (@{${$scriptParameterHashRef}{GATKReAlignerINDELKnownSite}}) )." ";  #Input VCF file(s) with known indels
	print $XARGSFILEHANDLE "-dcov ".${$scriptParameterHashRef}{GATKDownSampleToCoverage}." ";  #Coverage to downsample to at any given locus
	print $XARGSFILEHANDLE "--consensusDeterminationModel USE_READS ";  #Additionally uses indels already present in the original alignments of the reads 
	print $XARGSFILEHANDLE "-targetIntervals ".catfile($intermediarySampleDirectory, $infile.$outfileTag."_".$$contigRef.".intervals")." ";
	
	if ( (${$scriptParameterHashRef}{analysisType} eq "exomes") || (${$scriptParameterHashRef}{analysisType} eq "rapid") ) { #Exome/rapid analysis	
	    
	    print $XARGSFILEHANDLE "-L ".catfile($$tempDirectoryRef, $$contigRef."_".$exomeTargetBedFile)." "; #Limit to targets kit target file
	}
	else {  #genomes

	    print $XARGSFILEHANDLE "-L ".$$contigRef." ";  #Per contig
	}
	
	print $XARGSFILEHANDLE "-I ".catfile($$tempDirectoryRef, $infile.$infileTag."_".$$contigRef.".bam")." ";  #InFile per contig
	print $XARGSFILEHANDLE "-o ".catfile($$tempDirectoryRef, $infile.$outfileTag."_".$$contigRef.".bam")." ";  #OutFile
	say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
    }
    
    if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	## Copies file from temporary directory. Per contig
	say $FILEHANDLE "## Copy file from temporary directory";
	($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									XARGSFILEHANDLE => $XARGSFILEHANDLE,
									arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
									fileName =>$fileName,
									programInfoPath => $programInfoPath,
									nrCores => $nrCores,
									xargsFileCounter => $xargsFileCounter,
									outfile => $infile.$outfileTag,
									outDirectory => $outSampleDirectory,
									tempDirectory => $$tempDirectoryRef,
									fileEnding => ".b*",
								       });
	
	if ( (${$scriptParameterHashRef}{pGATKRealigner} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	    ${$sampleInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MostCompleteBAM}{Path} = catfile($outSampleDirectory, $infile.$outfileTag.".bam");	    
	}	
    }
    else {
	
	## Remove file at temporary Directory
	&RemoveContigFileAtTempDirectory({arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
					  FILEHANDLE => $FILEHANDLE,
					  nrCores => $nrCores,
					  fileName => $infile.$infileTag,
					  fileEnding => ".b*",
					  tempDirectory => $$tempDirectoryRef,
					 });
    }
    
    close($XARGSFILEHANDLE);
    
    if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	close($FILEHANDLE);
	
	if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			   sampleInfoHashRef => $sampleInfoHashRef,
			   jobIDHashRef => $jobIDHashRef,
			   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			   sampleID => $$sampleIDRef,
			   dependencies => 1, 
			   path => ${$parameterHashRef}{"p".$programName}{chain},
			   sbatchFileName => $fileName
			  });
	}
    }
    else {
	
	return $xargsFileCounter;  #Track the number of created xargs scripts per module for Block algorithm
    }
}


sub PicardToolsMarkduplicates { 

##PicardToolsMarkduplicates
    
##Function : Mark duplicated reads using PicardTools Markduplicates in files generated from alignment (sorted, merged).
##Returns  : "|$xargsFileCounter"
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $sampleID, $alignerOutDir, $programName, $fileName, $programInfoPath, $FILEHANDLE, $xargsFileCounter
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleIDRef                => The sampleID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $programName                => The program name
##         : $fileName                   => File name
##         : $programInfoPath            => The program info path
##         : $FILEHANDLE                 => Filehandle to write to
##         : $xargsFileCounter           => The xargs file counter

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $reduceIORef = \${$scriptParameterHashRef}{reduceIO};
    my $lanes = join("",@{ ${$laneHashRef}{$$sampleIDRef} });  #Extract lanes

    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 20;
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script

	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    }

    ## Assign directories
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef);
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef);
    ${$parameterHashRef}{"p".$programName}{$$sampleIDRef}{inDirectory} = $outSampleDirectory;  #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{pPicardToolsMergeSamFiles}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{"p".$programName}{fileTag};

    ## Add merged infile name after merging all BAM files per sampleID
    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias

    ## Sums all mapped and duplicate reads and takes fraction of before finishing
    my $regExp = q?perl -nae'my %feature; while (<>) { if($_=~/duplicates/ && $_=~/^(\d+)/) {$feature{dup} = $feature{dup} + $1} if($_=~/\d+\smapped/ && $_=~/^(\d+)/) {$feature{map} = $feature{map} + $1} } print "Read Mapped: ".$feature{map}."\nDuplicates: ".$feature{dup}."\n"."Fraction Duplicates: ".$feature{dup}/$feature{map}, "\n"; last;'?; 

    if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$sampleIDRef,
							       programName => $programName,
							       programDirectory => lc($$alignerOutDirRef),
							       nrofCores => $nrCores,
							       processTime => $time,
							       tempDirectory => $$tempDirectoryRef
							      });
	
	## Copy file(s) to temporary directory
	say $FILEHANDLE "## Copy file(s) to temporary directory";
	($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									XARGSFILEHANDLE => $XARGSFILEHANDLE,
									arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
									fileName =>$fileName,
									programInfoPath => $programInfoPath,
									nrCores => $nrCores,
									xargsFileCounter => $xargsFileCounter,
									infile => $infile.$infileTag,
									inDirectory => $inSampleDirectory,
									fileEnding => ".b*",
									tempDirectory => $$tempDirectoryRef,
								       });
    }
    
    ## Marking Duplicates
    say $FILEHANDLE "## Marking Duplicates";
    
    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE,
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "java",
							 memoryAllocation => "Xmx4g",
							 javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
							 javaTemporaryDirectory => $$tempDirectoryRef,
							 javaJar =>  ${$scriptParameterHashRef}{picardToolsPath}."/picard.jar",
							});	
    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {
	
	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];
	
	print $XARGSFILEHANDLE "MarkDuplicates ";
	print $XARGSFILEHANDLE "METRICS_FILE=".catfile($$tempDirectoryRef, $infile.$outfileTag."_".$$contigRef.".metric")." ";  #MetricFile
	print $XARGSFILEHANDLE "CREATE_INDEX=TRUE ";  #Create a BAM index when writing a coordinate-sorted BAM file.
	print $XARGSFILEHANDLE "INPUT=".catfile($$tempDirectoryRef, $infile.$infileTag."_".$$contigRef.".bam")." ";;  #InFile
	print $XARGSFILEHANDLE "OUTPUT=".catfile($$tempDirectoryRef, $infile.$outfileTag."_".$$contigRef.".bam")." ";  #OutFile
	print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	print $XARGSFILEHANDLE "; ";
	
	## Process BAM with sambamba flagstat to produce metric file for downstream analysis
	&SambambaFlagStat({infilePath => catfile($$tempDirectoryRef, $infile.$outfileTag."_".$$contigRef.".bam"),
			   outfilePath => catfile($$tempDirectoryRef, $infile.$outfileTag."_".$$contigRef."_metric"),
			   stderrFilePath => $xargsFileName.".".$$contigRef.".stderr.txt",
			   FILEHANDLE => $XARGSFILEHANDLE,
			  });
    }
    
    ## Concatenate all metric files
    print $FILEHANDLE "cat ";
    print $FILEHANDLE catfile($$tempDirectoryRef, $infile.$outfileTag."_*_metric")." ";
    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $infile.$outfileTag."_metricAll")." ", "\n";  #Metric file for all files
    
    ## Sum metric over concatenated file
    print $FILEHANDLE $regExp." ";
    print $FILEHANDLE catfile($$tempDirectoryRef, $infile.$outfileTag."_metricAll")." ";
    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $infile.$outfileTag."_metric")." ", "\n";  #Sum of all original metric files
    
    
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $infile.$outfileTag."_metric"),
			  filePath => $outSampleDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	## Collect QC metadata info for later use
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       sampleID => $$sampleIDRef,
		       programName => "MarkDuplicates",
		       infile => $infile,
		       outDirectory => $outSampleDirectory,
		       outfileEnding => $outfileTag."_metric",
		       outDataType => "infileDependent"
		      });
	${$sampleInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MostCompleteBAM}{Path} = catfile($outSampleDirectory, $infile.$outfileTag."_".${$fileInfoHashRef}{contigsSizeOrdered}[0].".bam");
    }
    
    if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	## Copies file from temporary directory. Per contig
	say $FILEHANDLE "## Copy file from temporary directory";
	($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									XARGSFILEHANDLE => $XARGSFILEHANDLE,
									arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
									fileName =>$fileName,
									programInfoPath => $programInfoPath,
									nrCores => $nrCores,
									xargsFileCounter => $xargsFileCounter,
									outfile => $infile.$outfileTag,
									outDirectory => $outSampleDirectory,
									tempDirectory => $$tempDirectoryRef,
									fileEnding => ".b*",
								       });
    }
    else {
	
	## Remove file at temporary Directory
	&RemoveContigFileAtTempDirectory({arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
					  FILEHANDLE => $FILEHANDLE,
					  nrCores => $nrCores,
					  fileName => $infile.$infileTag,
					  fileEnding => ".b*",
					  tempDirectory => $$tempDirectoryRef,
					 });
    }
    
    close($XARGSFILEHANDLE);
    
    if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	close($FILEHANDLE);
	
	if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			   sampleInfoHashRef => $sampleInfoHashRef,
			   jobIDHashRef => $jobIDHashRef,
			   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			   sampleID => $$sampleIDRef,
			   dependencies => 1, 
			   path => ${$parameterHashRef}{"p".$programName}{chain},
			   sbatchFileName => $fileName
			  });
	}
    }
    else {
	
	return $xargsFileCounter;  #Track the number of created xargs scripts per module for Block algorithm
    }
}


sub SambambaMarkduplicates { 

##SambambaMarkduplicates
    
##Function : Mark duplicated reads using Sambamba Markduplicates in files generated from alignment (sorted, merged).
##Returns  : "|$xargsFileCounter"
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $sampleID, $alignerOutDir, $programName, $fileName, $programInfoPath, $FILEHANDLE, $xargsFileCounter
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleIDRef                => The sampleID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $programName                => The program name
##         : $fileName                   => File name
##         : $programInfoPath            => The program info path
##         : $FILEHANDLE                 => Filehandle to write to
##         : $xargsFileCounter           => The xargs file counter

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programName = ${$argHashRef}{programName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $reduceIORef = \${$scriptParameterHashRef}{reduceIO};
    my $lanes = join("",@{ ${$laneHashRef}{$$sampleIDRef} });  #Extract lanes

    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 20;
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script

	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    }

    ## Assign directories
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef);
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef);
    ${$parameterHashRef}{"p".$programName}{$$sampleIDRef}{inDirectory} = $outSampleDirectory;  #Used downstream

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{pPicardToolsMergeSamFiles}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{"p".$programName}{fileTag};

    ## Add merged infile name after merging all BAM files per sampleID
    my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MergeInfile};  #Alias

    ## Sums all mapped and duplicate reads and takes fraction of before finishing
    my $regExp = q?perl -nae'my %feature; while (<>) { if($_=~/duplicates/ && $_=~/^(\d+)/) {$feature{dup} = $feature{dup} + $1} if($_=~/\d+\smapped/ && $_=~/^(\d+)/) {$feature{map} = $feature{map} + $1} } print "Read Mapped: ".$feature{map}."\nDuplicates: ".$feature{dup}."\n"."Fraction Duplicates: ".$feature{dup}/$feature{map}, "\n"; last;'?; 

    if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$sampleIDRef,
							       programName => $programName,
							       programDirectory => lc($$alignerOutDirRef),
							       nrofCores => $nrCores,
							       processTime => $time,
							       tempDirectory => $$tempDirectoryRef
							      });
	
	## Copy file(s) to temporary directory
	say $FILEHANDLE "## Copy file(s) to temporary directory";
	($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									XARGSFILEHANDLE => $XARGSFILEHANDLE,
									arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
									fileName =>$fileName,
									programInfoPath => $programInfoPath,
									nrCores => $nrCores,
									xargsFileCounter => $xargsFileCounter,
									infile => $infile.$infileTag,
									inDirectory => $inSampleDirectory,
									fileEnding => ".b*",
									tempDirectory => $$tempDirectoryRef,
								       });
    }
    
    ## Marking Duplicates
    say $FILEHANDLE "## Marking Duplicates";    
    
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => "sambamba ",  #Program
							});
    
    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {
	
	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];
	
	print $XARGSFILEHANDLE "markdup ";
	print $XARGSFILEHANDLE "--tmpdir=".${$scriptParameterHashRef}{tempDirectory}." ";  #Directory for storing intermediate files
	print $XARGSFILEHANDLE "--show-progress ";  #Show progressbar in STDERR
	print $XARGSFILEHANDLE "--hash-table-size=".${$scriptParameterHashRef}{sambambaMarkDupHashTableSize}." ";  #Size of hash table for finding read pairs
	print $XARGSFILEHANDLE "--overflow-list-size=".${$scriptParameterHashRef}{sambambaMarkDupOverflowListSize}." ";  #Size of the overflow list
	print $XARGSFILEHANDLE "--io-buffer-size=".${$scriptParameterHashRef}{sambambaMarkDupIoBufferSize}." "; #Two buffers of BUFFER_SIZE *megabytes* each are used for reading and writing BAM during the second pass
	print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $infile.$infileTag."_".$$contigRef.".bam")." ";;  #InFile
	print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $infile.$outfileTag."_".$$contigRef.".bam")." ";  #OutFile
	print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	print $XARGSFILEHANDLE "; ";
	
	## Process BAM with sambamba flagstat to produce metric file for downstream analysis
	&SambambaFlagStat({infilePath => catfile($$tempDirectoryRef, $infile.$outfileTag."_".$$contigRef.".bam"),
			   outfilePath => catfile($$tempDirectoryRef, $infile.$outfileTag."_".$$contigRef."_metric"),
			   stderrFilePath => $xargsFileName.".".$$contigRef.".stderr.txt",
			   FILEHANDLE => $XARGSFILEHANDLE,
			  });
    }
    
    ## Concatenate all metric files
    print $FILEHANDLE "cat ";
    print $FILEHANDLE catfile($$tempDirectoryRef, $infile.$outfileTag."_*_metric")." ";
    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $infile.$outfileTag."_metricAll")." ", "\n";  #Metric file for all files
    
    ## Sum metric over concatenated file
    print $FILEHANDLE $regExp." ";
    print $FILEHANDLE catfile($$tempDirectoryRef, $infile.$outfileTag."_metricAll")." ";
    say $FILEHANDLE "> ".catfile($$tempDirectoryRef, $infile.$outfileTag."_metric")." ", "\n";  #Sum of all original metric files
    
    
    &MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, $infile.$outfileTag."_metric"),
			  filePath => $outSampleDirectory,
			  FILEHANDLE => $FILEHANDLE,
			 });
    say $FILEHANDLE "wait", "\n";
    
    if ( (${$scriptParameterHashRef}{pSambambaMarkduplicates} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	## Collect QC metadata info for later use
	&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
		       familyID => $$familyIDRef,
		       sampleID => $$sampleIDRef,
		       programName => "MarkDuplicates",
		       infile => $infile,
		       outDirectory => $outSampleDirectory,
		       outfileEnding => $outfileTag."_metric",
		       outDataType => "infileDependent"
		      });
	${$sampleInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MostCompleteBAM}{Path} = catfile($outSampleDirectory, $infile.$outfileTag."_".${$fileInfoHashRef}{contigsSizeOrdered}[0].".bam");
    }
    
    if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	## Copies file from temporary directory. Per contig
	say $FILEHANDLE "## Copy file from temporary directory";
	($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									XARGSFILEHANDLE => $XARGSFILEHANDLE,
									arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
									fileName =>$fileName,
									programInfoPath => $programInfoPath,
									nrCores => $nrCores,
									xargsFileCounter => $xargsFileCounter,
									outfile => $infile.$outfileTag,
									outDirectory => $outSampleDirectory,
									tempDirectory => $$tempDirectoryRef,
									fileEnding => ".b*",
								       });
    }
    else {
	
	## Remove file at temporary Directory
	&RemoveContigFileAtTempDirectory({arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
					  FILEHANDLE => $FILEHANDLE,
					  nrCores => $nrCores,
					  fileName => $infile.$infileTag,
					  fileEnding => ".b*",
					  tempDirectory => $$tempDirectoryRef,
					 });
    }

    close($XARGSFILEHANDLE);
    
    if ( ! $$reduceIORef) {  #Run as individual sbatch script
	
	close($FILEHANDLE);
	
	if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			   sampleInfoHashRef => $sampleInfoHashRef,
			   jobIDHashRef => $jobIDHashRef,
			   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			   sampleID => $$sampleIDRef,
			   dependencies => 1, 
			   path => ${$parameterHashRef}{"p".$programName}{chain},
			   sbatchFileName => $fileName
			  });
	}
    }
    else {
	
	return $xargsFileCounter;  #Track the number of created xargs scripts per module for Block algorithm
    }
}


sub PicardToolsMergeSamFiles { 

##PicardToolsMergeSamFiles
    
##Function : Merges all bam files using PicardTools MergeSamFiles within each sampleid and files generated previously (option if provided with '-picardToolsMergeSamFilesPrevious'). The merged files have to be sorted before attempting to merge.
##Returns  : "|$xargsFileCounter"
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $sampleIDRef, $alignerOutDirRef, $fileName, $programInfoPath, $programName, $FILEHANDLE, $xargsFileCounter
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleIDRef                => The sampleID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis {REF}
##         : $programName                => The program name
##         : $programInfoPath            => The program info path
##         : $fileName                   => File name
##         : $FILEHANDLE                 => Filehandle to write to
##         : $xargsFileCounter           => The xargs file counter

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $fileName = ${$argHashRef}{fileName};
    my $programName = ${$argHashRef}{programName};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $programInfoPath = ${$argHashRef}{programInfoPath};

    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $reduceIORef = \${$scriptParameterHashRef}{reduceIO};
    my $lanes = join("",@{ ${$laneHashRef}{$$sampleIDRef} });  #Extract lanes

    my $XARGSFILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $xargsFileName;

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script
	
	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle	
	
	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$sampleIDRef,
							       programName => $programName,
							       programDirectory => lc($$alignerOutDirRef),
							       nrofCores => $nrCores,
							       processTime => 20,
							       tempDirectory => $$tempDirectoryRef
							      });
    }

    ## Assign directories
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef);
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef);
    ${$parameterHashRef}{"p".$programName}{$$sampleIDRef}{inDirectory} = $outSampleDirectory;  #Used downstream
   
    ## Assign fileTags
    my $infileTag;

    if (${$scriptParameterHashRef}{analysisType} ne "rapid") {

	$infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{ ${$parameterHashRef}{activeAligner} }{fileTag};
    }    
    else {  #Rapid mode used

	$infileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{pPicardToolsMergeRapidReads}{fileTag};
    }
    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{pPicardToolsMergeSamFiles}{fileTag};

    ## Copies files from source to temporary folder. Loop over files specified by $arrayRef and collects files from $extractArrayRef.
    &MigrateFilesToTemp({scriptParameterHashRef => $scriptParameterHashRef,
			 arrayRef => \@{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} },
			 extractArrayRef => \@{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} },
			 FILEHANDLE => $FILEHANDLE,
			 inSampleDirectory => $inSampleDirectory,
			 nrCores => $nrCores,
			 fileEnding => $infileTag.".b*"
			});
    
    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} });$infileCounter++) {  #For all files from 
	    
	my $infile = ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter];
	
	## Split BAMs using Samtools
	say $FILEHANDLE "## Split alignment files per contig";
	($xargsFileCounter, $xargsFileName) = &SplitBAMSambamba({scriptParameterHashRef => $scriptParameterHashRef,
								 FILEHANDLE => $FILEHANDLE,
								 XARGSFILEHANDLE => $XARGSFILEHANDLE,
								 contigs => \@{${$fileInfoHashRef}{contigsSizeOrdered}},
								 fileName => $fileName,
								 programInfoPath => $programInfoPath,
								 nrCores => $nrCores,
								 xargsFileCounter => $xargsFileCounter,
								 temporaryDirectory => $$tempDirectoryRef,
								 xargsFileCounter => $xargsFileCounter,
								 infile => $infile.$infileTag
								});
    }
    
    if (scalar( @{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} }) > 1) {
	
	## PicardToolsMergeSamFiles
	say $FILEHANDLE "## Merging alignment files";
	
	$nrCores = floor(${$scriptParameterHashRef}{nodeRamMemory} / 4);  #Division by X according to java Heap size
	$nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
					nrCores => $nrCores,
				       });  #To not exceed maximum
	
	## Create file commands for xargs
	($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							     XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							     fileName => $fileName,
							     programInfoPath => $programInfoPath,
							     nrCores => $nrCores,
							     firstCommand => "java",
							     xargsFileCounter => $xargsFileCounter,
							     memoryAllocation => "Xmx4g",
							     javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
							     javaTemporaryDirectory => $$tempDirectoryRef,
							     javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
							    });
	
	## Split per contig
	for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {
	    
	    my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];
	    
	    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} });$infileCounter++) {  #For all files from 
		
		my $infile = ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter];
		
		if ($infileCounter eq 0) {  #First round of loop
		    
		    print $XARGSFILEHANDLE "MergeSamFiles ";
		    print $XARGSFILEHANDLE "USE_THREADING=TRUE "; #Create a background thread to encode, compress and write to disk the output file
		    print $XARGSFILEHANDLE "CREATE_INDEX=TRUE ";  #Create a BAM index when writing a coordinate-sorted BAM file.
		    print $XARGSFILEHANDLE "OUTPUT=".catfile($$tempDirectoryRef, $$sampleIDRef."_lanes_".$lanes.$outfileTag."_".$$contigRef.".bam")." ";  #OutFile
		}
		print $XARGSFILEHANDLE "INPUT=".catfile($$tempDirectoryRef, $infile.$infileTag."_".$$contigRef.".bam")." ";  #InFile
	    }
	    say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	}
    }
    else {  #only 1 infile - rename sample instead of merge to streamline handling of filenames downstream
	
	## Rename samples
	say $FILEHANDLE "## Renaming sample instead of merge to streamline handling of filenames downstream";
	
	## Create file commands for xargs
	($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							     XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							     fileName => $fileName,
							     programInfoPath => $programInfoPath,
							     nrCores => $nrCores,
							     firstCommand => "mv",
							     xargsFileCounter => $xargsFileCounter,
							    });

	## Split per contig
	for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {
	    
	    my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];
	    
	    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} });$infileCounter++) {  #For all files from 
		
		my $infile = ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter];
		
		print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $infile.$infileTag."_".$$contigRef.".bam")." ";  #InFile
		print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$sampleIDRef."_lanes_".$lanes.$outfileTag."_".$$contigRef.".bam")." ";  #OutFile
		print $XARGSFILEHANDLE "; ";
		print $XARGSFILEHANDLE "samtools index ";
		print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $$sampleIDRef."_lanes_".$lanes.$outfileTag."_".$$contigRef.".bam")." ";
	    }
	    print $XARGSFILEHANDLE "\n";
	}
    }
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	${$sampleInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MostCompleteBAM}{Path} = catfile($outSampleDirectory, $$sampleIDRef."_lanes_".$lanes.$outfileTag.".bam");
    }
    
    ## Merge previously merged files with merged files generated this run
    if ( (${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{picardToolsMergeSamFilesPrevious} == 1) && (scalar( @{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} }) > 1) ) {
	
	for (my $mergeFileCounter=0;$mergeFileCounter<scalar(@{${$scriptParameterHashRef}{picardToolsMergeSamFilesPrevious}});$mergeFileCounter++) {
	    
	    if (${$scriptParameterHashRef}{picardToolsMergeSamFilesPrevious}[$mergeFileCounter] =~ /$$sampleIDRef/) {  #Look for sampleID in previously generated file to be merged with current run to be able to merge correct files within sampleID

		## Copy file(s) to temporary directory
		say $FILEHANDLE "## Copy file(s) to temporary directory";
		my $picardToolsMergeSamFilesPreviousFile = &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
									       path => ${$scriptParameterHashRef}{picardToolsMergeSamFilesPrevious}[$mergeFileCounter],
									       tempDirectory => $$tempDirectoryRef
									      });
		say $FILEHANDLE "wait", "\n";
		
		if (${$scriptParameterHashRef}{picardToolsMergeSamFilesPrevious}[$mergeFileCounter] =~ /lane(\d+)|s_(\d+)/) {  #Look for lanes_ or lane\d in previously generated file to be merged with current run to be able to extract previous lanes
		    
		    my $mergeLanes; if($1) {$mergeLanes = $1;} else {$mergeLanes = $2;}  #Make sure to always supply lanes from previous regexp		    

		    ## Removes ".fileEnding" in filename.FILENDING(.gz)
		    my $picardToolsMergeSamFilesPreviousFileNoEnding = &RemoveFileEnding({fileNameRef => \$picardToolsMergeSamFilesPreviousFile,
											  fileEnding => ".bam",
											 });

		    ## Split BAMs using Samtools
		    say $FILEHANDLE "## Split alignment files per contig";
		    ($xargsFileCounter, $xargsFileName) = &SplitBAMSambamba({scriptParameterHashRef => $scriptParameterHashRef,
									     FILEHANDLE => $FILEHANDLE,
									     XARGSFILEHANDLE => $XARGSFILEHANDLE,
									     contigs => \@{${$fileInfoHashRef}{contigsSizeOrdered}},
									     fileName => $fileName,
									     programInfoPath => $programInfoPath,
									     nrCores => $nrCores,
									     xargsFileCounter => $xargsFileCounter,
									     temporaryDirectory => $$tempDirectoryRef,
									     infile => $picardToolsMergeSamFilesPreviousFileNoEnding
									    });

		    ## PicardToolsMergeSamFiles
		    say $FILEHANDLE "## Merging alignment files";

		    $nrCores = floor(${$scriptParameterHashRef}{nodeRamMemory} / 4);  #Division by X according to java Heap size
		    $nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
						    nrCores => $nrCores,
						   });  #To not exceed maximum

		    ## Create file commands for xargs
		    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
									 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
									 fileName => $fileName,
									 programInfoPath => $programInfoPath,
									 nrCores => $nrCores,
									 xargsFileCounter => $xargsFileCounter,
									 firstCommand => "java",
									 memoryAllocation => "Xmx4g",
									 javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
									 javaTemporaryDirectory => $$tempDirectoryRef,
									 javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
									});
		    
		    ## Split per contig
		    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {

			my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];

			print $XARGSFILEHANDLE "MergeSamFiles ";
			print $XARGSFILEHANDLE "USE_THREADING=TRUE "; #Create a background thread to encode, compress and write to disk the output file
			print $XARGSFILEHANDLE "CREATE_INDEX=TRUE ";  #Create a BAM index when writing a coordinate-sorted BAM file.
			print $XARGSFILEHANDLE "OUTPUT=".catfile($$tempDirectoryRef, $$sampleIDRef."_lanes_".$mergeLanes.$lanes.$outfileTag."_".$$contigRef.".bam")." ";  #OutFile
			print $XARGSFILEHANDLE "INPUT=".catfile($$tempDirectoryRef, $$sampleIDRef."_lanes_".$lanes.$outfileTag."_".$$contigRef.".bam")." ";  #InFile from previous merge
			print $XARGSFILEHANDLE "INPUT=".catfile($$tempDirectoryRef, $picardToolsMergeSamFilesPreviousFileNoEnding."_".$$contigRef.".bam")." ";  #$mergeLanes contains lane info on previous merge, $infilesLaneNoEnding{$$sampleIDRef}[0] uses @RG for very first .bam file to include read group for subsequent merges. Complete path. 
			say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
		    }
		    
		    if ( ! $$reduceIORef) {
			
			## Copies file from temporary directory. Per contig
			say $FILEHANDLE "## Copy file from temporary directory";
			($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
											XARGSFILEHANDLE => $XARGSFILEHANDLE,
											arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
											fileName =>$fileName,
											programInfoPath => $programInfoPath,
											nrCores => $nrCores,
											xargsFileCounter => $xargsFileCounter,
											outfile => $$sampleIDRef."_lanes_".$mergeLanes.$lanes.$outfileTag,
											outDirectory => $outSampleDirectory,
											tempDirectory => $$tempDirectoryRef,
											fileEnding => ".b*",
										       });
		    }
		    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

			${$sampleInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MostCompleteBAM}{Path} = catfile($outSampleDirectory, $$sampleIDRef."_lanes_".$mergeLanes.$lanes.$outfileTag.".bam");
		    }
		}
	    }
	}
    }

    ## Merge files previously merged to single file with single file generated this run
    elsif (${$fileInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{picardToolsMergeSamFilesPrevious} == 1) {

	for (my $mergeFileCounter=0;$mergeFileCounter<scalar(@{${$scriptParameterHashRef}{picardToolsMergeSamFilesPrevious}});$mergeFileCounter++) {

	    ## Copy file(s) to temporary directory
	    say $FILEHANDLE "## Copy file(s) to temporary directory";
	    my $picardToolsMergeSamFilesPreviousFile = &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
									   path => ${$scriptParameterHashRef}{picardToolsMergeSamFilesPrevious}[$mergeFileCounter],
									   tempDirectory => $$tempDirectoryRef
									  });
	    say $FILEHANDLE "wait", "\n";

	    if (${$scriptParameterHashRef}{picardToolsMergeSamFilesPrevious}[$mergeFileCounter] =~ /lane(\d+)|s_(\d+)/) {  #Look for lanes_ or lane\d in previously generated file to be merged with current run to be able to extract previous lanes
		
		my $mergeLanes; if($1) {$mergeLanes = $1;} else {$mergeLanes = $2;}  #Make sure to always supply lanes from previous regexp
		my $infile = ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[0];  #Can only be 1 element in array due to previous if statement		    
		
		## PicardToolsMergeSamFiles
		say $FILEHANDLE "## Merging alignment files";

		$nrCores = floor(${$scriptParameterHashRef}{nodeRamMemory} / 4);  #Division by X according to java Heap size
		$nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
						nrCores => $nrCores,
					       });  #To not exceed maximum

		## Removes ".fileEnding" in filename.FILENDING(.gz)
		my $picardToolsMergeSamFilesPreviousFileNoEnding = &RemoveFileEnding({fileNameRef => \$picardToolsMergeSamFilesPreviousFile,
										      fileEnding => ".bam",
										     });

		## Split BAMs using Samtools
		say $FILEHANDLE "## Split alignment files per contig";
		($xargsFileCounter, $xargsFileName) = &SplitBAMSambamba({scriptParameterHashRef => $scriptParameterHashRef,
									 FILEHANDLE => $FILEHANDLE,
									 XARGSFILEHANDLE => $XARGSFILEHANDLE,
									 contigs => \@{${$fileInfoHashRef}{contigsSizeOrdered}},
									 fileName => $fileName,
									 programInfoPath => $programInfoPath,
									 nrCores => $nrCores,
									 xargsFileCounter => $xargsFileCounter,
									 temporaryDirectory => $$tempDirectoryRef,
									 infile => $picardToolsMergeSamFilesPreviousFileNoEnding
									});

		## Create file commands for xargs
		($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
								     XARGSFILEHANDLE => $XARGSFILEHANDLE, 
								     fileName => $fileName,
								     programInfoPath => $programInfoPath,
								     nrCores => $nrCores,
								     xargsFileCounter => $xargsFileCounter,
								     firstCommand => "java",
								     memoryAllocation => "Xmx4g",
								     javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
								     javaTemporaryDirectory => $$tempDirectoryRef,
								     javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
								    });

		## Split per contig
		for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {
		    
		    my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];

		    print $XARGSFILEHANDLE "MergeSamFiles ";
		    print $XARGSFILEHANDLE "USE_THREADING=TRUE "; #Create a background thread to encode, compress and write to disk the output file
		    print $XARGSFILEHANDLE "CREATE_INDEX=TRUE ";  #create a BAM index when writing a coordinate-sorted BAM file.
		    print $XARGSFILEHANDLE "OUTPUT=".catfile($$tempDirectoryRef, $$sampleIDRef."_lanes_".$mergeLanes.$lanes.$outfileTag."_".$$contigRef.".bam")." ";  #OutFile
		    print $XARGSFILEHANDLE "INPUT=".catfile($$tempDirectoryRef, $infile.$infileTag."_".$$contigRef.".bam")." ";  #InFile
		    print $XARGSFILEHANDLE "INPUT=".catfile($$tempDirectoryRef, $picardToolsMergeSamFilesPreviousFileNoEnding."_".$$contigRef.".bam")." ";  #$mergeLanes contains lane info on previous merge, $infilesLaneNoEnding{$$sampleIDRef}[0] uses @RG for very first .bam file to include read group for subsequent merges. Complete path.
		    say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
		}

		if ( ! $$reduceIORef) {
		    
		    ## Copies file from temporary directory. Per contig
		    say $FILEHANDLE "## Copy file from temporary directory";
		    ($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
										    XARGSFILEHANDLE => $XARGSFILEHANDLE,
										    arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
										    fileName =>$fileName,
										    programInfoPath => $programInfoPath,
										    nrCores => $nrCores,
										    xargsFileCounter => $xargsFileCounter,
										    outfile => $$sampleIDRef."_lanes_".$mergeLanes.$lanes.$outfileTag,
										    outDirectory => $outSampleDirectory,
										    tempDirectory => $$tempDirectoryRef,
										    fileEnding => ".b*",
										   });
		}
		if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
		    
		    ${$sampleInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MostCompleteBAM}{Path} = catfile($outSampleDirectory, $$sampleIDRef."_lanes_".$mergeLanes.$lanes.$outfileTag.".bam");
		}
	    }
	}
    }
    else {

	if ( ! $$reduceIORef) {

	    ## Copies file from temporary directory. Per contig
	    say $FILEHANDLE "## Copy file from temporary directory";
	    ($xargsFileCounter, $xargsFileName) = &XargsMigrateContigFiles({FILEHANDLE => $FILEHANDLE,
									    XARGSFILEHANDLE => $XARGSFILEHANDLE,
									    arrayRef => \@{ ${$fileInfoHashRef}{contigsSizeOrdered} },
									    fileName =>$fileName,
									    programInfoPath => $programInfoPath,
									    nrCores => $nrCores,
									    xargsFileCounter => $xargsFileCounter,
									    outfile => $$sampleIDRef."_lanes_".$lanes.$outfileTag,
									    outDirectory => $outSampleDirectory,
									    tempDirectory => $$tempDirectoryRef,
									    fileEnding => ".b*",
									   });
	}
    }

    close($XARGSFILEHANDLE);

    ## Add merged infile name after merging all BAM files per sampleID
    &AddMergedInfileName({scriptParameterHashRef => $scriptParameterHashRef,
			  fileInfoHashRef => $fileInfoHashRef,
			  laneHashRef => $laneHashRef,
			  infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			  sampleID => $$sampleIDRef,
			 });

    if ( ! $$reduceIORef) {
	
	close($FILEHANDLE);
	
	if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			   sampleInfoHashRef => $sampleInfoHashRef,
			   jobIDHashRef => $jobIDHashRef,
			   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			   sampleID => $$sampleIDRef,
			   dependencies => 1, 
			   path => ${$parameterHashRef}{"p".$programName}{chain},
			   sbatchFileName => $fileName
			  });
	}
    }
    else {

	&RemoveFilesAtTemp({scriptParameterHashRef => $scriptParameterHashRef,
			    arrayRef => \@{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} },
			    extractArrayRef => \@{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} },
			    FILEHANDLE => $FILEHANDLE,
			    inSampleDirectory => $inSampleDirectory,
			    nrCores => $nrCores,
			    infileTag => $infileTag,
			    fileEnding => "*",
			   });
	return $xargsFileCounter;  #Track the number of created xargs scripts per module
    }
}


sub BWASampe {

##BWASampe
    
##Function : Perform alignment of BWA Aln index reads using BWA sampe.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $infileHashRef, $inDirPathHashRef, $infilesLaneNoEndingHashRef, $infilesBothStrandsNoEndingHashRef, $jobIDHashRef, $sampleID, $alignerOutDir, $programName
##         : $parameterHashRef                  => The parameter hash {REF}
##         : $scriptParameterHashRef            => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef                 => Info on samples and family hash {REF}
##         : $infileHashRef                     => The infiles hash {REF}
##         : $inDirPathHashRef                  => The indirectories path(s) hash {REF}
##         : $infilesLaneNoEndingHashRef        => The infile(s) without the ".ending" {REF}
##         : $infilesBothStrandsNoEndingHashRef => The infile(s) without the ".ending" and strand info {REF}
##         : $jobIDHashRef                      => The jobID hash {REF}
##         : $sampleID                          => The sampleID
##         : $alignerOutDir                     => The alignerOutDir used in the analysis
##         : $programName                       => The program name

    my $parameterHashRef = $_[0];
    my $scriptParameterHashRef = $_[1];
    my $sampleInfoHashRef = $_[2];
    my $infileHashRef = $_[3];
    my $inDirPathHashRef = $_[4];
    my $infilesLaneNoEndingHashRef = $_[5];
    my $infilesBothStrandsNoEndingHashRef = $_[6];
    my $jobIDHashRef = $_[7];
    my $sampleID = $_[8];
    my $alignerOutDir = $_[9];
    my $programName = $_[10];
    
    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time=0;
    my $infileSize;
    my $pairedEndTracker = 0;

    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infilesLaneNoEndingHashRef}{$sampleID} });$infileCounter++) {  #For all files from BWA aln but process in the same command i.e. both reads per align call
	 
	if (${$scriptParameterHashRef}{analysisType} eq "genomes") {
	    
	    $time = 40;  
	}
	else {
	    
	    $time = 20;
	}

	my $nrCores = 2;
	my $sequenceRunMode = ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{File}{${$infilesLaneNoEndingHashRef}{ $sampleID }[$infileCounter]}{SequenceRunType};  #Collect paired-end or single-end sequence run mode

	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
						jobIDHashRef => $jobIDHashRef,
						FILEHANDLE => $FILEHANDLE,
						directoryID => $sampleID,
						programName => $programName,
						programDirectory => lc($alignerOutDir),
						nrofCores => $nrCores,
						processTime => $time,
						tempDirectory => ${$scriptParameterHashRef}{tempDirectory}
					       });
    
	## Assign directories
	my $FASTQinSampleDirectory = ${$inDirPathHashRef}{$sampleID};
	my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $sampleID, "bwa");
	my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $sampleID, "bwa");
	${$parameterHashRef}{"p".$programName}{$sampleID}{inDirectory} = $outSampleDirectory;  #Used downstream

	my $infile = $infile{$sampleID}[$pairedEndTracker]; #For required .fastq file

	## Copies files from source to temporary folder. Loop over files specified by $arrayRef and collects files from $extractArrayRef.
	&MigrateFilesToTemp({scriptParameterHashRef => $scriptParameterHashRef,
			     arrayRef => \@{ ${$infileHashRef}{$sampleID} },
			     extractArrayRef => \@{ ${$infileHashRef}{$sampleID} },
			     FILEHANDLE => $FILEHANDLE,
			     inSampleDirectory => $FASTQinSampleDirectory,
			     nrCores => $nrCores
			    });  #Fastq files
	&MigrateFilesToTemp({scriptParameterHashRef => $scriptParameterHashRef,
			     arrayRef => \@{ ${$infilesBothStrandsNoEndingHashRef}{$sampleID} },
			     extractArrayRef => \@{ ${$infilesBothStrandsNoEndingHashRef}{$sampleID} },
			     FILEHANDLE => $FILEHANDLE,
			     inSampleDirectory => $inSampleDirectory,
			     nrCores => $nrCores,
			     fileEnding => ".sai*",
			    });
	
	## BWA Sampe	
	say $FILEHANDLE "## Aligning reads";
	print $FILEHANDLE "bwa sampe ";
	print $FILEHANDLE q?-r "@RG\t?;
	print $FILEHANDLE q?ID:?.${$infilesLaneNoEndingHashRef}{$sampleID}[$infileCounter].q?\t?;
	print $FILEHANDLE q?SM:?.$sampleID.q?\t?;
	print $FILEHANDLE q?PL:?.${$scriptParameterHashRef}{platForm}.q?" ?;  #Read group header line
	print $FILEHANDLE catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference
	print $FILEHANDLE catfile(${$scriptParameterHashRef}{tempDirectory}, ${$infilesBothStrandsNoEndingHashRef}{$sampleID}[$pairedEndTracker].".sai")." ";  #Read 1

	if ( $sequenceRunMode eq "Paired-end") {

	    $pairedEndTracker = $pairedEndTracker+1;  #Increment to collect correct read 2 from %infile
	    print $FILEHANDLE catfile(${$scriptParameterHashRef}{tempDirectory}, ${$infilesBothStrandsNoEndingHashRef}{$sampleID}[$pairedEndTracker].".sai")." ";  #Read 2
	}

	print $FILEHANDLE catfile(${$scriptParameterHashRef}{tempDirectory}, $infile)." ";  #Fastq read 1
	
	if ( $sequenceRunMode eq "Paired-end") { 

	    print $FILEHANDLE catfile(${$scriptParameterHashRef}{tempDirectory}, ${$infileHashRef}{$sampleID}[$pairedEndTracker])." ";  #Fastq read 2
	}

	say $FILEHANDLE "> ".catfile(${$scriptParameterHashRef}{tempDirectory}, ${$infilesLaneNoEndingHashRef}{$sampleID}[$infileCounter].".sam"), "\n";  #Outfile (SAM)

	## Convert SAM to BAM using samTools view
	say $FILEHANDLE "## Convert SAM to BAM";
	print $FILEHANDLE "samtools view -bS ".catfile(${$scriptParameterHashRef}{tempDirectory}, ${$infilesLaneNoEndingHashRef}{$sampleID}[$infileCounter].".sam")." ";  #Infile (SAM)
	say $FILEHANDLE "> ".catfile(${$scriptParameterHashRef}{tempDirectory}, ${$infilesLaneNoEndingHashRef}{$sampleID}[$infileCounter].".bam"), "\n";  #Outfile (BAM)

	## Copies file from temporary directory.
	say $FILEHANDLE "## Copy file from temporary directory";
	&MigrateFileFromTemp({tempPath => catfile(${$scriptParameterHashRef}{tempDirectory}, ${$infilesLaneNoEndingHashRef}{$sampleID}[$infileCounter].".bam"),
			      filePath => $outSampleDirectory,
			      FILEHANDLE => $FILEHANDLE,
			     });
	say $FILEHANDLE "wait", "\n";

	close($FILEHANDLE);

	if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	    ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{MostCompleteBAM}{Path} = catfile($outSampleDirectory, ${$infilesLaneNoEndingHashRef}{$sampleID}[$infileCounter].".bam");

	    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			   sampleInfoHashRef => $sampleInfoHashRef,
			   jobIDHashRef => $jobIDHashRef,
			   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			   sampleID => $sampleID,
			   dependencies => 3, 
			   path => ${$parameterHashRef}{"p".$programName}{chain},
			   sbatchFileName => $fileName,
			   sbatchScriptTracker => $infileCounter
			  });
	}
	$pairedEndTracker++;
    }
}


sub BWAAln {

##BWAAln
    
##Function : Generates BWA aln index on fastq files.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $infileHashRef, $inDirPathHashRef, $infilesLaneNoEndingHashRef, $infilesBothStrandsNoEndingHashRef, $jobIDHashRef, $sampleID, $alignerOutDir, $programName
##         : $parameterHashRef                  => The parameter hash {REF}
##         : $scriptParameterHashRef            => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef                 => Info on samples and family hash {REF}
##         : $infileHashRef                     => The infiles hash {REF}
##         : $inDirPathHashRef                  => The indirectories path(s) hash {REF}
##         : $infilesLaneNoEndingHashRef        => The infile(s) without the ".ending" {REF}
##         : $infilesBothStrandsNoEndingHashRef => The infile(s) without the ".ending" and strand info {REF}
##         : $jobIDHashRef                      => The jobID hash {REF}
##         : $sampleID                          => The sampleID
##         : $alignerOutDir                     => The alignerOutDir used in the analysis
##         : $programName                       => The program name

    my $parameterHashRef = $_[0];
    my $scriptParameterHashRef = $_[1];
    my $sampleInfoHashRef = $_[2];
    my $infileHashRef = $_[3];
    my $inDirPathHashRef = $_[4];
    my $infilesLaneNoEndingHashRef = $_[5];
    my $infilesBothStrandsNoEndingHashRef = $_[6];
    my $jobIDHashRef = $_[7];
    my $sampleID = $_[8];
    my $alignerOutDir = $_[9];
    my $programName = $_[10];

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = ceil(2.5*scalar( @{ ${$infilesLaneNoEndingHashRef}{$sampleID} }));  #One full lane on Hiseq takes approx. 2,5 h for BWAAln to process, round up to nearest full hour.
    my $nrCores = 0;

    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infilesLaneNoEndingHashRef}{$sampleID} });$infileCounter++) {  #For all files   

	my $infileRef = \${$infilesLaneNoEndingHashRef}{ $sampleID }[$infileCounter];  #Alias

	## Adjust the number of cores to be used in the analysis according to sequencing mode requirements.
	&AdjustNrCoresToSeqMode({nrCoresRef => \$nrCores,
				 sequenceRunTypeRef => \${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{File}{$$infileRef}{SequenceRunType},
				});
    }

    ## Set the number of cores to allocate per sbatch job.
    $nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
				    nrCores => $nrCores,
				   });  #Make sure that the number of cores does not exceed maximum after incrementing above

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $sampleID,
					    programName => $programName,
					    programDirectory => lc($alignerOutDir),
					    nrofCores => $nrCores,
					    processTime => $time,
					    tempDirectory => ${$scriptParameterHashRef}{tempDirectory}
					   });

    ## Assign directories
    my $inSampleDirectory =  ${$inDirPathHashRef}{$sampleID};
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $sampleID, lc($alignerOutDir));
    ${$parameterHashRef}{"p".$programName}{$sampleID}{inDirectory} = $outSampleDirectory;  #Used downstream

    my $coreCounter=1;    

    ## Copies files from source to temporary folder. Loop over files specified by $arrayRef and collects files from $extractArrayRef
    &MigrateFilesToTemp({scriptParameterHashRef => $scriptParameterHashRef,
			 arrayRef => \@{ ${$infileHashRef}{$sampleID} },
			 extractArrayRef => \@{ ${$infileHashRef}{$sampleID} },
			 FILEHANDLE => $FILEHANDLE,
			 inSampleDirectory => $inSampleDirectory,
			 nrCores => $nrCores,
			});

    ## BWA Aln
    say $FILEHANDLE "## Creating .sai index";
    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infileHashRef}{$sampleID} });$infileCounter++) {

	&PrintWait({counterRef => \$infileCounter,
		    nrCoresRef => \$nrCores,
		    coreCounterRef => \$coreCounter,
		    FILEHANDLE => $FILEHANDLE,
		   });

	my $infile = ${$infileHashRef}{$sampleID}[$infileCounter];

	print $FILEHANDLE "bwa aln ";
	print $FILEHANDLE "-k 1 ";  #maximum differences in the seed
	print $FILEHANDLE "-t 4 ";  #number of threads
	print $FILEHANDLE "-n 3 ";  #max diff (int) or missing prob under 0.02 err rate (float)
	print $FILEHANDLE "-q ".${$scriptParameterHashRef}{bwaAlnQualityTrimming}." ";  #Quality trimming
	print $FILEHANDLE catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference
	print $FILEHANDLE catfile(${$scriptParameterHashRef}{tempDirectory}, $infile)." ";  #InFile
	say $FILEHANDLE "> ".catfile(${$scriptParameterHashRef}{tempDirectory}, ${$infilesBothStrandsNoEndingHashRef}{$sampleID}[$infileCounter].".sai")." &\n";  #OutFile 
    }
    say $FILEHANDLE "wait", "\n";

    ## Copies files from temporary folder to source. Loop over files specified by $arrayRef and collects files from $extractArrayRef.
    &MigrateFilesFromTemp({arrayRef => \@{ ${$infilesBothStrandsNoEndingHashRef}{$sampleID} },
			   extractArrayRef => \@{ ${$infilesBothStrandsNoEndingHashRef}{$sampleID} },
			   outSampleDirectory => $outSampleDirectory,
			   tempDirectory => ${$scriptParameterHashRef}{tempDirectory},
			   nrCores => $nrCores,
			   fileEnding => ".sai",
			   FILEHANDLE => $FILEHANDLE,
			  });
    
    close($FILEHANDLE);

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {   

	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       sampleID => $sampleID,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}

sub PicardToolsMergeRapidReads { 

##PicardToolsMergeRapidReads
    
##Function : Merges all batch read processes to one file using PicardTools MergeSamFiles within each sampleid. The read batch proccessed files have to be sorted before attempting to merge.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $sampleID, $alignerOutDir, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleIDRef                => The sampleID
##         : $alignerOutDirRef           => The alignerOutDir used in the analysis
##         : $programName                => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $programName = ${$argHashRef}{programName};
    
    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} },  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{$$sampleIDRef},  #Any MIP mandatory key will do
			     sampleIDRef => $$sampleIDRef,
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$sampleIDRef,
					    programName => $programName,
					    programDirectory => lc($$alignerOutDirRef),
					    nrofCores => ${$scriptParameterHashRef}{maximumCores},
					    processTime => 20,
					   });

    ## Assign directories
    my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef);
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef);

    ## Assign fileTags
    my $infileTag = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{pBwaMem}{fileTag};
    my $outfileTag = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{"p".$programName}{fileTag};

    my $coreCounter=1;
    my $coreTracker=0;  #Required to portion out cores and files before wait and to track the MOS_BU outfiles to correct lane
    
    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} });$infileCounter++) {  #For all files from 
	
	my $infile = ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter];
	my $nrReadBatchProcesses = ${$sampleInfoHashRef}{${$scriptParameterHashRef}{familyID}}{$$sampleIDRef}{${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter]}{pBwaMem}{ReadBatchProcesses}; 

	if ($nrReadBatchProcesses > 0) {  #Check that we have read batch processes to merge

	    &PrintWait({counterRef => \$coreTracker,
			nrCoresRef => \${$scriptParameterHashRef}{maximumCores},
			coreCounterRef => \$coreCounter,
			FILEHANDLE => $FILEHANDLE,
		       });

	    for (my $readBatchProcessesCount=0;$readBatchProcessesCount<$nrReadBatchProcesses;$readBatchProcessesCount++) {
		
		if ($readBatchProcessesCount eq 0) {
		    
		    &JavaCore({FILEHANDLE => $FILEHANDLE,
			       memoryAllocation => "Xmx4g",
			       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
			       javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
			       javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
			      });
		    
		    print $FILEHANDLE "MergeSamFiles ";
		    print $FILEHANDLE "USE_THREADING=TRUE "; #Create a background thread to encode, compress and write to disk the output file
		    print $FILEHANDLE "CREATE_INDEX=TRUE ";  #Create a BAM index when writing a coordinate-sorted BAM file.
		    print $FILEHANDLE "OUTPUT=".catfile($outSampleDirectory, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].$outfileTag.".bam")." ";  #OutFile
		}
		print $FILEHANDLE "INPUT=".catfile($inSampleDirectory, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter]."_".$readBatchProcessesCount.$outfileTag.".bam")." ";  #InFile(s)
	    }
	    say $FILEHANDLE "& ","\n";
	    $coreTracker++;  #Track nr of merge calls for infiles so that wait can be printed at the correct intervals (dependent on ${$scriptParameterHashRef}{maximumCores})
	}
	else {  #Still needs to rename file to be included in potential merge of BAM files in next step
	    
	    &JavaCore({FILEHANDLE => $FILEHANDLE,
		       memoryAllocation => "Xmx4g",
		       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		       javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
		       javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
		      });
	    
	    print $FILEHANDLE "MergeSamFiles ";
	    print $FILEHANDLE "USE_THREADING=TRUE ";  #Create a background thread to encode, compress and write to disk the output file
	    print $FILEHANDLE "CREATE_INDEX=TRUE ";  #Create a BAM index when writing a coordinate-sorted BAM file.
	    print $FILEHANDLE "INPUT=".catfile($inSampleDirectory, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter]."_0".$outfileTag."_rg.bam")." ";  #InFile
	    say $FILEHANDLE "OUTPUT=".catfile($outSampleDirectory, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].$outfileTag.".bam")." &";  #OutFile
	}
    }
    say $FILEHANDLE "wait", "\n";
    
    say $FILEHANDLE "## Remove Temp Directory";
    print $FILEHANDLE "rm ";
    say $FILEHANDLE "-rf ".${$scriptParameterHashRef}{tempDirectory}, "\n";  #Remove Temp Directory
    
    close($FILEHANDLE);

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       sampleID => $$sampleIDRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub BWAMem {

##BWAMem
    
##Function : Performs alignment.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infileHashRef, $inDirPathHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $sampleIDRef, $alignerOutDirRef, $programName
##         : $parameterHashRef                  => The parameter hash {REF}
##         : $scriptParameterHashRef            => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef                 => Info on samples and family hash {REF}
##         : $fileInfoHashRef                   => The file info hash {REF}
##         : $infileHashRef                     => The infiles hash {REF}
##         : $inDirPathHashRef                  => The indirectories path(s) hash {REF}
##         : $infilesLaneNoEndingHashRef        => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef                      => The jobID hash {REF}
##         : $sampleIDRef                       => The sampleID {REF}
##         : $alignerOutDirRef                  => The alignerOutDir used in the analysis {REF}
##         : $programName                       => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infileHashRef = ${$argHashRef}{infileHashRef};
    my $inDirPathHashRef = ${$argHashRef}{inDirPathHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $programName = ${$argHashRef}{programName};
    
    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} },  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infileHashRef => ${$infileHashRef}{$$sampleIDRef}, #Any MIP mandatory key will do
			     inDirPathHashRef => ${$inDirPathHashRef}{$$sampleIDRef}, #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{$$sampleIDRef},  #Any MIP mandatory key will do
			     sampleIDRef => $$sampleIDRef,
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 30;
    my $infileSize;
    my $totalSbatchCounter = 0;
    my $pairedEndTracker = 0;

    my $outfileTag = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{"p".$programName}{fileTag};

    ## Collect fastq file(s) size
    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} });$infileCounter++) {  #For all infiles but process in the same command i.e. both reads per align call
	
	my $sequenceRunMode = ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{File}{${$infilesLaneNoEndingHashRef}{ $$sampleIDRef }[$infileCounter]}{SequenceRunType};  #Collect paired-end or single-end sequence run mode
	
	## Fastq.gz
	if (${$infileHashRef}{$$sampleIDRef}[$infileCounter] =~/.fastq.gz$/) {  #Files are already gz and presently the scalar for compression has not been investigated. Therefore no automatic time allocation can be performed.
	
	    if (${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{File}{${$infilesLaneNoEndingHashRef}{ $$sampleIDRef }[$infileCounter]}{SequenceRunType} eq "Paired-end") {  #Second read direction if present
                $infileSize = -s catfile(${$inDirPathHashRef}{$$sampleIDRef}, ${$infileHashRef}{$$sampleIDRef}[$infileCounter+$infileCounter]);
	    }
	    else {  #Single-end

                $infileSize = -s catfile(${$inDirPathHashRef}{$$sampleIDRef}, ${$infileHashRef}{$$sampleIDRef}[$infileCounter]);
	    }
        }
        else {  #Files are in fastq format
	    
	    if (${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{File}{${$infilesLaneNoEndingHashRef}{ $$sampleIDRef }[$infileCounter]}{SequenceRunType} eq "Paired-end") {  #Second read direction if present        

		$infileSize = -s catfile(${$inDirPathHashRef}{$$sampleIDRef}, ${$infileHashRef}{$$sampleIDRef}[$infileCounter+$infileCounter]);  # collect .fastq file size to enable estimation of time required for aligning, +1 for syncing multiple infiles per sampleID. Hence, filesize will be calculated on read2 (should not matter).
	    }
	    else {  #Single-end

                $infileSize = -s catfile(${$inDirPathHashRef}{$$sampleIDRef}, ${$infileHashRef}{$$sampleIDRef}[$infileCounter]);
	    }
        }

	## Parallelize alignment by spliting of alignmnet processes as the files are read
	if (${$scriptParameterHashRef}{analysisType} eq "rapid") {
	    
	    my $seqLength = ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{File}{${$infilesLaneNoEndingHashRef}{ $$sampleIDRef }[$infileCounter]}{SequenceLength};
	    my ($numberNodes, $ReadNrofLines) = &DetermineNrofRapidNodes($seqLength, $infileSize);
	    
	    for (my $sbatchCounter=0;$sbatchCounter<$numberNodes-1;$sbatchCounter++) {  #Parallization for each file handled
		
		## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
		my ($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
									  jobIDHashRef => $jobIDHashRef,
									  FILEHANDLE => $FILEHANDLE,
									  directoryID => $$sampleIDRef,
									  programName => $programName,
									  programDirectory => lc($$alignerOutDirRef),
									  nrofCores => ${$scriptParameterHashRef}{maximumCores},
									  processTime => $time,
									 });
		my ($volume, $directories, $stderrFile) = File::Spec->splitpath($programInfoPath.".stderr.txt");  #Split to enable submission to &SampleInfoQC later

		my $readStart = $sbatchCounter *  $ReadNrofLines;  #Constant for gz files
		my $readStop = $readStart + ceil( $ReadNrofLines + 1);  #Constant for gz files	

		## Assign directories
		my $BWAinSampleDirectory = ${$inDirPathHashRef}{$$sampleIDRef};
		my $BWAoutSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef);
		${$parameterHashRef}{"p".$programName}{$$sampleIDRef}{inDirectory} = $BWAoutSampleDirectory;  #Used downstream

		my $infile;

		if ($sequenceRunMode eq "Paired-end") {  #Second read direction if present
	
		    $infile = ${$infileHashRef}{$$sampleIDRef}[$infileCounter+$infileCounter];  #For required .fastq file
                }
                else {  #Single-end
		    
		    $infile = ${$infileHashRef}{$$sampleIDRef}[$infileCounter];  #For required .fastq file
                }
		
		## BWA Mem for each read batch	
		print $FILEHANDLE "bwa mem ";
		print $FILEHANDLE "-M ";  #Mark shorter split hits as secondary (for Picard compatibility). 
		print $FILEHANDLE "-t ".${$scriptParameterHashRef}{maximumCores}." ";  #Number of threads

		## Read group header line
		print $FILEHANDLE q?-R "@RG\t?;
		print $FILEHANDLE q?ID:?.${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].q?\t?;
		print $FILEHANDLE q?SM:?.$$sampleIDRef.q?\t?;
		print $FILEHANDLE q?PL:?.${$scriptParameterHashRef}{platForm}.q?" ?;

		print $FILEHANDLE catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference
		print $FILEHANDLE "<( ";  #Pipe to BWA Mem (Read 1)
		print $FILEHANDLE "zcat ";  #Decompress Read 1
		print $FILEHANDLE catfile($BWAinSampleDirectory, $infile)." ";  #Read 1
		print $FILEHANDLE "| ";  #Pipe
		print $FILEHANDLE q?perl -ne 'if ( ($.>?.$readStart.q?) && ($.<?.$readStop.q?) ) {print $_;}' ?;  #Limit to sbatch script interval
		print $FILEHANDLE ") ";  #End Read 1

		if ($sequenceRunMode eq "Paired-end") {  #Second read direction if present
		      
		    print $FILEHANDLE "<( ";  #Pipe to BWA Mem (Read 2)
		    print $FILEHANDLE "zcat ";  #Decompress Read 2
		    print $FILEHANDLE catfile($BWAinSampleDirectory, ${$infileHashRef}{$$sampleIDRef}[$infileCounter+$infileCounter+1])." ";  #Read 2
		    print $FILEHANDLE "| ";  #Pipe
		    print $FILEHANDLE q?perl -ne 'if ( ($.>?.$readStart.q?) && ($.<?.$readStop.q?) ) {print $_;}' ?;  #Limit to sbatch script interval
		    print $FILEHANDLE ") ";  #End Read 2
		}

		print $FILEHANDLE "| ";  #Pipe SAM to BAM conversion of aligned reads
		print $FILEHANDLE "samtools view "; 
		print $FILEHANDLE "-S ";  #Input is SAM
		print $FILEHANDLE "-h ";  #Print header for the SAM output
		print $FILEHANDLE "-u ";  #Uncompressed BAM output
		print $FILEHANDLE "- ";  #/dev/stdin
		print $FILEHANDLE "| ";  #Pipe
		print $FILEHANDLE "intersectBed ";  #Limit output to only clinically interesting genes
		print $FILEHANDLE "-abam stdin ";  #The A input file is in BAM format.  Output will be BAM as well.
		print $FILEHANDLE "-b ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{bwaMemRapidDb})." ";  #Db file of clinically relevant variants
		say $FILEHANDLE "> ".catfile($BWAoutSampleDirectory, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter]."_".$sbatchCounter.".bam"), "\n";  #Outfile (BAM)
		
		print $FILEHANDLE "samtools sort ";
		print $FILEHANDLE catfile($BWAoutSampleDirectory, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter]."_".$sbatchCounter.".bam")." ";  #Infile
		say $FILEHANDLE catfile($BWAoutSampleDirectory, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter]."_".$sbatchCounter.$outfileTag), "\n";  #OutFile

		print $FILEHANDLE "samtools index ";
		say $FILEHANDLE catfile($BWAoutSampleDirectory, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter]."_".$sbatchCounter.$outfileTag.".bam"), "\n";  #OutFile

		close($FILEHANDLE);

		if ( (${$scriptParameterHashRef}{pBwaMem} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

		    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
				   sampleInfoHashRef => $sampleInfoHashRef,
				   jobIDHashRef => $jobIDHashRef,
				   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
				   sampleID => $$sampleIDRef,
				   dependencies => 3, 
				   path => ${$parameterHashRef}{"p".$programName}{chain},
				   sbatchFileName => $fileName,
				   sbatchScriptTracker => $totalSbatchCounter
				  });
		}
		$totalSbatchCounter++;

                ## Save sbatch Counter to track how many read batch processes we have engaged
		${$sampleInfoHashRef}{${$scriptParameterHashRef}{familyID}}{$$sampleIDRef}{${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter]}{pBwaMem}{ReadBatchProcesses} = $sbatchCounter+1;  #Used to be  $sbatchCounter
		${$sampleInfoHashRef}{${$scriptParameterHashRef}{familyID}}{$$sampleIDRef}{pBwaMem}{sbatchBatchProcesses} = $totalSbatchCounter;
	    }
	}
	else {  #Not rapid mode align whole file

	    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	    my ($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
								      jobIDHashRef => $jobIDHashRef,
								      FILEHANDLE => $FILEHANDLE,
								      directoryID => $$sampleIDRef,
								      programName => $programName,
								      programDirectory => lc($$alignerOutDirRef),
								      nrofCores => ${$scriptParameterHashRef}{maximumCores},
								      processTime => $time,
								      tempDirectory => $$tempDirectoryRef,
								     });
	    my ($volume, $directories, $stderrFile) = File::Spec->splitpath($programInfoPath.".stderr.txt");  #Split to enable submission to &SampleInfoQC later

	    ## Assign directories
	    my $inSampleDirectory = ${$inDirPathHashRef}{$$sampleIDRef};
	    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef);
	    ${$parameterHashRef}{"p".$programName}{$$sampleIDRef}{inDirectory} = $outSampleDirectory;  #Used downstream
	    
	    ## Copies file to temporary directory.
	    say $FILEHANDLE "## Copy file(s) to temporary directory"; 
	    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
				path => catfile($inSampleDirectory, ${$infileHashRef}{$$sampleIDRef}[$pairedEndTracker]),
				tempDirectory => $$tempDirectoryRef,
			       });  #Read 1
	    if ($sequenceRunMode eq "Paired-end") {  #Second read direction if present
		
		&MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
				    path => catfile($inSampleDirectory, ${$infileHashRef}{$$sampleIDRef}[$pairedEndTracker+1]),
				    tempDirectory => $$tempDirectoryRef,
				   });  #Read 2
	    }
	    say $FILEHANDLE "wait", "\n";

	    ### BWA MEM

	    ##Detect version and source of the humanGenomeReference: Source (hg19 or GRCh) and return the correct BwaMem binary
	    my $bwaBinary = &SelectBwaMemBinary({humanGenomeReferenceSourceRef => \${$fileInfoHashRef}{humanGenomeReferenceSource},
						 humanGenomeReferenceVersionRef => \${$fileInfoHashRef}{humanGenomeReferenceVersion},
						});

	    say $FILEHANDLE "## Aligning reads and sorting via Sambamba";	    
	    
	    print $FILEHANDLE $bwaBinary." ";

	    if ($bwaBinary eq "bwa mem") {  #Prior to ALTs in refrence genome

		print $FILEHANDLE "-M ";  #Mark shorter split hits as secondary (for Picard compatibility). 
	    }
	    else {

		if (${$scriptParameterHashRef}{bwaMemHLA} == 1) {

		    print $FILEHANDLE "-H ";  #Apply HLA typing
		}
		print $FILEHANDLE "-o ".catfile($$tempDirectoryRef, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter])." ";  #prefix for output files
	    }
	    print $FILEHANDLE "-t ".${$scriptParameterHashRef}{maximumCores}." ";  #Number of threads
	    print $FILEHANDLE q?-R "@RG\t?;
	    print $FILEHANDLE q?ID:?.${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].q?\t?;
	    print $FILEHANDLE q?SM:?.$$sampleIDRef.q?\t?;
	    print $FILEHANDLE q?PL:?.${$scriptParameterHashRef}{platForm}.q?" ?;  #Read group header line
	    print $FILEHANDLE catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference
	    print $FILEHANDLE catfile($$tempDirectoryRef, ${$infileHashRef}{$$sampleIDRef}[$pairedEndTracker])." ";  #Read 1

	    if ($sequenceRunMode eq "Paired-end") {  #Second read direction if present

		$pairedEndTracker = $pairedEndTracker+1;  #Increment to collect correct read 2 from %infile 
		print $FILEHANDLE catfile($$tempDirectoryRef, ${$infileHashRef}{$$sampleIDRef}[$pairedEndTracker])." ";  #Read 2
	    }
	    $pairedEndTracker++;

	    if ($bwaBinary eq "bwa mem") {  #Prior to ALTs in refrence genome

		print $FILEHANDLE "| ";  #Pipe SAM to BAM conversion of aligned reads
		print $FILEHANDLE "samtools view "; 
		print $FILEHANDLE "-S ";  #Input is SAM
		print $FILEHANDLE "-h ";  #Print header for the SAM output
		print $FILEHANDLE "-u ";  #Uncompressed BAM output
		print $FILEHANDLE "-@ ".${$scriptParameterHashRef}{maximumCores}." ";  #Number of threads 
		print $FILEHANDLE "- ";  #/dev/stdin
		print $FILEHANDLE "| ";
	    }
	    else {
	
		print $FILEHANDLE "| ";
		print $FILEHANDLE "sh ";
		say $FILEHANDLE "\n";
	    }
	    
	    print $FILEHANDLE "sambamba ";  #Program
	    print $FILEHANDLE "sort ";  #Command
	    print $FILEHANDLE "-m ".${$scriptParameterHashRef}{bwaSambambaSortMemoryLimit}." ";  #Memory limit
	    print $FILEHANDLE "--tmpdir=".$$tempDirectoryRef." ";  #Directory for storing intermediate files
	    print $FILEHANDLE "--show-progress ";  #Show progressbar in STDERR
	    print $FILEHANDLE "--out=".catfile($$tempDirectoryRef, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].$outfileTag.".bam")." ";  #Outfile

	    if ($bwaBinary eq "bwa mem") {  #Pipe from samtools view

		say $FILEHANDLE catfile(dirname(devnull()),"stdin"),"\n";

		## BAMS, HLA files BWAMem logs etc.
		&MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].".*"),
				      filePath => $outSampleDirectory,
				      FILEHANDLE => $FILEHANDLE,
				     });
		say $FILEHANDLE "wait", "\n";
	    }
	    else {  #Sort directly from run-bwakit

		say $FILEHANDLE catfile($$tempDirectoryRef, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].".aln.bam"), "\n";
		    
		## Copies file from temporary directory.
		say $FILEHANDLE "## Copy file from temporary directory";
		&MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].$outfileTag.".b*"),
				      filePath => $outSampleDirectory,
				      FILEHANDLE => $FILEHANDLE,
				     });
		say $FILEHANDLE "wait", "\n";
	    }

	    if (${$scriptParameterHashRef}{bwaMembamStats} == 1) {

		print $FILEHANDLE "samtools stats ";
		print $FILEHANDLE catfile($$tempDirectoryRef, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].$outfileTag.".bam")." ";
		print $FILEHANDLE "| "; 
		print $FILEHANDLE q?perl -ne '$raw; $map; chomp($_); print $_, "\n"; if($_=~/raw total sequences:\s+(\d+)/) {$raw = $1;} elsif($_=~/reads mapped:\s+(\d+)/) {$map = $1; $p = ($map / $raw ) * 100; print "percentag mapped reads:\t".$p."\n"}' ?;
		say $FILEHANDLE "> ".catfile($$tempDirectoryRef, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].$outfileTag.".stats")." ", "\n";

		## Copies file from temporary directory.
		say $FILEHANDLE "## Copy file from temporary directory";
		&MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].$outfileTag.".stats"),
				      filePath => $outSampleDirectory,
				      FILEHANDLE => $FILEHANDLE,
				     });
		say $FILEHANDLE "wait", "\n";
	    }

	    if (${$scriptParameterHashRef}{bwaMemCram} == 1) {

		say $FILEHANDLE "## Create CRAM file from BAM";
		print $FILEHANDLE "sambamba ";  #Program
		print $FILEHANDLE "view ";  #Commmand
		print $FILEHANDLE "-f cram "; #Write output to CRAM-format
		print $FILEHANDLE "-h ";  #print header before reads
		print $FILEHANDLE "-T ".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference
		print $FILEHANDLE "--output-filename ".catfile($$tempDirectoryRef, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].$outfileTag.".cram")." ";
		say $FILEHANDLE catfile($$tempDirectoryRef, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].$outfileTag.".bam"), "\n";
		
		## Copies file from temporary directory.
		say $FILEHANDLE "## Copy file from temporary directory";
		&MigrateFileFromTemp({tempPath => catfile($$tempDirectoryRef, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].$outfileTag.".cram"),
				      filePath => $outSampleDirectory,
				      FILEHANDLE => $FILEHANDLE,
				     });
		say $FILEHANDLE "wait", "\n";
	    }
	    
	    close($FILEHANDLE);

	    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

		${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{MostCompleteBAM}{Path} = catfile($outSampleDirectory, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].".bam");

		if (${$scriptParameterHashRef}{bwaMemCram} eq 1) {

		    ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{Program}{Bwa}{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter]}{Path} = catfile($outSampleDirectory, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].$outfileTag.".cram");  #Required for analysisRunStatus check downstream
		    ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{File}{${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter]}{CramFile} = catfile($outSampleDirectory, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].$outfileTag.".cram");  #Fastreference to cram file
		}
		if (${$scriptParameterHashRef}{bwaMembamStats} == 1) {

		    if (! ${$fileInfoHashRef}{undeterminedInFileName}{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter] } ) {  #Do not add to SampleInfo and hence skip test of "UndeterminedInFileName" files in QCCollect

			## Collect QC metadata info for later use
			&SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
				       familyID => ${$scriptParameterHashRef}{familyID},
				       sampleID => $$sampleIDRef,
				       programName => "BamStats",
				       infile => ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter],
				       outDirectory => $outSampleDirectory,
				       outfileEnding => $outfileTag.".stats",
				       outDataType => "infileDependent"
				      });
		    }
		}

		if ($bwaBinary eq "bwa mem") {

		    &SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
				   familyID => ${$scriptParameterHashRef}{familyID},
				   sampleID => $$sampleIDRef,
				   programName => "Bwa",
				   infile => ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter],
				   outDirectory => $directories,
				   outfileEnding => $outfileTag.".log.bwa",
				   outDataType => "infileDependent"
				  });
		}
		else {

		    &SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
				   familyID => ${$scriptParameterHashRef}{familyID},
				   sampleID => $$sampleIDRef,
				   programName => "Bwa",
				   infile => ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter],
				   outDirectory => $directories,
				   outfileEnding => $stderrFile,
				   outDataType => "infoDirectory"
				  });
		}
		&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			       sampleInfoHashRef => $sampleInfoHashRef,
			       jobIDHashRef => $jobIDHashRef,
			       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			       sampleID => $$sampleIDRef,
			       dependencies => 3, 
			       path => ${$parameterHashRef}{"p".$programName}{chain},
			       sbatchFileName => $fileName,
			       sbatchScriptTracker => $infileCounter
			      });
	    }
	}
    }
}


sub MosaikAlign {

##MosaikAlign
    
##Function : Performs alignment.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infileHashRef, $inDirPathHashRef, $infilesLaneNoEndingHashRef, $sampleID, $alignerOutDir, $programName
##         : $parameterHashRef                  => The parameter hash {REF}
##         : $scriptParameterHashRef            => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef                 => Info on samples and family hash {REF}
##         : $fileInfoHashRef                   => The file info hash {REF}
##         : $infileHashRef                     => The infiles hash {REF}
##         : $inDirPathHashRef                  => The indirectories path(s) hash {REF}
##         : $infilesLaneNoEndingHashRef        => The infile(s) without the ".ending" {REF}
##         : $sampleID                          => The sampleID
##         : $alignerOutDir                     => The alignerOutDir used in the analysis
##         : $programName                       => The program name

    my $parameterHashRef = $_[0];
    my $scriptParameterHashRef = $_[1];
    my $sampleInfoHashRef = $_[2];
    my $fileInfoHashRef = $_[3];
    my $infileHashRef = $_[4];
    my $inDirPathHashRef = $_[5];
    my $infilesLaneNoEndingHashRef = $_[6];
    my $jobIDHashRef = $_[7];
    my $sampleID = $_[8];
    my $alignerOutDir = $_[9];
    my $programName = $_[10];
    
    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $sbatchScriptTracker=0;
    my $time=0;
    my $infileSize;

    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infilesLaneNoEndingHashRef}{$sampleID} });$infileCounter++) {  #For all infiles per lane
	   
	if (${$scriptParameterHashRef}{analysisType} eq "genomes") {
	    
	    $time = 80;  
	}
	else {
	    
	    $time = 40;
	}

	my $infile = ${$infilesLaneNoEndingHashRef}{$sampleID}[$infileCounter];

	## Set parameters depending on sequence length
	my $seqLength = ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{File}{$infile}{SequenceLength};
	my $actParameter = 35;  #The alignment candidate threshold (length)
	my $bwParameter = 35;  #Specifies the Smith-Waterman bandwidth.

	if ($seqLength <= 36) {
	    
	    $actParameter = 20;
	    $bwParameter = 13;   
	}
	if ($seqLength > 36 && $seqLength <= 51) {
	    
	    $actParameter = 25;
	    $bwParameter = 21;   
	}
	if ($seqLength > 51 && $seqLength <= 76) {
	    
	    $bwParameter = 29;   
	}

	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	my ($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
								  jobIDHashRef => $jobIDHashRef,
								  FILEHANDLE => $FILEHANDLE,
								  directoryID => $sampleID,
								  programName => $programName,
								  programDirectory => lc($alignerOutDir),
								  nrofCores => ${$scriptParameterHashRef}{maximumCores},
								  processTime => $time,
								  tempDirectory => ${$scriptParameterHashRef}{tempDirectory}
								 });
	my ($volume, $directories, $stdoutfile) = File::Spec->splitpath($programInfoPath."stdout.txt");  #Split to enable submission to &SampleInfoQC later

	## Assign directories
	my $inSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $sampleID, $alignerOutDir);
	my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $sampleID, $alignerOutDir);
	${$parameterHashRef}{"p".$programName}{$sampleID}{inDirectory} = $outSampleDirectory;  #Used downstream
	my $outfileTag = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{"p".$programName}{fileTag};

	## Copies file to temporary directory.
	say $FILEHANDLE "## Copy file to node"; 
	&MigrateFileToTemp({FILEHANDLE => $FILEHANDLE, 
			    path => catfile($inSampleDirectory, $infile.".dat"),
			    tempDirectory => ${$scriptParameterHashRef}{tempDirectory}
			   });
	say $FILEHANDLE "wait", "\n";
	
	## MosaikAlign
	say $FILEHANDLE "## Create node temporary MOSAIK directory";
	say $FILEHANDLE "mkdir -p ".catfile(${$scriptParameterHashRef}{tempDirectory}, "mosaik_tmp");
	say $FILEHANDLE "export MOSAIK_TMP=".catfile(${$scriptParameterHashRef}{tempDirectory}, "mosaik_tmp"), "\n";

	say $FILEHANDLE "## Generating .bam file from .dat files";
	print $FILEHANDLE "MosaikAligner ";
	print $FILEHANDLE "-ia ".catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{mosaikAlignReference})." ";  #Mosaik Reference
	print $FILEHANDLE "-annse ".catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{mosaikAlignNeuralNetworkSeFile})." ";  #NerualNetworkSE

	if (${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{File}{${$infilesLaneNoEndingHashRef}{ $sampleID }[$infileCounter]}{SequenceRunType} eq "Paired-end") {  #Second read direction if present

	    print $FILEHANDLE "-annpe ".catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{mosaikAlignNeuralNetworkPeFile})." ";  #NerualNetwork
	    print $FILEHANDLE "-ls 100 "; #Enable local alignment search for PE reads
	}

	print $FILEHANDLE "-p ".${$scriptParameterHashRef}{maximumCores}." ";  #Nr of cores
	print $FILEHANDLE "-hs 15 ";  #Hash size
	print $FILEHANDLE "-mm 4 ";  #The # of mismatches allowed
	print $FILEHANDLE "-mhp 100 "; #The maximum of positions stored per seed
	print $FILEHANDLE "-act ".$actParameter." ";  #The alignment candidate threshold (length)
	print $FILEHANDLE "-bw ".$bwParameter." ";  #Specifies the Smith-Waterman bandwidth.
	print $FILEHANDLE "-j ".catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{mosaikJumpDbStub})." ";  #JumpDatabase
	print $FILEHANDLE "-in ".catfile(${$scriptParameterHashRef}{tempDirectory}, $infile.".dat")." ";  #Infile
	say $FILEHANDLE "-out ".catfile(${$scriptParameterHashRef}{tempDirectory}, $infile)." ";  #OutFile (MosaikAligner appends .bam to infile name)

	## BAM to SAM conversion and sorting/indexing. Make sure that the BAM file BIN field is correct (Mosaik v.2.2.3 does according to Picard not set the bin field correctly)
	say $FILEHANDLE "## BAM to SAM";
	&JavaCore({FILEHANDLE => $FILEHANDLE,
		   memoryAllocation => "Xmx2g",
		   javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		   javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
		   javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
		  });
	
	print $FILEHANDLE "SamFormatConverter ";
	print $FILEHANDLE "VALIDATION_STRINGENCY=SILENT ";  #Disable errors print
	print $FILEHANDLE "INPUT=".catfile(${$scriptParameterHashRef}{tempDirectory}, $infile.".bam")." ";  #InFile
	say $FILEHANDLE "OUTPUT=".catfile(${$scriptParameterHashRef}{tempDirectory}, $infile.".sam")." "; #OutFile

	## SAM to BAM conversion
	say $FILEHANDLE "## SAM to BAM";
	&JavaCore({FILEHANDLE => $FILEHANDLE,
		   memoryAllocation => "Xmx2g",
		   javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		   javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
		   javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
		  });

	print $FILEHANDLE "SamFormatConverter ";
	print $FILEHANDLE "INPUT=".catfile(${$scriptParameterHashRef}{tempDirectory}, $infile.".sam")." ";  #InFile
	say $FILEHANDLE "OUTPUT=".catfile(${$scriptParameterHashRef}{tempDirectory}, $infile.".bam")." ";  #OutFile

	## Sort BAM
	say $FILEHANDLE "## Sort BAM";
	&JavaCore({FILEHANDLE => $FILEHANDLE,
		   memoryAllocation => "Xmx4g",
		   javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		   javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
		   javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
		  });
	
	print $FILEHANDLE "SortSam ";
	print $FILEHANDLE "SORT_ORDER=coordinate ";  #Sort per contig and coordinate
	print $FILEHANDLE "CREATE_INDEX=TRUE ";  #create a BAM index when writing a coordinate-sorted BAM file. 
	print $FILEHANDLE "INPUT=".catfile(${$scriptParameterHashRef}{tempDirectory}, $infile.".bam")." ";  #InFile
	say $FILEHANDLE "OUTPUT=".catfile(${$scriptParameterHashRef}{tempDirectory}, $infile.$outfileTag.".bam");  #Outfile

	if (${$scriptParameterHashRef}{genomicSet} ne "noUserInfo") {

	    ## Create Bedtools genome file
	    say $FILEHANDLE "## Create Bedtools genome file";
	    print $FILEHANDLE "cut -f1-2 ".catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{humanGenomeReference}.".fai")." ";  #Contig name and length
	    say $FILEHANDLE "> ".catfile(${$scriptParameterHashRef}{tempDirectory}, "bedtools_genome_file.txt")." ";  #Bedtool genome file

	    ## Select alignment mapping to genetic regions
	    say $FILEHANDLE "## Select alignment mapping to genetic regions";
	    print $FILEHANDLE "bedtools intersect ";
	    print $FILEHANDLE "-abam ".catfile(${$scriptParameterHashRef}{tempDirectory}, $infile.$outfileTag.".bam")." ";
	    print $FILEHANDLE "-b ".catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{genomicSet})." ";
	    print $FILEHANDLE "-wa ";
	    print $FILEHANDLE "-sorted ";
	    print $FILEHANDLE "-g ".catfile(${$scriptParameterHashRef}{tempDirectory}, "bedtools_genome_file.txt")." ";  #Bedtool genome file
	    say $FILEHANDLE "> ".catfile(${$scriptParameterHashRef}{tempDirectory}, $infile.$outfileTag."_genetic_regions.bam")." ";  #TempFile
	    
	    ## Move to final file name
	    say $FILEHANDLE "## Move to final file name";
	    print $FILEHANDLE "mv ";
	    print $FILEHANDLE catfile(${$scriptParameterHashRef}{tempDirectory}, $infile.$outfileTag."_genetic_regions.bam")." ";  #TempFile
	    say $FILEHANDLE catfile(${$scriptParameterHashRef}{tempDirectory}, $infile.$outfileTag.".bam")." ";  #OutFile
	    
	    ## Writes java core commands to filehandle.
	    &JavaCore({FILEHANDLE => $FILEHANDLE,
		       memoryAllocation => "Xmx2g",
		       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		       javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
		       javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
		      }); 
	    
	    print $FILEHANDLE "BuildBamIndex ";
	    say $FILEHANDLE "INPUT=".catfile(${$scriptParameterHashRef}{tempDirectory}, $infile.$outfileTag.".bam")." ";  #OutFile

	    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
		
		## Collect QC metadata info for later use                     	
		${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{MostCompleteBAM}{Path} = catfile($outSampleDirectory, $infile.$outfileTag.".bam");
	    }
	}
	
	## Copies file from temporary directory.
	say $FILEHANDLE "## Copy file from temporary directory";
	&MigrateFileFromTemp({tempPath => catfile(${$scriptParameterHashRef}{tempDirectory}, $infile.$outfileTag.".b*"),
			      filePath => $outSampleDirectory,
			      FILEHANDLE => $FILEHANDLE,
			     });
	&MigrateFileFromTemp({tempPath => catfile(${$scriptParameterHashRef}{tempDirectory}, $infile.".stat"),
			      filePath => $outSampleDirectory,
			      FILEHANDLE => $FILEHANDLE,
			     });
	say $FILEHANDLE "wait", "\n";
	
	close($FILEHANDLE);
	
	if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	    ## Collect QC metadata info for later use                     	
	    &SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
			   familyID => ${$scriptParameterHashRef}{familyID},
			   sampleID => $sampleID,
			   programName => "MosaikAligner",
			   infile => $infile,
			   outDirectory => $directories,
			   outfileEnding => $stdoutfile,
			   outDataType => "infoDirectory"
			  });
	    
	    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			   sampleInfoHashRef => $sampleInfoHashRef,
			   jobIDHashRef => $jobIDHashRef,
			   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			   sampleID => $sampleID,
			   dependencies => 3, 
			   path => ${$parameterHashRef}{"p".$programName}{chain},
			   sbatchFileName => $fileName,
			   sbatchScriptTracker => $sbatchScriptTracker
			  });
	}
	$sbatchScriptTracker++;  #Tracks nr of sbatch scripts
    }
}


sub MosaikBuild {

##MosaikBuild
    
##Function : Generates Mosaik hash format on reads using MosaikBuild
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $infileHashRef, $inDirPathHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $sampleID, $alignerOutDir, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $infileHashRef              => The infiles hash {REF}
##         : $inDirPathHashRef           => The indirectories path(s) hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleID                   => The sampleID
##         : $alignerOutDir              => The alignerOutDir used
##         : $programName                => The program name

    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $infileHashRef = ${$argHashRef}{infileHashRef};
    my $inDirPathHashRef = ${$argHashRef}{inDirPathHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleID};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDir};
    my $programName = ${$argHashRef}{programName};

    my $tempDirectoryRef = \${$scriptParameterHashRef}{tempDirectory};

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 10;
    
    ## Set the number of cores to allocate per sbatch job.
    my $nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
				       nrCores => scalar( @{ ${$laneHashRef}{$$sampleIDRef} } ),
				      });  #Detect the number of cores to use from lanes
    
    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$sampleIDRef,
					    programName => $programName,
					    programDirectory => lc($$alignerOutDirRef),
					    nrofCores => $nrCores,
					    processTime => $time,
					    tempDirectory => $$tempDirectoryRef
					   });
    
    ## Assign directories
    my $inSampleDirectory = ${$inDirPathHashRef}{$$sampleIDRef};
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, $$alignerOutDirRef);
    ${$parameterHashRef}{"p".$programName}{$$sampleIDRef}{inDirectory} = $outSampleDirectory;  ##Used downstream

    my $coreCounter=1;
    my $pairedEndTracker = 0;
    my $stParameter = ${$scriptParameterHashRef}{platForm};
    
    ## Copies files from source to temporary folder. Loop over files specified by $arrayRef and collects files from $extractArrayRef.
    &MigrateFilesToTemp({scriptParameterHashRef => $scriptParameterHashRef,
			 sampleInfoHashRef => $sampleInfoHashRef,
			 arrayRef => \@{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} },
			 extractArrayRef => \@{ ${$infileHashRef}{$$sampleIDRef} },
			 FILEHANDLE => $FILEHANDLE,
			 inSampleDirectory => $inSampleDirectory,
			 nrCores => $nrCores,
			 sampleID => $$sampleIDRef
			});

    ## MosaikBuild
    say $FILEHANDLE "## Generating .dat file from fastq files";    
    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} });$infileCounter++) {  #For all files
	
	my $sequenceRunMode = ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{File}{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter] }{SequenceRunType};  #Collect paired-end or single-end sequence run mode
	my $coreTracker=0;  #Required to portion out cores and files before wait and to track the outfiles to correct lane
	
	&PrintWait({counterRef => \$infileCounter,
		    nrCoresRef => \$nrCores,
		    coreCounterRef => \$coreCounter,
		    FILEHANDLE => $FILEHANDLE,
		   });
	
	print $FILEHANDLE "MosaikBuild ";
	print $FILEHANDLE "-id ".${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter]." ";  #Read group ID for BAM Header
	print $FILEHANDLE "-sam ".$$sampleIDRef." ";  #Sample name for BAM Header
	print $FILEHANDLE "-st ".$stParameter." ";  #Sequencing technology for BAM Header
	print $FILEHANDLE "-mfl ".${$scriptParameterHashRef}{mosaikBuildMedianFragLength}." ";  #Median Fragment Length
	print $FILEHANDLE "-q ".catfile($$tempDirectoryRef, ${$infileHashRef}{$$sampleIDRef}[$pairedEndTracker])." ";  #Read 1
	
	if ( $sequenceRunMode eq "Paired-end") {
    
	    $pairedEndTracker = $pairedEndTracker+1;  #Increment to collect correct read 2 from %infile
	    print $FILEHANDLE "-q2 ".catfile($$tempDirectoryRef, ${$infileHashRef}{$$sampleIDRef}[$pairedEndTracker])." ";  #Read 2
	} 

	$pairedEndTracker++;  #Increment to correctly track both single-end runs and paired-end runs
	say $FILEHANDLE "-out ".catfile($$tempDirectoryRef, ${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter].".dat")." &\n";  #OutFile
    }
    say $FILEHANDLE "wait", "\n";

    ## Copies files from temporary folder to source. Loop over files specified by $arrayRef and collects files from $extractArrayRef.
    &MigrateFilesFromTemp({arrayRef => \@{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} },
			   extractArrayRef => \@{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} },
			   outSampleDirectory => $outSampleDirectory,
			   tempDirectory => $$tempDirectoryRef,
			   nrCores => $nrCores,
			   fileEnding => ".dat",
			   FILEHANDLE => $FILEHANDLE,
			  });
        
    close($FILEHANDLE);
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) { 
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       sampleID => $$sampleIDRef,
		       dependencies => 1, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub VariantAnnotationBlock {

##VariantAnnotationBlock
    
##Function : Run consecutive module 
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $annovarTableHashRef, $alignerOutDirRef, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The file info hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $annovarTableHashRef        => annovarTableHashRef {REF}
##         : $familyIDRef                => The familyID {REF}
##         : $alignerOutDirRef           => The alignerOutDir used {REF}
##         : $programName                => The program name
    
    my ($argHashRef) = @_;
   
    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $annovarTableHashRef = ${$argHashRef}{annovarTableHashRef};
    my $supportedCosmidReferenceHashRef = ${$argHashRef}{supportedCosmidReferenceHashRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     callType => $callType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 80;
    
    ## Set the number of cores to allocate per sbatch job.
    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $xargsFileName;
    
    $logger->info("\t[PrepareForVariantAnnotationBlock]\n");

    if (${$scriptParameterHashRef}{pVT} > 0) {
	
	$logger->info("\t[VT]\n");  #Run VT. Done per family
	
	&CheckBuildHumanGenomePreRequisites({parameterHashRef => $parameterHashRef,
					     scriptParameterHashRef => $scriptParameterHashRef,
					     sampleInfoHashRef => $sampleInfoHashRef,
					     fileInfoHashRef => $fileInfoHashRef,
					     infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
					     jobIDHashRef => $jobIDHashRef,
					     supportedCosmidReferenceHashRef => $supportedCosmidReferenceHashRef,
					     programName => "VT",
					    });
    }
    if (${$scriptParameterHashRef}{pVariantEffectPredictor} > 0) {  #Run VariantEffectPredictor. Done per family
	
	$logger->info("\t[VariantEffectPredictor]\n");
    }
    if (${$scriptParameterHashRef}{pVCFParser} > 0) {  #Run pVCFParser. Done per family

	$logger->info("\t[VCFParser]\n");
    }
    if (${$scriptParameterHashRef}{pAnnovar} > 0) {  #Run Annovar. Done per family
	
	$logger->info("\t[Annovar]\n");
	
	&CheckBuildHumanGenomePreRequisites({parameterHashRef => $parameterHashRef,
					     scriptParameterHashRef => $scriptParameterHashRef,
					     sampleInfoHashRef => $sampleInfoHashRef,
					     fileInfoHashRef => $fileInfoHashRef,
					     infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
					     jobIDHashRef => $jobIDHashRef,
					     supportedCosmidReferenceHashRef => $supportedCosmidReferenceHashRef,
					     programName => "Annovar",
					    });
	
	for (my $tableNamesCounter=0;$tableNamesCounter<scalar(@{ ${$scriptParameterHashRef}{annovarTableNames} });$tableNamesCounter++) {  #For all specified table names
	    
	    if (${$parameterHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{buildFile} eq 1) {

		&BuildAnnovarPreRequisites({parameterHashRef => $parameterHashRef,
					    scriptParameterHashRef => $scriptParameterHashRef,
					    sampleInfoHashRef => $sampleInfoHashRef,
					    infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    annovarTableHashRef => $annovarTableHashRef,
					    programName => "Annovar",
					   });
		last;  #Will handle all build tables within sbatch script
	    }
	}
    }
    if (${$scriptParameterHashRef}{pSnpEff} > 0) {  #Run snpEff. Done per family
	
	$logger->info("\t[SnpEff]\n");
	
	&CheckBuildDownLoadPreRequisites({parameterHashRef => $parameterHashRef,
					  scriptParameterHashRef => $scriptParameterHashRef,
					  sampleInfoHashRef => $sampleInfoHashRef,
					  infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
					  jobIDHashRef => $jobIDHashRef,
					  supportedCosmidReferenceHashRef => $supportedCosmidReferenceHashRef,
					  programName => "SnpEff",
					 });
    }
    if (${$scriptParameterHashRef}{pRankVariants} > 0) { #Run RankVariants. Done per family
	
	$logger->info("\t[RankVariants]\n");
    }
    
    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							      jobIDHashRef => $jobIDHashRef,
							      FILEHANDLE => $FILEHANDLE,
							      directoryID => $$familyIDRef,
							      programName => $programName,
							      programDirectory => lc($$alignerOutDirRef),
							      nrofCores => $nrCores,
							      processTime => $time,
							     });

    ## Copy files for VariantAnnotationBlock to enable restart and skip of modules within block
    ($xargsFileCounter, $xargsFileName) = &PrepareForVariantAnnotationBlock({parameterHashRef => $parameterHashRef,
									     scriptParameterHashRef => $scriptParameterHashRef,
									     sampleInfoHashRef => $sampleInfoHashRef,
									     fileInfoHashRef => $fileInfoHashRef,
									     infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
									     jobIDHashRef => $jobIDHashRef,
									     callType => $callType,
									     programName => "VT",
									     fileName => $fileName,
									     programInfoPath => $programInfoPath,
									     FILEHANDLE => $FILEHANDLE,
									     xargsFileCounter => $xargsFileCounter,
									     stderrPath => $programInfoPath.".stderr.txt",
									    });	
    if (${$scriptParameterHashRef}{pVT} > 0) {  #Run VT. Done per family
	
	($xargsFileCounter, $xargsFileName) = &VT({parameterHashRef => $parameterHashRef,
						   scriptParameterHashRef => $scriptParameterHashRef,
						   sampleInfoHashRef => $sampleInfoHashRef,
						   fileInfoHashRef => $fileInfoHashRef,
						   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
						   jobIDHashRef => $jobIDHashRef,
						   callType => $callType,
						   programName => "VT",
						   fileName => $fileName,
						   programInfoPath => $programInfoPath,
						   FILEHANDLE => $FILEHANDLE,
						   xargsFileCounter => $xargsFileCounter,
						   stderrPath => $programInfoPath.".stderr.txt",
						  });	
    }
    if (${$scriptParameterHashRef}{pVariantEffectPredictor} > 0) {  #Run VariantEffectPredictor. Done per family
		
	($xargsFileCounter, $xargsFileName) = &VariantEffectPredictor({parameterHashRef => $parameterHashRef,
								       scriptParameterHashRef => $scriptParameterHashRef,
								       sampleInfoHashRef => $sampleInfoHashRef,
								       fileInfoHashRef => $fileInfoHashRef,
								       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
								       jobIDHashRef => $jobIDHashRef,
								       callType => $callType,
								       programName => "VariantEffectPredictor",
								       fileName => $fileName,
								       programInfoPath => $programInfoPath,
								       FILEHANDLE => $FILEHANDLE,
								       xargsFileCounter => $xargsFileCounter,
								       stderrPath => $programInfoPath.".stderr.txt",
								      });	
    }
    if (${$scriptParameterHashRef}{pVCFParser} > 0) {  #Run VCFParser. Done per family

	($xargsFileCounter, $xargsFileName) = &VCFParser({parameterHashRef => $parameterHashRef,
							  scriptParameterHashRef => $scriptParameterHashRef,
							  sampleInfoHashRef => $sampleInfoHashRef,
							  fileInfoHashRef => $fileInfoHashRef,
							  infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
							  jobIDHashRef => $jobIDHashRef,
							  callType => $callType,
							  programName => "VCFParser",
							  fileName => $fileName,
							  programInfoPath => $programInfoPath,
							  FILEHANDLE => $FILEHANDLE,
							  xargsFileCounter => $xargsFileCounter,
							 });
    }
    if (${$scriptParameterHashRef}{pAnnovar} > 0) {  #Run Annovar. Done per family
	
	($xargsFileCounter, $xargsFileName) = &Annovar({parameterHashRef => $parameterHashRef,
							scriptParameterHashRef => $scriptParameterHashRef,
							sampleInfoHashRef => $sampleInfoHashRef,
							fileInfoHashRef => $fileInfoHashRef,
							infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
							jobIDHashRef => $jobIDHashRef,
							annovarTableHashRef => $annovarTableHashRef,
							callType => $callType,
							programName => "Annovar",
							fileName => $fileName,
							programInfoPath => $programInfoPath,
							FILEHANDLE => $FILEHANDLE,
							xargsFileCounter => $xargsFileCounter,
						       });
    }
    if (${$scriptParameterHashRef}{pSnpEff} > 0) {  #Run snpEff. Done per family
	
	($xargsFileCounter, $xargsFileName) = &SnpEff({parameterHashRef => $parameterHashRef,
						       scriptParameterHashRef => $scriptParameterHashRef,
						       sampleInfoHashRef => $sampleInfoHashRef,
						       fileInfoHashRef => $fileInfoHashRef,
						       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
						       jobIDHashRef => $jobIDHashRef,
						       callType => $callType,
						       programName => "SnpEff",
						       fileName => $fileName,
						       programInfoPath => $programInfoPath,
						       FILEHANDLE => $FILEHANDLE,
						       xargsFileCounter => $xargsFileCounter,
						      });
    }
    if (${$scriptParameterHashRef}{pRankVariants} > 0) {  #Run RankVariants. Done per family
	
	($xargsFileCounter, $xargsFileName) = &RankVariants({parameterHashRef => $parameterHashRef,
							     scriptParameterHashRef => $scriptParameterHashRef,
							     sampleInfoHashRef => $sampleInfoHashRef,
							     fileInfoHashRef => $fileInfoHashRef,
							     infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
							     jobIDHashRef => $jobIDHashRef,
							     callType => $callType,
							     programName => "RankVariants",
							     fileName => $fileName,
							     programInfoPath => $programInfoPath,
							     FILEHANDLE => $FILEHANDLE,
							     xargsFileCounter => $xargsFileCounter,
							    });
    }
}


sub BAMCalibrationBlock {

##BAMCalibrationBlock
    
##Function : Run consecutive module 
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $laneHashRef, $jobIDHashRef, $supportedCosmidReferenceHashRef, $alignerOutDir, $programName
##         : $parameterHashRef                => The parameter hash {REF}
##         : $scriptParameterHashRef          => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef               => Info on samples and family hash {REF}
##         : $fileInfoHashRef                 => The file info hash {REF}
##         : $infilesLaneNoEndingHashRef      => The infile(s) without the ".ending" {REF}
##         : $laneHashRef                     => The lane info hash {REF}
##         : $jobIDHashRef                    => The jobID hash {REF}
##         : $supportedCosmidReferenceHashRef => The supported cosmid references hash {REF}
##         : $alignerOutDir                   => The alignerOutDir used
##         : $programName                     => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $supportedCosmidReferenceHashRef = ${$argHashRef}{supportedCosmidReferenceHashRef};
    my $programName = ${$argHashRef}{programName};
    
    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "BAMCalibrationBlock");
    
    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 80;
    
    ## Set the number of cores to allocate per sbatch job.
    my $nrCores = ${$scriptParameterHashRef}{maximumCores};

    ##Always run even for single samples to rename them correctly for standardised downstream processing. 
    ##Will also split alignment per contig and copy to temporary directory for '-rio 1' block to enable selective removal of block submodules.
    $logger->info("\t[PicardTool MergeSamFiles]\n");

    if ($scriptParameter{pPicardToolsMarkduplicates} > 0) {  #PicardTools Markduplicates
	
	$logger->info("\t[PicardTools Markduplicates]\n");
    }
    if ($scriptParameter{pSambambaMarkduplicates} > 0) {  #Sambamba Markduplicates
	
	$logger->info("\t[Sambamba Markduplicates]\n");
    }
    if ($scriptParameter{pGATKRealigner} > 0) {  #Run GATK ReAlignerTargetCreator/IndelRealigner
	
	$logger->info("\t[GATK ReAlignerTargetCreator/IndelRealigner]\n");
	
	&CheckBuildHumanGenomePreRequisites({parameterHashRef => $parameterHashRef,
					     scriptParameterHashRef => $scriptParameterHashRef,
					     sampleInfoHashRef => $sampleInfoHashRef,
					     fileInfoHashRef => $fileInfoHashRef,
					     infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
					     jobIDHashRef => $jobIDHashRef,
					     supportedCosmidReferenceHashRef => $supportedCosmidReferenceHashRef,
					     programName => "GATKRealigner",
					    });
	&CheckBuildDownLoadPreRequisites({parameterHashRef => $parameterHashRef,
					  scriptParameterHashRef => $scriptParameterHashRef,
					  sampleInfoHashRef => $sampleInfoHashRef,
					  infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
					  jobIDHashRef => $jobIDHashRef,
					  supportedCosmidReferenceHashRef => $supportedCosmidReferenceHashRef,
					  programName => "GATKRealigner",
					 });
    }
    if ($scriptParameter{pGATKBaseRecalibration} > 0) {  #Run GATK BaseRecalibrator/PrintReads
	
	$logger->info("\t[GATK BaseRecalibrator/PrintReads]\n");
	
	&CheckBuildHumanGenomePreRequisites({parameterHashRef => $parameterHashRef,
					     scriptParameterHashRef => $scriptParameterHashRef,
					     sampleInfoHashRef => $sampleInfoHashRef,
					     fileInfoHashRef => $fileInfoHashRef,
					     infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
					     jobIDHashRef => $jobIDHashRef,
					     supportedCosmidReferenceHashRef => $supportedCosmidReferenceHashRef,
					     programName => "GATKBaseRecalibration",
					    });

	&CheckBuildDownLoadPreRequisites({parameterHashRef => $parameterHashRef,
					  scriptParameterHashRef => $scriptParameterHashRef,
					  sampleInfoHashRef => $sampleInfoHashRef,
					  infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
					  jobIDHashRef => $jobIDHashRef,
					  supportedCosmidReferenceHashRef => $supportedCosmidReferenceHashRef,
					  programName => "GATKBaseRecalibration",
					 });
    }

    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{ ${$scriptParameterHashRef}{sampleIDs} });$sampleIDCounter++) {  #Create a sbatch for each sample

	my $sampleIDRef = \${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter];
	my $xargsFileCounter = 0;
	my $xargsFileName;

	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	my ($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
								  jobIDHashRef => $jobIDHashRef,
								  FILEHANDLE => $FILEHANDLE,
								  directoryID => $$sampleIDRef,
								  programName => $programName,
								  programDirectory => lc($$alignerOutDirRef),
								  nrofCores => $nrCores,
								  processTime => $time,
								  tempDirectory => $$tempDirectoryRef
								 });

	##Always run even for single samples to rename them correctly for standardised downstream processing. 
	##Will also split alignment per contig and copy to temporary directory for -rio 1 block to enable selective removal of block submodules.
	($xargsFileCounter, $xargsFileName) = &PicardToolsMergeSamFiles({parameterHashRef => $parameterHashRef,
									 scriptParameterHashRef => $scriptParameterHashRef,
									 sampleInfoHashRef => $sampleInfoHashRef,
									 fileInfoHashRef => $fileInfoHashRef,
									 infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
									 laneHashRef => $laneHashRef,
									 jobIDHashRef => $jobIDHashRef,
									 sampleIDRef => $sampleIDRef,
									 programName => "PicardToolsMergeSamFiles",
									 fileName => $fileName,
									 programInfoPath => $programInfoPath,
									 FILEHANDLE => $FILEHANDLE,
									});

	if ($scriptParameter{pPicardToolsMarkduplicates} > 0) {  #PicardTools Markduplicates
	    
	    ($xargsFileCounter, $xargsFileName) = &PicardToolsMarkduplicates({parameterHashRef => $parameterHashRef,
									      scriptParameterHashRef => $scriptParameterHashRef,
									      sampleInfoHashRef => $sampleInfoHashRef,
									      fileInfoHashRef => $fileInfoHashRef,
									      infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
									      laneHashRef => $laneHashRef,
									      jobIDHashRef => $jobIDHashRef,
									      sampleIDRef => $sampleIDRef,
									      programName => "PicardToolsMarkduplicates",
									      fileName => $fileName,
									      programInfoPath => $programInfoPath,
									      FILEHANDLE => $FILEHANDLE,
									      xargsFileCounter => $xargsFileCounter,
									     });
	}
	if ($scriptParameter{pSambambaMarkduplicates} > 0) {  #Sambamba Markduplicates
	    
	    ($xargsFileCounter, $xargsFileName) = &SambambaMarkduplicates({parameterHashRef => $parameterHashRef,
									   scriptParameterHashRef => $scriptParameterHashRef,
									   sampleInfoHashRef => $sampleInfoHashRef,
									   fileInfoHashRef => $fileInfoHashRef,
									   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
									   laneHashRef => $laneHashRef,
									   jobIDHashRef => $jobIDHashRef,
									   sampleIDRef => $sampleIDRef,
									   programName => "SambambaMarkduplicates",
									   fileName => $fileName,
									   programInfoPath => $programInfoPath,
									   FILEHANDLE => $FILEHANDLE,
									   xargsFileCounter => $xargsFileCounter,
									  });
	}
	if ($scriptParameter{pGATKRealigner} > 0) {  #Run GATK ReAlignerTargetCreator/IndelRealigner
	       
	    ($xargsFileCounter, $xargsFileName) = &GATKReAligner({parameterHashRef => $parameterHashRef,
								  scriptParameterHashRef => $scriptParameterHashRef,
								  sampleInfoHashRef => $sampleInfoHashRef,
								  fileInfoHashRef => $fileInfoHashRef,
								  laneHashRef => $laneHashRef,
								  infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
								  jobIDHashRef => $jobIDHashRef,
								  sampleIDRef => $sampleIDRef,
								  programName => "GATKRealigner",
								  fileName => $fileName,
								  programInfoPath => $programInfoPath,
								  FILEHANDLE => $FILEHANDLE,
								  xargsFileCounter => $xargsFileCounter,
								 });	
	}
	if ($scriptParameter{pGATKBaseRecalibration} > 0) {  #Run GATK BaseRecalibrator/PrintReads

	    ($xargsFileCounter, $xargsFileName) = &GATKBaseReCalibration({parameterHashRef => $parameterHashRef,
									  scriptParameterHashRef => $scriptParameterHashRef,
									  sampleInfoHashRef => $sampleInfoHashRef,
									  fileInfoHashRef => $fileInfoHashRef,
									  laneHashRef => $laneHashRef,
									  infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
									  jobIDHashRef => $jobIDHashRef,
									  sampleIDRef => $sampleIDRef,
									  programName => "GATKBaseRecalibration",
									  fileName => $fileName,
									  programInfoPath => $programInfoPath,
									  FILEHANDLE => $FILEHANDLE,
									  xargsFileCounter => $xargsFileCounter,
									 });
	}
    }
}


sub Madeline {

##Madeline
    
##Function : Draw pedigree trees.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyIDRef, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => The familyIDRef {REF}
##         : $programName                => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     programName => $programName,
	);
     &CheckMandatoryArguments(\%mandatoryArgument, "Madeline");

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 1;
    my $nrCores = 1;

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$familyIDRef,
					    programName => $programName,
					    programDirectory => lc($programName),
					    nrofCores => $nrCores,
					    processTime => $time,
					   });

    ## Assign directories
    my $outFamilyDirectory = catfile(${$scriptParameterHashRef}{outDataDir}, $$familyIDRef, lc($programName));

    say $FILEHANDLE "## Reformat pedigree to Madeline format";

    print $FILEHANDLE "ped_parser ";
    print $FILEHANDLE "-t mip ";  #MIP pedigree format
    print $FILEHANDLE "--to_madeline ";  #Print the ped file in madeline format
    print $FILEHANDLE ${$scriptParameterHashRef}{pedigreeFile}." ";  #InFile
    say $FILEHANDLE "-o ".catfile($outFamilyDirectory, "madeline_pedigree.txt")." ";

    say $FILEHANDLE "## ".$programName;

    print $FILEHANDLE "madeline2 ";
    print $FILEHANDLE "--color ";
    print $FILEHANDLE "--outputprefix ".catfile($outFamilyDirectory, $$familyIDRef."_madeline")." ";
    say $FILEHANDLE catfile($outFamilyDirectory, "madeline_pedigree.txt")." ";

    ## Collect QC metadata info for active program for later use
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{Program}{$programName}{Path} = catfile($outFamilyDirectory, $$familyIDRef."_madeline.xml");
    }

    close($FILEHANDLE);
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 2, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub FastQC {

##FastQC
    
##Function : Raw sequence quality analysis using FASTQC.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $infileHashRef, $inDirPathHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $sampleIDRef, $programName
##         : $parameterHashRef                  => The parameter hash {REF}
##         : $scriptParameterHashRef            => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef                 => Info on samples and family hash {REF}
##         : $infileHashRef                     => The infiles hash {REF}
##         : $inDirPathHashRef                  => The indirectories path(s) hash {REF}
##         : $infilesLaneNoEndingHashRef        => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef                      => The jobID hash {REF}
##         : $sampleIDRef                       => The sampleID {REF}
##         : $programName                       => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $infileHashRef = ${$argHashRef}{infileHashRef};
    my $inDirPathHashRef = ${$argHashRef}{inDirPathHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleID};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} },  #Any MIP mandatory key will do
			     inDirPathHashRef => ${$inDirPathHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     sampleIDRef => $$sampleIDRef,
			     programName => $programName,
	);
     &CheckMandatoryArguments(\%mandatoryArgument, "FastQC");

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = 10;

    my $nrCores = 0;

    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} });$infileCounter++) {  #For all files   

	my $infileRef = \${$infilesLaneNoEndingHashRef}{ $$sampleIDRef }[$infileCounter];  #Alias

	## Adjust the number of cores to be used in the analysis according to sequencing mode requirements.
	&AdjustNrCoresToSeqMode({nrCoresRef => \$nrCores,
				 sequenceRunTypeRef => \${$sampleInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{File}{$$infileRef}{SequenceRunType},
				});
    }

    ## Set the number of cores to allocate per sbatch job.
    $nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
				    nrCores => $nrCores,
				   });  #Make sure that the number of cores does not exceed maximum after incrementing above

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$sampleIDRef,
					    programName => $programName,
					    programDirectory => lc($programName),
					    nrofCores => $nrCores,
					    processTime => $time,
					    tempDirectory => $$tempDirectoryRef,
					   });

    ## Assign directories
    my $inSampleDirectory = ${$inDirPathHashRef}{$$sampleIDRef};
    my $outSampleDirectory = catdir(${$scriptParameterHashRef}{outDataDir}, $$sampleIDRef, lc($programName));

    my $coreCounter=1;

    ## Copies files from source to temporary folder. Loop over files specified by $arrayRef and collects files from $extractArrayRef.
    &MigrateFilesToTemp({scriptParameterHashRef => $scriptParameterHashRef,
			 sampleInfoHashRef => $sampleInfoHashRef,
			 arrayRef => \@{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} },
			 extractArrayRef => \@{ ${$infileHashRef}{$$sampleIDRef} },
			 FILEHANDLE => $FILEHANDLE,
			 inSampleDirectory => $inSampleDirectory,
			 nrCores => $nrCores,
			 sampleID => $$sampleIDRef
			});
    
    say $FILEHANDLE "## ".$programName;
    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infileHashRef}{$$sampleIDRef} });$infileCounter++) {

	&PrintWait({counterRef => \$infileCounter,
		    nrCoresRef => \$nrCores,
		    coreCounterRef => \$coreCounter,
		    FILEHANDLE => $FILEHANDLE,
		   });

	my $infile = ${$infileHashRef}{$$sampleIDRef}[$infileCounter];

	## Removes ".fileEnding" in filename.FILENDING(.gz)
	my $fileAtLaneLevel = &RemoveFileEnding({fileNameRef => \$infile,
						 fileEnding => ".fastq",
						});

	print $FILEHANDLE "fastqc ";
	print $FILEHANDLE catfile($$tempDirectoryRef, $infile)." ";  #InFile
	print $FILEHANDLE "--extract ";  #the zipped output file will be uncompressed in the same directory after it has been created.
	print $FILEHANDLE "-o ".$$tempDirectoryRef." ";  #OutFile
	say $FILEHANDLE "&", "\n";

	## Collect QC metadata info for active program for later use
	if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	    &SampleInfoQC({sampleInfoHashRef => $sampleInfoHashRef,
			   familyID => $$familyIDRef,
			   sampleID => $$sampleIDRef,
			   programName => "FastQC",
			   infile => $infile,
			   outDirectory => catfile($outSampleDirectory, $fileAtLaneLevel."_fastqc"),
			   outfileEnding => "fastqc_data.txt",
			   outDataType => "static"
			  });
	}
    }
    say $FILEHANDLE "wait";    

    ## Copies files from temporary folder to source.
    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infileHashRef}{$$sampleIDRef} });$infileCounter++) {

	&PrintWait({counterRef => \$infileCounter,
		    nrCoresRef => \$nrCores,
		    coreCounterRef => \$coreCounter,
		    FILEHANDLE => $FILEHANDLE,
		   });

	my $infile = ${$infileHashRef}{$$sampleIDRef}[$infileCounter];

	## Removes ".fileEnding" in filename.FILENDING(.gz)
	my $fileAtLaneLevel = &RemoveFileEnding({fileNameRef => \$infile,
						 fileEnding => ".fastq",
						});

	## Copies files from temporary folder to source
	print $FILEHANDLE "cp -r ";
	print $FILEHANDLE catfile($$tempDirectoryRef, $fileAtLaneLevel."_fastqc")." ";
	print $FILEHANDLE $outSampleDirectory." ";
	say $FILEHANDLE "&", "\n";
    }
    say $FILEHANDLE "wait"; 

    close($FILEHANDLE);
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       sampleID => $$sampleIDRef,
		       dependencies => 2, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub GZipFastq { 
 
##GZipFastq
    
##Function : Automatically gzips fastq files.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $infileHashRef, $inDirPathHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $sampleID, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $infileHashRef              => The infiles hash {REF}
##         : $inDirPathHashRef           => The indirectories path(s) hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $sampleID                   => The sampleID
##         : $programName                => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $infileHashRef = ${$argHashRef}{infileHashRef};
    my $inDirPathHashRef = ${$argHashRef}{inDirPathHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $sampleID = ${$argHashRef}{sampleID};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} },  #Any MIP mandatory key will do
			     inDirPathHashRef => ${$inDirPathHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     sampleID => $sampleID,
			     programName => $programName,
	);
     &CheckMandatoryArguments(\%mandatoryArgument, "GZipFastq");

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $time = ceil(1.5*scalar( @{ ${$infileHashRef}{$sampleID} }));  #One full lane on Hiseq takes approx. 1.5 h for gzip to process, round up to nearest full hour.

    my $nrCores = 0;

    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infilesLaneNoEndingHashRef}{$sampleID} });$infileCounter++) {  #For all files   
	
	my $infileRef = \${$infilesLaneNoEndingHashRef}{ $sampleID }[$infileCounter];  #Alias
	## Adjust the number of cores to be used in the analysis according to sequencing mode requirements.
	&AdjustNrCoresToSeqMode({nrCoresRef => \$nrCores,
				 sequenceRunTypeRef => \${$sampleInfoHashRef}{$$familyIDRef}{$sampleID}{File}{$$infileRef}{SequenceRunType},
				});
    }

    ## Set the number of cores to allocate per sbatch job.
    $nrCores = &NrofCoresPerSbatch({scriptParameterHashRef => $scriptParameterHashRef,
				    nrCores => $nrCores,
				   });  #Make sure that the number of cores does not exceed maximum after incrementing above
    
    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $sampleID,
					    programName => $programName,
					    programDirectory => lc($programName),
					    nrofCores => $nrCores,
					    processTime => $time,
					   });

    ## Assign directories
    my $inSampleDirectory = ${$inDirPathHashRef}{$sampleID};   

    my $coreCounter=1;
    my $uncompressedFileCounter = 0;  #Used to print wait at the right times since infiles cannot be used (can be a mixture of .gz and .fast files)

    say $FILEHANDLE "cd ".${$inDirPathHashRef}{$sampleID}, "\n";
    
    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infileHashRef}{$sampleID} });$infileCounter++) {

	if (${$infileHashRef}{$sampleID}[$infileCounter] =~/.fastq$/) {  #For files ending with .fastq required since there can be a mixture (also .fastq.gz) within the sample dir

	    if ($uncompressedFileCounter == $coreCounter*${$scriptParameterHashRef}{maximumCores}) {  #Using only $scriptParameter{maximumCores} cores
		
		say $FILEHANDLE "wait", "\n";
		$coreCounter=$coreCounter+1;
	    }

	    my $infile = ${$infileHashRef}{$sampleID}[$infileCounter];

	    print $FILEHANDLE "gzip ";
	    say $FILEHANDLE catfile($inSampleDirectory, $infile)." &\n";  #InFile
	    $uncompressedFileCounter++;
	    ${$infileHashRef}{$sampleID}[$infileCounter] =~ s/.fastq/.fastq.gz/g;  #Replace the .fastq ending with .fastq.gz since this will execute before fastQC screen and mosaikBuild, hence changing the original file name ending from ".fastq" to ".fastq.gz". 
	}
    }
    say $FILEHANDLE "wait", "\n";

    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       sampleID => $sampleID,
		       dependencies => 0, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub BuildAnnovarPreRequisites {

##BuildAnnovarPreRequisites
    
##Function : Creates the AnnovarPreRequisites.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $annovarTableHashRef, $familyID, $alignerOutDir, $programName
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $annovarTableHashRef        => annovarTableHashRef {REF}
##         : $familyID                   => Family ID
##         : $alignerOutDir              => The alignerOutDir used in the analysis
##         : $programName                => The program name

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $annovarTableHashRef = ${$argHashRef}{annovarTableHashRef};
    my $programName = ${$argHashRef}{programName};
    
    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    ${$parameterHashRef}{annovarBuildReference}{buildFile} = 0;  #Ensure that this subrutine is only executed once
    my $annovarTemporaryDirectory = catfile(${$scriptParameterHashRef}{annovarPath}, "humandb", "Db_temporary");  #Temporary download directory
    
    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$familyIDRef,
					    programName => $programName,
					    programDirectory => lc($$alignerOutDirRef),
					    processTime => 3,
					    tempDirectory => $$tempDirectoryRef
					   });

    $logger->warn("Will try to create required Annovar database files before executing ".$programName."\n");

    say $FILEHANDLE "## Make temporary download directory\n"; 
    say $FILEHANDLE "mkdir -p ".$annovarTemporaryDirectory."; ", "\n"; 

    say $FILEHANDLE "## Downloading Annovar Db files", "\n";

    for (my $tableNamesCounter=0;$tableNamesCounter<scalar(@{${$scriptParameterHashRef}{annovarTableNames}});$tableNamesCounter++) {  #For all specified table names
	
	if (${$parameterHashRef}{${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter]}{buildFile} eq 1) {
	    
	    print $FILEHANDLE "perl ".catfile(${$scriptParameterHashRef}{annovarPath}, "annotate_variation.pl")." ";  #Annovar script 
	    print $FILEHANDLE "-buildver ".${$scriptParameterHashRef}{annovarGenomeBuildVersion}." ";  #GenomeBuild version
	    print $FILEHANDLE "-downdb ".${$annovarTableHashRef}{${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter]}{download}." ";  #Db to download
	    
	    if (defined(${$annovarTableHashRef}{${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter]}{ucscAlias})) {
		
		print $FILEHANDLE "-webfrom ucsc ";  #Download from ucsc
	    }
	    else {
		
		print $FILEHANDLE "-webfrom annovar ";  #Download from annovar
	    }
	    say $FILEHANDLE catfile($annovarTemporaryDirectory)." ", "\n";  #Annovar/humandb directory is assumed

	    if (${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] =~/ensGene|refGene/) {  #Special case for MT download
		
		print $FILEHANDLE "perl ".catfile(${$scriptParameterHashRef}{annovarPath}, "annotate_variation.pl")." ";  #Annovar script 
		print $FILEHANDLE "-buildver GRCh37_MT ";  #GenomeBuild version
		print $FILEHANDLE "-downdb ensGene ";  #Db to download
		print $FILEHANDLE "-webfrom annovar ";  #Download from annovar
		say $FILEHANDLE catfile($annovarTemporaryDirectory), "\n";  #annovar/humandb directory is assumed
	    }
	    
	    ### Check file existance and move created file if lacking 
	    my $intendedFilePath;
	    my $temporaryFilePath;
	    
	    if (defined(${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{File})) {
		
		for (my $filesCounter=0;$filesCounter<scalar(@{${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{File}});$filesCounter++) {  #All annovarTable file(s), some tables have multiple files downloaded from the same call
		    
		    $intendedFilePath = catfile(${$scriptParameterHashRef}{annovarPath}, "humandb", ${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{File}[$filesCounter]);  
		    $temporaryFilePath = catfile($annovarTemporaryDirectory, ${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{File}[$filesCounter]);
		    
		    ## Checks if a file exists and moves the file in place if file is lacking or has a size of 0 bytes.
		    &PrintCheckExistandMoveFile($FILEHANDLE, \$intendedFilePath, \$temporaryFilePath);
		    
		    if (defined(${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{indexFile})) {
			
			$intendedFilePath = catfile(${$scriptParameterHashRef}{annovarPath}, "humandb", ${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{File}[$filesCounter].".idx");  
			$temporaryFilePath = catfile($annovarTemporaryDirectory, ${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{File}[$filesCounter].".idx");
			
			## Checks if a file exists and moves the file in place if file is lacking or has a size of 0 bytes.
			&PrintCheckExistandMoveFile($FILEHANDLE, \$intendedFilePath, \$temporaryFilePath);	
		    }
		}		
	    }
	    elsif ((defined(${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{ucscAlias}))){
		
		$intendedFilePath = catfile(${$scriptParameterHashRef}{annovarPath}, "humandb", ${$scriptParameterHashRef}{annovarGenomeBuildVersion}."_".${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{ucscAlias}.".txt");
		$temporaryFilePath = catfile($annovarTemporaryDirectory, ${$scriptParameterHashRef}{annovarGenomeBuildVersion}."_".${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{ucscAlias}.".txt");
		
		## Checks if a file exists and moves the file in place if file is lacking or has a size of 0 bytes.
		&PrintCheckExistandMoveFile($FILEHANDLE, \$intendedFilePath, \$temporaryFilePath);
	    
		if (defined(${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{indexFile})) {
		    
		    $intendedFilePath = catfile(${$scriptParameterHashRef}{annovarPath}, "humandb", ${$scriptParameterHashRef}{annovarGenomeBuildVersion}."_".${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{ucscAlias}.".txt.idx");
		    $temporaryFilePath = catfile($annovarTemporaryDirectory, ${$scriptParameterHashRef}{annovarGenomeBuildVersion}."_".${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{ucscAlias}.".txt.idx");
		    
		    ## Checks if a file exists and moves the file in place if file is lacking or has a size of 0 bytes.
		    &PrintCheckExistandMoveFile($FILEHANDLE, \$intendedFilePath, \$temporaryFilePath);
		}
	    }
	    else {
	    
		$intendedFilePath = catfile(${$scriptParameterHashRef}{annovarPath}, "humandb", ${$scriptParameterHashRef}{annovarGenomeBuildVersion}."_".${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter].".txt");
		$temporaryFilePath = catfile($annovarTemporaryDirectory, ${$scriptParameterHashRef}{annovarGenomeBuildVersion}."_".${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter].".txt");    
		
		## Checks if a file exists and moves the file in place if file is lacking or has a size of 0 bytes.
		&PrintCheckExistandMoveFile($FILEHANDLE, \$intendedFilePath, \$temporaryFilePath);
	    
		if (defined(${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{indexFile})) {
	
		    $intendedFilePath = catfile(${$scriptParameterHashRef}{annovarPath}, "humandb", ${$scriptParameterHashRef}{annovarGenomeBuildVersion}."_".${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter].".txt.idx");
		    $temporaryFilePath = catfile($annovarTemporaryDirectory, ${$scriptParameterHashRef}{annovarGenomeBuildVersion}."_".${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter].".txt.idx");    
		    
		    ## Checks if a file exists and moves the file in place if file is lacking or has a size of 0 bytes.
		    &PrintCheckExistandMoveFile($FILEHANDLE, \$intendedFilePath, \$temporaryFilePath);	
		}				
	    }
	}
        ${$parameterHashRef}{${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter]}{buildFile} = 0;
    }
    
    say $FILEHANDLE "rm -rf $annovarTemporaryDirectory;", "\n";  #Cleaning up temp directory
    close($FILEHANDLE);
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 6, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub BuildDownLoadablePreRequisites {

##BuildDownLoadablePreRequisites

##Function : Creates the downloadable resources.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, supportedCosmidReferenceHashRef, $familyIDRef, $alignerOutDirRef, $programName, $FILEHANDLE, $randomInteger
##         : $parameterHashRef                => The parameter hash {REF}
##         : $scriptParameterHashRef          => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef               => Info on samples and family hash {REF}
##         : $infilesLaneNoEndingHashRef      => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef                    => The jobID hash {REF}
##         : $supportedCosmidReferenceHashRef => The supported cosmid references hash {REF}
##         : $familyIDRef                     => Family ID {REF}
##         : $alignerOutDirRef                => The alignerOutDir used in the analysis
##         : $programName                     => The program name

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $supportedCosmidReferenceHashRef = ${$argHashRef}{supportedCosmidReferenceHashRef};
    my $programName = ${$argHashRef}{programName};

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    
    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$familyIDRef,
					    programName => $programName,
					    programDirectory => lc($$alignerOutDirRef),
					    processTime => 4,
					   });

    say $FILEHANDLE "cd ${$scriptParameterHashRef}{referencesDir}", "\n";  #Move to reference directory

    ## Locates and sets the cosmid directory to download to
    my $cosmidResourceDirectory = &CheckCosmidYAML($scriptParameterHashRef);

    for my $parameterName (keys %{$supportedCosmidReferenceHashRef}) {

	if (! &CheckEntryHashofArray({hashRef => ${$parameterHashRef}{$parameterName},
				      key => "associatedProgram",
				      element => "p".$programName,
				     })
	    ) {  #If the cosmid supported parameter is associated with the MIP program

	    if (${$parameterHashRef}{$parameterName}{buildFile} eq 1) {
	    
		&DownloadReference({parameterHashRef => $parameterHashRef,
				    scriptParameterHashRef => $scriptParameterHashRef,
				    sampleInfoHashRef => $sampleInfoHashRef,
				    infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
				    jobIDHashRef => $jobIDHashRef,
				    supportedCosmidReferenceHashRef => $supportedCosmidReferenceHashRef,
				    cosmidResourceDirectoryRef => \$cosmidResourceDirectory,
				    programRef => \$programName,
				    FILEHANDLE => $FILEHANDLE,
				    parameterName => $parameterName,
				   });
	    }
	}
    }
    
    close($FILEHANDLE);
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 6, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub BuildPTCHSMetricPreRequisites {

##BuildPTCHSMetricPreRequisites

##Function : Creates the target "infiles_list" "padded.infile_list" and interval_list files.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $familyIDRef, $alignerOutDir, $programName, $FILEHANDLE
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The file info hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $familyIDRef                => Family ID {REF}
##         : $alignerOutDir              => The alignerOutDir used in the analysis
##         : $programName                => The program name
##         : $FILEHANDLE                 => Filehandle to write to

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $programName = ${$argHashRef}{programName};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};  #Decides if a new sbatch script will be generated or handled by supplied FILEHANDLE

    my $parametersToEvaluate = 0;  #The number of parameters to evaluate
    my $fileName;

    unless(defined($FILEHANDLE)) {  #No supplied FILEHANDLE i.e. create new sbatch script    
	
	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle

	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					     jobIDHashRef => $jobIDHashRef,
					     FILEHANDLE => $FILEHANDLE,
					     directoryID => $$familyIDRef,
					     programName => $programName,
					     programDirectory => lc($$alignerOutDirRef),
					    });
    }
  	    
    my $randomInteger = int(rand(10000));  #Generate a random integer between 0-10,000.

    ## Alias exomeTargetBed endings
    my $infileListEndingRef = \${$fileInfoHashRef}{exomeTargetBed}[0];  
    my $paddedInfileListEndingRef = \${$fileInfoHashRef}{exomeTargetBed}[1];
    my $paddedIntervalListEndingRef = \${$fileInfoHashRef}{exomeTargetBed}[2];

    foreach my $exomeTargetBedFile (keys %{${$scriptParameterHashRef}{exomeTargetBed}}) {
	
	$logger->warn("Will try to create required ".$exomeTargetBedFile." associated file(s) before executing ".$programName."\n");

	my $exomeTargetBedFileRandom = $exomeTargetBedFile."_".$randomInteger;  #Add random integer

	say $FILEHANDLE "## CreateSequenceDictionary from reference";
	
	&JavaCore({FILEHANDLE => $FILEHANDLE,
		   memoryAllocation => "Xmx2g",
		   javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		   javaTemporaryDirectory => $$tempDirectoryRef,
		   javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
		  });
    
	print $FILEHANDLE "CreateSequenceDictionary ";
	print $FILEHANDLE "R=".catfile($$referencesDirRef, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference genome
	say $FILEHANDLE "OUTPUT=".catfile($$referencesDirRef, $exomeTargetBedFileRandom.".dict"), "\n";  #Output sequence dictionnary
    
	say $FILEHANDLE "## Add target file to headers from sequenceDictionary";
	print $FILEHANDLE "cat ";  #Concatenate
	print $FILEHANDLE catfile($$referencesDirRef, $exomeTargetBedFileRandom.".dict")." ";  #Sequence dictionnary
	print $FILEHANDLE catfile($$referencesDirRef, $exomeTargetBedFile)." ";  #Bed file
	print $FILEHANDLE "> ";  #Write to
	say $FILEHANDLE catfile($$referencesDirRef, $exomeTargetBedFileRandom.".dict_body"), "\n";  #Add bed body to dictionnary
	
	say $FILEHANDLE "#Remove target annotations, 'track', 'browse' and keep only 5 columns";
	print $FILEHANDLE q?perl  -nae 'if ($_=~/@/) {print $_;} elsif ($_=~/^track/) {} elsif ($_=~/^browser/) {} else {print @F[0], "\t", (@F[1] + 1), "\t", @F[2], "\t", "+", "\t", "-", "\n";}' ?;
	print $FILEHANDLE catfile($$referencesDirRef, $exomeTargetBedFileRandom.".dict_body")." ";  #Infile
	print $FILEHANDLE "> ";  #Write to
	say $FILEHANDLE catfile($$referencesDirRef, $exomeTargetBedFileRandom.".dict_body_col_5.interval_list"), "\n";  #Remove unnecessary info and reformat 
    
	say $FILEHANDLE "## Create".$$infileListEndingRef;
	&JavaCore({FILEHANDLE => $FILEHANDLE,
		   memoryAllocation => "Xmx2g",
		   javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		   javaTemporaryDirectory => $$tempDirectoryRef,
		   javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
		  });
    
	print $FILEHANDLE "IntervalListTools ";
	print $FILEHANDLE "INPUT=".catfile($$referencesDirRef, $exomeTargetBedFileRandom.".dict_body_col_5.interval_list")." ";
	say $FILEHANDLE "OUTPUT=".catfile($$referencesDirRef, $exomeTargetBedFileRandom.".dict_body_col_5_".$$infileListEndingRef), "\n";
    
	my $intendedFilePath = catfile($$referencesDirRef, $exomeTargetBedFile.$$infileListEndingRef);
	my $temporaryFilePath = catfile($$referencesDirRef, $exomeTargetBedFileRandom.".dict_body_col_5_".$$infileListEndingRef);
    
	## Checks if a file exists and moves the file in place if file is lacking or has a size of 0 bytes.
	&PrintCheckExistandMoveFile($FILEHANDLE, \$intendedFilePath, \$temporaryFilePath);
    
	say $FILEHANDLE "#Create".$$paddedInfileListEndingRef;
	&JavaCore({FILEHANDLE => $FILEHANDLE,
		   memoryAllocation => "Xmx2g",
		   javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		   javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
		   javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
		  });
    
	print $FILEHANDLE "IntervalListTools ";
	print $FILEHANDLE "PADDING=100 ";  #Add 100 nt on both sides of bed entry
	print $FILEHANDLE "INPUT=".catfile($$referencesDirRef, $exomeTargetBedFileRandom.".dict_body_col_5.interval_list")." ";
	say $FILEHANDLE "OUTPUT=".catfile($$referencesDirRef, $exomeTargetBedFileRandom.".dict_body_col_5".$$paddedInfileListEndingRef), "\n";
    
	$intendedFilePath = catfile($$referencesDirRef, $exomeTargetBedFile.$$paddedInfileListEndingRef);
	$temporaryFilePath = catfile($$referencesDirRef, $exomeTargetBedFileRandom.".dict_body_col_5".$$paddedInfileListEndingRef);
    
	## Checks if a file exists and moves the file in place if file is lacking or has a size of 0 bytes.
	&PrintCheckExistandMoveFile($FILEHANDLE, \$intendedFilePath, \$temporaryFilePath);
	
	say $FILEHANDLE "#Create ".$$paddedIntervalListEndingRef." by softlinking";

	##Softlink '.interval_list' to padded .infile_list", "\n";
	print $FILEHANDLE "ln -f -s ";  #Softlink
	print $FILEHANDLE catfile($$referencesDirRef, $exomeTargetBedFile.$$paddedInfileListEndingRef)." ";  #Origin file
	print $FILEHANDLE catfile($$referencesDirRef, $exomeTargetBedFile.$$paddedIntervalListEndingRef);  #interval_list file

	say $FILEHANDLE "\n";
	
	say $FILEHANDLE "#Remove temporary files";
	
	print $FILEHANDLE "rm ";
	say $FILEHANDLE catfile($$referencesDirRef, $exomeTargetBedFileRandom.".dict_body_col_5.interval_list"), "\n";
	
	print $FILEHANDLE "rm ";
	say $FILEHANDLE catfile($$referencesDirRef, $exomeTargetBedFileRandom.".dict_body"), "\n";
	
	print $FILEHANDLE "rm ";
	say $FILEHANDLE catfile($$referencesDirRef, $exomeTargetBedFileRandom.".dict"), "\n";

	
    }
    unless($_[6]) {  #Unless FILEHANDLE was supplied close filehandle and submit 
	
	close($FILEHANDLE);
	
	if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			   sampleInfoHashRef => $sampleInfoHashRef,
			   jobIDHashRef => $jobIDHashRef,
			   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			   dependencies => 6, 
			   path => "MIP",
			   sbatchFileName => $fileName
			  });
	}
    }
}

sub BuildBwaPreRequisites {

##BuildBwaPreRequisites

##Function : Creates the BwaPreRequisites using scriptParameters{'humanGenomeReference'} as reference.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $supportedCosmidReferenceHashRef, $bwaBuildReferenceFileEndingsArrayRef, $familyIDRef, $alignerOutDirRef, $programName, $FILEHANDLE, $humanGenomeReferenceRef
##         : $parameterHashRef                     => The parameter hash {REF}
##         : $scriptParameterHashRef               => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef                    => Info on samples and family hash {REF}
##         : $fileInfoHashRef                      => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef           => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef                         => The jobID hash {REF}
##         : $supportedCosmidReferenceHashRef      => The supported cosmid references hash {REF}
##         : $bwaBuildReferenceFileEndingsArrayRef => The bwa reference associated file endings {REF}
##         : $familyIDRef                          => Family ID {REF}
##         : $alignerOutDirRef                     => The alignerOutDir used in the analysis
##         : $programName                          => The program name
##         : $humanGenomeReferenceRef              => Human genome reference {REF}

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $humanGenomeReferenceRef = ${$argHashRef}{'humanGenomeReferenceRef'} //= \${$argHashRef}{'scriptParameterHashRef'}{'humanGenomeReference'},

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $supportedCosmidReferenceHashRef = ${$argHashRef}{supportedCosmidReferenceHashRef};
    my $bwaBuildReferenceFileEndingsArrayRef = ${$argHashRef}{bwaBuildReferenceFileEndingsArrayRef};
    my $programName = ${$argHashRef}{programName};
    
    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     bwaBuildReferenceFileEndingsArrayRef => ${$bwaBuildReferenceFileEndingsArrayRef}[0],
			     familyID => $$familyIDRef,
			     alignerOutDir => $$alignerOutDirRef,
			     programName => $programName,
	);
    
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $randomInteger = int(rand(10000));  #Generate a random integer between 0-10,000.

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $$familyIDRef,
					    programName => $programName,
					    programDirectory => lc($$alignerOutDirRef),
					    processTime => 3,
					   });
 
    &BuildHumanGenomePreRequisites({parameterHashRef => $parameterHashRef,
				    scriptParameterHashRef => $scriptParameterHashRef,
				    sampleInfoHashRef => $sampleInfoHashRef,
				    fileInfoHashRef => $fileInfoHashRef,
				    infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
				    jobIDHashRef => $jobIDHashRef,
				    supportedCosmidReferenceHashRef => $supportedCosmidReferenceHashRef,
				    familyID => $$familyIDRef,
				    alignerOutDir => $$alignerOutDirRef,
				    program => $programName,
				    FILEHANDLE => $FILEHANDLE,
				    randomInteger => $randomInteger,
				   });

    if (${$parameterHashRef}{bwaBuildReference}{buildFile} eq 1) {

	$logger->warn("Will try to create required ".$$humanGenomeReferenceRef." index files before executing ".$programName."\n");
	
	say $FILEHANDLE "## Building BWA index";
	print $FILEHANDLE "bwa index ";  #Index sequences in the FASTA format
	print $FILEHANDLE "-p ".catfile($$referencesDirRef, $$humanGenomeReferenceRef."_".$randomInteger)." "; #Prefix of the index
	print $FILEHANDLE "-a bwtsw ";  #BWT construction algorithm
	say $FILEHANDLE catfile($$referencesDirRef, $$humanGenomeReferenceRef), "\n";  #The FASTA reference sequences file

	for (my $fileEndingsCounter=0;$fileEndingsCounter<scalar(@{$bwaBuildReferenceFileEndingsArrayRef});$fileEndingsCounter++) {  #All fileEndings
	    
	    my $intendedFilePath = catfile($$referencesDirRef, $$humanGenomeReferenceRef.${$bwaBuildReferenceFileEndingsArrayRef}[$fileEndingsCounter]);
	    my $temporaryFilePath = catfile($$referencesDirRef, $$humanGenomeReferenceRef."_".$randomInteger.${$bwaBuildReferenceFileEndingsArrayRef}[$fileEndingsCounter]);

	    ## Checks if a file exists and moves the file in place if file is lacking or has a size of 0 bytes.
	    &PrintCheckExistandMoveFile($FILEHANDLE, \$intendedFilePath, \$temporaryFilePath);
	}
	${$parameterHashRef}{bwaBuildReference}{buildFile} = 0;  #Ensure that this subrutine is only executed once
    }
    close($FILEHANDLE);
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		   sampleInfoHashRef => $sampleInfoHashRef,
		   jobIDHashRef => $jobIDHashRef,
		   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		   dependencies => 6, 
		   path => ${$parameterHashRef}{"p".$programName}{chain},
		   sbatchFileName => $fileName
		  });
    }
}


sub BuildMosaikAlignPreRequisites {

##BuildMosaikAlignPreRequisites
    
##Function : Creates the mosaikAlignPreRequisites using scriptParameters{'humanGenomeReference'} as reference.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $supportedCosmidReferenceHashRef, $mosaikJumpDbStubFileEndingsArrayRef, $humanGenomeReferenceSourceRef, $humanGenomeReferenceVersionRef, $familyID, $alignerOutDir, $programName
##         : $parameterHashRef                    => The parameter hash {REF}
##         : $scriptParameterHashRef              => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef                   => Info on samples and family hash {REF}
##         : $fileInfoHashRef                     => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef          => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef                        => The jobID hash {REF}
##         : $supportedCosmidReferenceHashRef     => The supported cosmid references hash {REF}
##         : $mosaikJumpDbStubFileEndingsArrayRef => The mosaikJump database file endings
##         : $humanGenomeReferenceSourceRef       => The human genome source {REF}
##         : $humanGenomeReferenceVersionRef      => The human genome build version {REF}
##         : $familyID                            => Family ID
##         : $alignerOutDir                       => AlignerOutDir used in the analysis
##         : $programName                         => Program name 

    my $parameterHashRef = $_[0];
    my $scriptParameterHashRef = $_[1];
    my $sampleInfoHashRef = $_[2];
    my $fileInfoHashRef = $_[3];
    my $infilesLaneNoEndingHashRef = $_[4];
    my $jobIDHashRef = $_[5];
    my $supportedCosmidReferenceHashRef = $_[6];
    my $mosaikJumpDbStubFileEndingsArrayRef = $_[7];
    my $humanGenomeReferenceSourceRef = $_[8];
    my $humanGenomeReferenceVersionRef = $_[9];
    my $familyID = $_[10];
    my $alignerOutDir = $_[11];
    my $programName = $_[12];

    my $FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
    my $randomInteger = int(rand(10000));  #Generate a random integer between 0-10,000.

    ## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header.
    my ($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					    FILEHANDLE => $FILEHANDLE,
					    directoryID => $familyID,
					    programName => $programName,
					    programDirectory => lc($alignerOutDir),
					    nrofCores => 4,
					    processTime => 2,
					   });
    
    ## Creates the humanGenomePreRequisites using scriptParameters{humanGenomeReference} as reference.
    &BuildHumanGenomePreRequisites({parameterHashRef => $parameterHashRef,
				    scriptParameterHashRef => $scriptParameterHashRef,
				    sampleInfoHashRef => $sampleInfoHashRef,
				    fileInfoHashRef => $fileInfoHashRef,
				    infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
				    jobIDHashRef => $jobIDHashRef,
				    supportedCosmidReferenceHashRef => $supportedCosmidReferenceHashRef,
				    familyID => $familyID,
				    alignerOutDir => $alignerOutDir,
				    program => $programName,
				    FILEHANDLE => $FILEHANDLE,
				    randomInteger => $randomInteger,
				   });

    if (${$parameterHashRef}{mosaikAlignReference}{buildFile} eq 1) {  ##Begin autoBuild of MosaikAlignReference
	
	$logger->warn("Will try to create required ".${$scriptParameterHashRef}{mosaikAlignReference}." before executing ".$programName."\n");
	
	say $FILEHANDLE "#Building MosaikAligner Reference";
	print $FILEHANDLE "MosaikBuild ";
	print $FILEHANDLE "-fr ".catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #The FASTA reference sequences file
	print $FILEHANDLE "-sn Homo_sapiens ";  #Species name
	print $FILEHANDLE "-ga ".$$humanGenomeReferenceSourceRef.$$humanGenomeReferenceVersionRef." ";  #The genome assembly ID
	say $FILEHANDLE "-oa ".catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{mosaikAlignReference}."_".$randomInteger), "\n";  #Temporary outfile

	my $intendedFilePath = catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{mosaikAlignReference});
	my $temporaryFilePath = catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{mosaikAlignReference}."_".$randomInteger);    

	## Checks if a file exists and moves the file in place if file is lacking or has a size of 0 bytes.
	&PrintCheckExistandMoveFile($FILEHANDLE, \$intendedFilePath, \$temporaryFilePath);
    }
    if (${$parameterHashRef}{mosaikJumpDbStub}{buildFile} eq 1) {  ##Begin autoBuild of MosaikJump Database

	$logger->warn("Will try to create required ".${$scriptParameterHashRef}{mosaikJumpDbStub}." before executing ".$programName."\n");

	say $FILEHANDLE "#Building MosaikAligner JumpDatabase";
	say $FILEHANDLE "mkdir -p ".catfile("scratch", "mosaik_tmp");
	say $FILEHANDLE "export MOSAIK_TMP=".catfile("scratch", "mosaik_tmp"), "\n";
	
	print $FILEHANDLE "MosaikJump ";
	print $FILEHANDLE "-ia ".catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{mosaikAlignReference})." ";  #The input reference file  
	print $FILEHANDLE "-hs 15 ";  #The hash size
	print $FILEHANDLE "-mem 24 ";  #The amount memory used when sorting hashes
	say $FILEHANDLE "-out ".catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{mosaikJumpDbStub}."_".$randomInteger), "\n";  #Mosaik JumpDbStub for the output filenames

	for (my $fileEndingsCounter=0;$fileEndingsCounter<scalar(@{$mosaikJumpDbStubFileEndingsArrayRef});$fileEndingsCounter++) {  #All MosaikJumpDb assocaiated files

	    my $intendedFilePath = catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{mosaikJumpDbStub}.${$mosaikJumpDbStubFileEndingsArrayRef}[$fileEndingsCounter]);
	    my $temporaryFilePath = catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{mosaikJumpDbStub}."_".$randomInteger.${$mosaikJumpDbStubFileEndingsArrayRef}[$fileEndingsCounter]);

	    ## Checks if a file exists and moves the file in place if file is lacking or has a size of 0 bytes.
	    &PrintCheckExistandMoveFile($FILEHANDLE, \$intendedFilePath, \$temporaryFilePath);
	}	
	
	say $FILEHANDLE "rm -rf ".catfile("scratch", "mosaik_tmp"), "\n";  #Cleaning up temp directory
    }
    close($FILEHANDLE);
    
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	&FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
		       sampleInfoHashRef => $sampleInfoHashRef,
		       jobIDHashRef => $jobIDHashRef,
		       infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		       dependencies => 6, 
		       path => ${$parameterHashRef}{"p".$programName}{chain},
		       sbatchFileName => $fileName
		      });
    }
}


sub CheckBuildHumanGenomePreRequisites {

##CheckBuildHumanGenomePreRequisites
    
##Function : Checks if the HumanGenomePreRequisites needs to be built
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $supportedCosmidReferenceHashRef, $programName
##         : $parameterHashRef                => The parameter hash {REF}
##         : $scriptParameterHashRef          => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef               => Info on samples and family hash {REF}
##         : $fileInfoHashRef                 => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef      => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef                    => The jobID hash {REF}
##         : $supportedCosmidReferenceHashRef => The supported cosmid references hash {REF}
##         : $programName                     => Program name  

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $supportedCosmidReferenceHashRef = ${$argHashRef}{supportedCosmidReferenceHashRef};
    my $programName = ${$argHashRef}{programName};

    foreach my $fileEnding (@{${$fileInfoHashRef}{humanGenomeReferenceFileEndings}}) {  #Files assocaiated with human genome reference

	if ( (${$parameterHashRef}{"humanGenomeReference".$fileEnding}{buildFile} eq 1) || (${$fileInfoHashRef}{humanGenomeCompressed} eq "compressed") ) {
	   
	    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} != 1)) {
	
		## Creates the humanGenomePreRequisites using scriptParameters{humanGenomeReference} as reference.
		&BuildHumanGenomePreRequisites({parameterHashRef => $parameterHashRef,
						scriptParameterHashRef => $scriptParameterHashRef,
						sampleInfoHashRef => $sampleInfoHashRef,
						fileInfoHashRef => $fileInfoHashRef,
						infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
						jobIDHashRef => $jobIDHashRef,
						supportedCosmidReferenceHashRef => $supportedCosmidReferenceHashRef,
						familyID => ${$scriptParameterHashRef}{familyID},
						alignerOutDir => ${$scriptParameterHashRef}{alignerOutDir},
						program => $programName,
					       });
		last;#Will handle all metafiles build within sbatch script
	    }
	}
    }
}


sub CheckBuildPTCHSMetricPreRequisites {

##CheckBuildPTCHSMetricPreRequisites
    
##Function : Check if PicardToolsHSMetricsPrequisites needs to be built
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $programName, $FILEHANDLE, $familyIDRef
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The associated reference file endings {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $programName                => Program name
##         : $FILEHANDLE                 => Filehandle to write to
##         : $familyIDRef                => The familyIDRef {REF}

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $programName = ${$argHashRef}{programName};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    if (${$parameterHashRef}{exomeTargetBed}{buildFile} eq 1) {
	
	&BuildPTCHSMetricPreRequisites({parameterHashRef => $parameterHashRef,
					scriptParameterHashRef => $scriptParameterHashRef,
					sampleInfoHashRef => $sampleInfoHashRef,
					fileInfoHashRef => $fileInfoHashRef,
					infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
					jobIDHashRef => $jobIDHashRef,
					programName => $programName,
					FILEHANDLE => $FILEHANDLE,
				       });
	
	${$parameterHashRef}{exomeTargetBed}{buildFile} = 0;  #Only build once for all modules and files
    }
}


sub DownloadReference {
     
##DownloadReference
    
##Function : Downloads reference(s) using the database download manager Cosmid.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $supportedCosmidReferenceHashRef, $cosmidResourceDirectoryRef, $programRef, $FILEHANDLE, $parameterName, $cosmidResourceDirectoryRef
##         : $parameterHashRef                 => The parameter hash {REF}
##         : $scriptParameterHashRef           => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef                => Info on samples and family hash {REF}
##         : $infilesLaneNoEndingHashRef       => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef                     => The jobID hash {REF}
##         : $supportedCosmidReferenceHashRef  => The supported cosmid references hash {REF}
##         : $cosmidResourceDirectoryRef       => Cosmid directory {REF}
##         : $programRef                       => Program under evaluation {REF}
##         : $FILEHANDLE                       => Filehandle to write to
##         : $parameterName                    => Parameter to use for download

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $supportedCosmidReferenceHashRef = ${$argHashRef}{supportedCosmidReferenceHashRef};
    my $cosmidResourceDirectoryRef = ${$argHashRef}{cosmidResourceDirectoryRef};
    my $programRef = ${$argHashRef}{programRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $parameterName = ${$argHashRef}{parameterName};

    my @vtReferences = ("indels", "mills", "dbsnp", "hapmap", "dbsnpex", "1000g_snps");  #Should be decomposed and normalzed using vt out of downloadable references using Cosmid
 
    if (${$parameterHashRef}{$parameterName}{buildFile} eq 1) {  #Reference need to be built a.k.a downloaded
	
	## Use $parameter instead of $scriptParameter to cater for annotation files that are arrays and not supplied as flag => value
	if (defined(${$scriptParameterHashRef}{$parameterName})) {

	    $logger->warn("Will try to download ".${$scriptParameterHashRef}{$parameterName}." before executing ".$$programRef."\n");
	}
	else {

	    $logger->warn("Will try to download ".$parameterName." before executing ".$$programRef."\n");
	}

	print $FILEHANDLE "cosmid ";  #Database download manager
	print $FILEHANDLE "clone ";  #Clone resource
	print $FILEHANDLE ${$supportedCosmidReferenceHashRef}{$parameterName}{cosmidName};  #The actual reference

	unless (${$supportedCosmidReferenceHashRef}{$parameterName}{version} eq "latest") {  #Version to download

	    print $FILEHANDLE "#".${$supportedCosmidReferenceHashRef}{$parameterName}{version},
	}
	say $FILEHANDLE "\n"; 

	## Check if reference comes decompressed or not
	if (${$supportedCosmidReferenceHashRef}{$parameterName}{compressedSwitch} eq "compressed") {

	    ## Clear trap for signal(s)
	    &ClearTrap({FILEHANDLE => $FILEHANDLE,
		       });
	    
	    print $FILEHANDLE "gzip ";
	    print $FILEHANDLE "-d ";  #Decompress
	    say $FILEHANDLE catfile($$cosmidResourceDirectoryRef, ${$supportedCosmidReferenceHashRef}{$parameterName}{cosmidName}, "*.gz"), "\n";

	    ## Enable trap for signal(s) and function
	    &EnableTrap({FILEHANDLE => $FILEHANDLE,
			});
	}

	my $temporaryFilePath = catfile($$cosmidResourceDirectoryRef, ${$supportedCosmidReferenceHashRef}{$parameterName}{cosmidName}, "*");

	if ( ( any {$_ eq ${$supportedCosmidReferenceHashRef}{$parameterName}{cosmidName}} @vtReferences ) ) {  #If element is part of array

	    ## Split multi allelic records into single records and normalize
	    &VTCore({scriptParameterHashRef => $scriptParameterHashRef,
		     sampleInfoHashRef => $sampleInfoHashRef,
		     infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
		     jobIDHashRef => $jobIDHashRef,
		     FILEHANDLE => $FILEHANDLE,
		     infilePath => catfile($$cosmidResourceDirectoryRef, ${$supportedCosmidReferenceHashRef}{$parameterName}{cosmidName}, "*"),
		     outfilePath => catfile($$cosmidResourceDirectoryRef, ${$supportedCosmidReferenceHashRef}{$parameterName}{cosmidName}, ${$scriptParameterHashRef}{$parameterName}),
		     decompose => ${$scriptParameterHashRef}{VTDecompose},
		     normalize => ${$scriptParameterHashRef}{VTNormalize},
		    });
	    $temporaryFilePath = catfile($$cosmidResourceDirectoryRef, ${$supportedCosmidReferenceHashRef}{$parameterName}{cosmidName}, ${$scriptParameterHashRef}{$parameterName});
	}

	my $intendedFilePath;
	## Use $parameter instead of $scriptParameter to cater for annotation files that are arrays and not supplied as flag => value
	if (defined(${$scriptParameterHashRef}{$parameterName})) {
	  
	    $intendedFilePath = catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{$parameterName});
	}
	else {
	    
	    $intendedFilePath = catfile(${$scriptParameterHashRef}{referencesDir}, $parameterName);
	}

	## Checks if a file exists and moves the file in place if file is lacking or has a size of 0 bytes.
	&PrintCheckExistandMoveFile($FILEHANDLE, \$intendedFilePath, \$temporaryFilePath);	

	## Remove temporary Cosmid resources directory
	print $FILEHANDLE "rm -rf ";
	say $FILEHANDLE catfile($$cosmidResourceDirectoryRef, ${$supportedCosmidReferenceHashRef}{$parameterName}{cosmidName}, ";"), "\n";

	## Clear trap for signal(s)
	&ClearTrap({FILEHANDLE => $FILEHANDLE,
		   });

	## Remove temporary Cosmid ".cosmid.yaml" file
	print $FILEHANDLE "rm ";
	say $FILEHANDLE catfile($$cosmidResourceDirectoryRef, ".cosmid.yaml"), "\n";

	## Enable trap for signal(s) and function
	&EnableTrap({FILEHANDLE => $FILEHANDLE,
		    });

	for my $supportedParameterName (keys %{$supportedCosmidReferenceHashRef}) {

	    if (${$supportedCosmidReferenceHashRef}{$supportedParameterName}{cosmidName} eq ${$supportedCosmidReferenceHashRef}{$parameterName}{cosmidName}) {  #Reset to 0 for all supportedCosmidReference that are shared between modules 
		
		${$parameterHashRef}{$supportedParameterName}{buildFile} = 0;  #Only need to download once per analysis call
	    }
	}
    }
}


sub BuildHumanGenomePreRequisites {

##BuildHumanGenomePreRequisites
    
##Function : Creates the humanGenomePreRequisites using scriptParameters{humanGenomeReference} as reference.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $humanGenomeReferenceFileEndingsArrayRef, $familyIDRef, $alignerOutDirRef, $program, $FILEHANDLE, $randomInteger, $humanGenomeReferenceRef
##         : $parameterHashRef                => The parameter hash {REF}
##         : $scriptParameterHashRef          => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef               => Info on samples and family hash {REF}
##         : $fileInfoHashRef                 => The fileInfo hash {REF}
##         : $infilesLaneNoEndingHashRef      => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef                    => The jobID hash {REF}
##         : $supportedCosmidReferenceHashRef => The supported cosmid references hash {REF}
##         : $familyIDRef                     => Family ID {REF}
##         : $alignerOutDirRf                 => The alignerOutDir used in the analysis
##         : $program                         => The program under evaluation
##         : $FILEHANDLE                      => Filehandle to write to. A new sbatch script will be generated if $FILEHANDLE is lacking, else write to exising $FILEHANDLE
##         : $randomInteger                   => The random integer to create temporary file name
##         : $humanGenomeReferenceRef         => Human genome reference {REF}

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    my $humanGenomeReferenceRef = ${$argHashRef}{'humanGenomeReferenceRef'} //= \${$argHashRef}{'scriptParameterHashRef'}{'humanGenomeReference'},

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $supportedCosmidReferenceHashRef = ${$argHashRef}{supportedCosmidReferenceHashRef};
    my $program = ${$argHashRef}{program};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $randomInteger = ${$argHashRef}{randomInteger};
    
    my $fileName;

    unless(defined($FILEHANDLE)) {  #No supplied FILEHANDLE i.e. create new sbatch script

	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
	$randomInteger = int(rand(10000));  #Generate a random integer between 0-10,000.

	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
					    jobIDHashRef => $jobIDHashRef,
					     FILEHANDLE => $FILEHANDLE,
					     directoryID => $$familyIDRef,
					     programName => $program,
					     programDirectory => lc($$alignerOutDirRef),
					    });
    }

    say $FILEHANDLE "cd $$referencesDirRef", "\n";  #Move to reference directory

    ## Locates and sets the cosmid directory to download to
    my $cosmidResourceDirectory = &CheckCosmidYAML($scriptParameterHashRef);

    &DownloadReference({parameterHashRef => $parameterHashRef,
			scriptParameterHashRef => $scriptParameterHashRef,
			sampleInfoHashRef => $sampleInfoHashRef,
			infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			jobIDHashRef => $jobIDHashRef,
			supportedCosmidReferenceHashRef => $supportedCosmidReferenceHashRef,
			cosmidResourceDirectoryRef => \$cosmidResourceDirectory,
			programRef => \$program,
			FILEHANDLE => $FILEHANDLE,
			parameterName => "humanGenomeReference",
		       });

    ## Check for compressed files
    if (${$fileInfoHashRef}{humanGenomeCompressed} eq "compressed") {

	$logger->warn("Will try to decompres ".$$humanGenomeReferenceRef." before executing ".$program."\n");

	## Clear trap for signal(s)
	&ClearTrap({FILEHANDLE => $FILEHANDLE,
		   });

	print $FILEHANDLE "gzip ";
	print $FILEHANDLE "-d ";  #Decompress
	say $FILEHANDLE catfile($$referencesDirRef, $$humanGenomeReferenceRef), "\n";

	## Enable trap for signal(s) and function
	&EnableTrap({FILEHANDLE => $FILEHANDLE,
		    });
	
	$$humanGenomeReferenceRef =~ s/.fasta.gz/.fasta/g;  #Replace the .fasta.gz ending with .fasta since this will execute before the analysis, hence changing the original file name ending from ".fastq" to ".fastq.gz".
	$logger->info("Set humanGenomeReference to: ".$$humanGenomeReferenceRef, "\n");
	${$fileInfoHashRef}{humanGenomeCompressedRef} = "unCompressed";
    }
    
    &CheckBuildPTCHSMetricPreRequisites({$parameterHashRef => $parameterHashRef,
					 scriptParameterHashRef => $scriptParameterHashRef,
					 sampleInfoHashRef => $sampleInfoHashRef,
					 fileInfoHashRef => $fileInfoHashRef,
					 infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
					 jobIDHashRef => $jobIDHashRef,
					 programName => $program,
					 FILEHANDLE => $FILEHANDLE,
					});
    
    for (my $fileEndingsCounter=0;$fileEndingsCounter<scalar(@{${$fileInfoHashRef}{humanGenomeReferenceFileEndings}});$fileEndingsCounter++) {  #All meta files    
	
	if (${$parameterHashRef}{"humanGenomeReference.dict"}{buildFile} eq 1) {  #.dict file
	    
	    $logger->warn("Will try to create dict file for ".$$humanGenomeReferenceRef." before executing ".$program."\n");
	    
	    say $FILEHANDLE "#CreateSequenceDictionary from reference";
	    &JavaCore({FILEHANDLE => $FILEHANDLE,
		       memoryAllocation => "Xmx2g",
		       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		       javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
		       javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
		      });
	    
	    print $FILEHANDLE "CreateSequenceDictionary ";
	    print $FILEHANDLE "R=".catfile($$referencesDirRef, $$humanGenomeReferenceRef)." ";  #Reference genome
	    say $FILEHANDLE "OUTPUT=".catfile($$referencesDirRef, ${$fileInfoHashRef}{humanGenomeReferenceNameNoEnding}."_".$randomInteger.".dict"), "\n";  #Output sequence dictionnary
	    
	    my $intendedFilePath = catfile($$referencesDirRef, ${$fileInfoHashRef}{humanGenomeReferenceNameNoEnding}.".dict");  
	    my $temporaryFilePath = catfile($$referencesDirRef, ${$fileInfoHashRef}{humanGenomeReferenceNameNoEnding}."_".$randomInteger.".dict");

	    ## Checks if a file exists and moves the file in place if file is lacking or has a size of 0 bytes.
	    &PrintCheckExistandMoveFile($FILEHANDLE, \$intendedFilePath, \$temporaryFilePath);
	    
	    ${$parameterHashRef}{"humanGenomeReference.dict"}{buildFile} = 0;  #Only create once
	    
	}
	if (${$parameterHashRef}{"humanGenomeReference.fasta.fai"}{buildFile} eq 1) {
	    
	    $logger->warn("Will try to create .fai file for ".$$humanGenomeReferenceRef." before executing ".$program."\n");
	    
	    say $FILEHANDLE "## Fai file from reference";
	    print $FILEHANDLE "ln -s ";  #Softlink
	    print $FILEHANDLE catfile($$referencesDirRef, $$humanGenomeReferenceRef)." ";  #Reference genome
	    say $FILEHANDLE catfile($$referencesDirRef, $$humanGenomeReferenceRef."_".$randomInteger), "\n";  #Softlink to Reference genome
	    
	    print $FILEHANDLE "samtools faidx ";#index/extract FASTA
	    say $FILEHANDLE catfile($$referencesDirRef, $$humanGenomeReferenceRef."_".$randomInteger), "\n";  #Softlink to Reference genome
	    
	    my $intendedFilePath = catfile($$referencesDirRef, ${$fileInfoHashRef}{humanGenomeReferenceNameNoEnding}.".fasta.fai");
	    my $temporaryFilePath = catfile($$referencesDirRef, $$humanGenomeReferenceRef."_".$randomInteger.".fai");

	    ## Checks if a file exists and moves the file in place if file is lacking or has a size of 0 bytes.
	    &PrintCheckExistandMoveFile($FILEHANDLE, \$intendedFilePath, \$temporaryFilePath);
	    
	    print $FILEHANDLE "rm ";  #Remove softLink
	    say $FILEHANDLE catfile($$referencesDirRef, $$humanGenomeReferenceRef."_".$randomInteger), "\n";  #Softlink to reference genome
	    
	    ${$parameterHashRef}{"humanGenomeReference.fasta.fai"}{buildFile} = 0;  #Only create once	
	}
    }
    unless($_[7]) {  #Unless FILEHANDLE was supplied close it and submit 
	
	close($FILEHANDLE);
    
	if ( (${$scriptParameterHashRef}{"p".$program} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			   sampleInfoHashRef => $sampleInfoHashRef,
			   jobIDHashRef => $jobIDHashRef,
			   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			   dependencies => 6, 
			   path => "MIP",
			   sbatchFileName => $fileName
			  });
	}
    }
}


sub CheckCosmidInstallation {

##CheckCosmidInstallation
    
##Function : Check that a Cosmid installation exists
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $parameterNameRef
##         : $parameterHashRef                => The parameter hash {REF}
##         : $scriptParameterHashRef          => The active parameters for this analysis hash {REF}
##         : $supportedCosmidReferenceHashRef => Suported Cosmid references {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;
    my $supportedCosmidReferenceHashRef;
    
    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	supportedCosmidReferenceHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$supportedCosmidReferenceHashRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $whichReturn;

    for my $parameterName (keys %{$supportedCosmidReferenceHashRef}) {

	if (${$parameterHashRef}{$parameterName}{buildFile} eq 1) {
	 
	    $logger->info("Checking your Cosmid installation in preparation for download of ".${$scriptParameterHashRef}{$parameterName}."\n");
	    
	    $whichReturn = `which cosmid;`;

	    if ($whichReturn eq "") {
		
		$logger->fatal("MIP uses cosmid to download ".${$scriptParameterHashRef}{$parameterName}." and MIP could not find a cosmid installation in your environment ","\n"); 
		exit 1;
	    }
	    else {  #Test ok
		
		$logger->info("Found installation in ".$whichReturn);
	    }
	    last;  #Only need to check once per analysis run
	}
    }
}


sub ReadPlinkPedigreeFile {

##ReadPlinkPedigreeFile
    
##Function : Reads familyID_pedigree file in PLINK format. Checks for pedigree data for allowed entries and correct format. Add data to sampleInfo depending on user info. 
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $supportedCaptureKitHashRef, $filePath, $familyIDRef
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The associated reference file endings {REF}
##         : $supportedCaptureKitHashRef => The supported capture kits hash {REF}
##         : $filePath                   => Pedigree file path
##         : $familyIDRef                => FamilyID {RF}
###FORMAT: FamliyID\tSampleID\tFather\tMother\tSex(1=male; 2=female; other=unknown)\tPhenotype(-9 missing, 0 missing, 1 unaffected, 2 affected)..n

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};

    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;
    my $sampleInfoHashRef;
    my $fileInfoHashRef;
    my $supportedCaptureKitHashRef;
    my $filePath;

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	sampleInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$sampleInfoHashRef},
	fileInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$fileInfoHashRef},
	supportedCaptureKitHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$supportedCaptureKitHashRef},
	filePath => { required => 1, defined => 1, strict_type => 1, store => \$filePath},
	familyIDRef => { default => \$$, strict_type => 1},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];
    
    my %exomtargetBedTestFileTracker;  #Use to collect which sampleIDs have used a certain capture_kit
    my @pedigreeFileElements = ("FamilyID", "SampleID", "Father", "Mother", "Sex", "Phenotype", );
    my @pedigreeSampleIDs;
    my $familyID;
    my $sampleID;
    
    ## Determine if the user supplied info on parameter either via cmd or config
    my $userSampleIDsSwitch = &CheckUserSuppliedInfo({scriptParameterHashRef => $scriptParameterHashRef,
						      dataRef => \@{${$parameterHashRef}{sampleIDs}{value}},
						      parameterName => "sampleIDs",
						     });
    ## Determine if the user supplied info on parameter either via cmd or config
    my $userExomeTargetBedSwitch = &CheckUserSuppliedInfo({scriptParameterHashRef => $scriptParameterHashRef,
							   dataRef => ${$parameterHashRef}{exomeTargetBed}{value},
							   parameterName => "exomeTargetBed",
							  });
    
    ## Defines which entries are allowed and links them to position.
    my %plinkPedigree = &DefinePlinkPedigree();  #Holds allowed entries and positions to be checked for Plink pedigree files
    
    open(my $PEDF, "<", $filePath) or $logger->logdie("Can't open '".$filePath."': ".$!."\n");    
    
    while (<$PEDF>) {
	
	chomp $_;  #Remove newline
	
	if ( ($. == 1) && ($_ =~/^\#/) ) {  #Header present overwrite @pedigreeFileElements with header info
	    
	    @pedigreeFileElements = split("\t", $'); #')
		next;
	}
	if (m/^\s+$/) {  # Avoid blank lines
	    next;
	}
	if (m/^\#/) {  # Avoid "#"
	    next;
        }		
	if ($_ =~/(\S+)/) {	
	    
	    my @lineInfo = split("\t",$_);  #Loads pedigree file info
	    
	    ##Need to parse familyID and sampleID separately since these have not been set yet
	    if ($lineInfo[0] =~/\S+/) {  #FamilyID
		
		$familyID = $lineInfo[0];
		if ($familyID ne ${$scriptParameterHashRef}{familyID}) {

		    $logger->fatal("File: ".$filePath." at line ".$.." pedigree FamilyID: '".$familyID."' and supplied FamilyId: '".${$scriptParameterHashRef}{familyID}."' does not match\n");
		    exit 1;
		}
	    }
	    else {

		$logger->fatal("File: ".$filePath." at line ".$.." cannot find FamilyID in column 1\n");
		exit 1;
	    }
	    if ($lineInfo[1] =~/\S+/) { #SampleID

		$sampleID = $lineInfo[1];		

		if ($userSampleIDsSwitch == 0) {

		    push(@{${$scriptParameterHashRef}{sampleIDs}}, $lineInfo[1]);  #Save sampleID info
		}
		else {  #Save sampleIDs in pedigree to check that user supplied info and sampleID in pedigree match

		    push(@pedigreeSampleIDs, $lineInfo[1]); #Save pedigree sampleID info 
		}
	    }
	    else {

		$logger->fatal("File: ".$filePath." at line ".$.." cannot find SampleID in column 2\n");
		exit 1;
	    }
	    for (my $sampleElementsCounter=0;$sampleElementsCounter<scalar(@pedigreeFileElements);$sampleElementsCounter++) {  #All pedigreeFileElements
		
		if ( defined($lineInfo[$sampleElementsCounter]) && ($lineInfo[$sampleElementsCounter] =~/\S+/) ) {  #Check that we have an non blank entry
		    
		    ## Test element for being part of hash of array at supplied key.
		    if (&CheckEntryHashofArray({hashRef => \%plinkPedigree,
						key => $sampleElementsCounter,
						element => $lineInfo[$sampleElementsCounter],
					       })
			) {
			
			$logger->fatal("Found illegal element: '".$lineInfo[$sampleElementsCounter]."' in column '".$sampleElementsCounter."' in pedigree file: '".$filePath."' at line '".$.."'\n");
			$logger->fatal("Please correct the entry before analysis.\n");
			$logger->fatal("\nMIP: Aborting run.\n\n");
			exit 1;
		    }
		    
		    my @elementInfo = split(";", $lineInfo[$sampleElementsCounter]);  #Split element (if required)

		    if ($sampleElementsCounter < 6) {  #Mandatory elements known to be key->value
			
			${$sampleInfoHashRef}{$familyID}{$sampleID}{$pedigreeFileElements[$sampleElementsCounter]} = $lineInfo[$sampleElementsCounter];
		    }	
		    else {  #Other elements treat as lists

			## Detects if there are elements in arrayQueryRef that are not present in scalarQueryRef or arrayToCheckRef. If unique adds the unique element to arrayToCheckRef.
			&CheckUniqueArrayElement({arrayToCheckRef => \@{ ${$sampleInfoHashRef}{$familyID}{$sampleID}{$pedigreeFileElements[$sampleElementsCounter]} },
						  queryRef => \@elementInfo,
						 });  #Check if there are any new info and add it to sampleInfo if so. 
		    }
		    if (${$sampleInfoHashRef}{$familyID}{$sampleID}{Capture_kit} && $pedigreeFileElements[$sampleElementsCounter] eq "Capture_kit") {  #Add latest capture kit for each individual
			
			my $captureKit = ${$sampleInfoHashRef}{$familyID}{$sampleID}{$pedigreeFileElements[$sampleElementsCounter]}[-1];  #Use only the last capture kit since it should be the most interesting
			
			
			## Return a capture kit depending on user info
			my $exomeTargetBedFile = &AddCaptureKit({fileInfoHashRef => $fileInfoHashRef,
								 supportedCaptureKitHashRef => $supportedCaptureKitHashRef, 
								 captureKit => $captureKit, 
								 userSuppliedParameterswitch => $userExomeTargetBedSwitch,
								});
			if($exomeTargetBedFile) {
			    
			    push(@{$exomtargetBedTestFileTracker{$exomeTargetBedFile}}, $sampleID);
			   
			}
		    }
		}
		else {  #No entry in pedigre file element
		    
		    if ($sampleElementsCounter < 6) {  #Only check mandatory elements 
			
			$logger->fatal($pedigreeFileElements[$sampleElementsCounter], "\t File: ".$filePath." at line ".$.."\tcannot find '".$pedigreeFileElements[$sampleElementsCounter]."' entry in column ".$sampleElementsCounter, "\n");
			exit 1;
		    }  
		}
	    }
	}	
    }
    if ($userSampleIDsSwitch == 0) {
	
	@{${$scriptParameterHashRef}{sampleIDs}} = sort(@{${$scriptParameterHashRef}{sampleIDs}});  #Lexiographical sort to determine the correct order of ids indata
    }
    else { #Check that CLI supplied sampleID exists in pedigree

	## Prepare CLI supplied sampleIDs if comma sep
	my $valuesArrayRef = \@{${$parameterHashRef}{sampleIDs}{value}};
	my $elementSeparatorRef = \${$parameterHashRef}{sampleIDs}{elementSeparator};
	my @tempSampleIDs = split($$elementSeparatorRef, join($$elementSeparatorRef, @{$valuesArrayRef}) );

	foreach my $sampleID (@tempSampleIDs) {  
	    
	    if (! ( any {$_ eq $sampleID} @pedigreeSampleIDs ) ) {  #If element is not part of array
		
		$logger->fatal("Provided sampleID: ".$sampleID." is not present in pedigree file: ".$filePath, "\n");
		exit 1;
	    }
	}
    }
    if(%exomtargetBedTestFileTracker) {  #We have read capture kits from pedigree and neded to transfer to scriptParameters

	foreach my $exomeTargetBedFile (keys %exomtargetBedTestFileTracker) {

	    ${$scriptParameterHashRef}{exomeTargetBed}{$exomeTargetBedFile} = join(",", @{$exomtargetBedTestFileTracker{$exomeTargetBedFile}});
	}
    }
    $logger->info("Read pedigree file: ".$filePath, "\n");
    close($PEDF);
}


sub DefinePlinkPedigree {

##DefinePlinkPedigree
    
##Function : Defines which entries are allowed and links them to position.
##Returns  : "%plinkPedigree"
##Arguments: 
##         : 

    my %plinkPedigree;

    $plinkPedigree{4} = [1, 2, "other"];  #Sex allowed entries
    $plinkPedigree{5} = [-9, 0, 1, 2];  #Phenotype allowed entries

    return %plinkPedigree
}


sub AddToJobID {

##AddToJobID
    
##Function : Adds all previous jobIds per familyChainKey and chainKey to jobIDs string used to set the dependency in SLURM.
##Returns  : "$jobIDs"
##Arguments: $jobIDHashRef, $familyIDChainKey, $chainKey
##         : $jobIDHashRef     => The info on jobIds hash {REF}
##         : $familyIDChainKey => Family ID chain hash key
##         : $chainKey         => The current chain hash key

    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $jobIDHashRef;
    my $familyIDChainKey;
    my $chainKey;
    
     my $tmpl = { 
	jobIDHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$jobIDHashRef},
	familyIDChainKey => { required => 1, defined => 1, strict_type => 1, store => \$familyIDChainKey},
	chainKey => { required => 1, defined => 1, strict_type => 1, store => \$chainKey},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];
    
    my $jobIDs = "";  #JobID string
    
    if (${$jobIDHashRef}{$familyIDChainKey}{$chainKey}) {
	
	for (my $jobCounter=0;$jobCounter<scalar( @{ ${$jobIDHashRef}{$familyIDChainKey}{$chainKey} });$jobCounter++) {   #All previous jobIDs
	    
	    if ( (! $jobCounter) && (scalar( @{ ${$jobIDHashRef}{$familyIDChainKey}{$chainKey} }) == 1) ) {  #Only 1 previous jobID 
		
		$jobIDs .= ":${$jobIDHashRef}{$familyIDChainKey}{$chainKey}[$jobCounter]";  #First and last jobID start with ":" and end without ":"
	    }
	    elsif (! $jobCounter) {  #First jobID
		
		$jobIDs .= ":${$jobIDHashRef}{$familyIDChainKey}{$chainKey}[$jobCounter]:";  #First jobID start with :
	    }
	    elsif ($jobCounter eq (scalar( @{ ${$jobIDHashRef}{$familyIDChainKey}{$chainKey} }) -1) ) {  #Last jobID
		
		$jobIDs .= "${$jobIDHashRef}{$familyIDChainKey}{$chainKey}[$jobCounter]";  #Last jobID finish without :
	    }
	    else {  #JobIDs in the middle
		
		$jobIDs .= "${$jobIDHashRef}{$familyIDChainKey}{$chainKey}[$jobCounter]:";
	    }
	}
    }
    return $jobIDs;
}


sub PushToJobID {

##PushToJobID
    
##Function : Saves JobId to the correct hash array depending on chaintype.
##Returns  : ""
##Arguments: $scriptParameterHashRef, $sampleInfoHashRef, $jobIDHashRef, $infilesLaneNoEndingHashRef, $familyIDChainKey, $sampleIDChainKey, $sampleID, $familyIDRef, $path, $chainKeyType
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $jobIDHashRef               => The info on jobIds hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $familyIDChainKey           => Family ID chain hash key
##         : $sampleIDChainKey           => Sample ID chain hash key
##         : $sampleID                   => Sample ID
##         : $familyIDRef                => Family id {REF}
##         : $path                       => Trunk or branch
##         : $chainKeyType               => "parallel", "merged" or "family_merged"

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    
    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $sampleInfoHashRef;
    my $infilesLaneNoEndingHashRef;
    my $jobIDHashRef;
    my $parallelChainsArrayRef;
    my $familyIDChainKey;
    my $sampleIDChainKey;
    my $sampleID;
    my $path;
    my $chainKeyType;

    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	sampleInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$sampleInfoHashRef},
	infilesLaneNoEndingHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$infilesLaneNoEndingHashRef},
	jobIDHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$jobIDHashRef},
	parallelChainsArrayRef => { default => [], strict_type => 1, store => \$parallelChainsArrayRef},
	familyIDChainKey => { required => 1, defined => 1, strict_type => 1, store => \$familyIDChainKey},
	sampleIDChainKey => { required => 1, defined => 1, strict_type => 1, store => \$sampleIDChainKey},
	sampleID => { strict_type => 1, store => \$sampleID},
	path => { required => 1, defined => 1, strict_type => 1, store => \$path},
	chainKeyType => { required => 1, defined => 1,
			  allow => ["parallel", "merged", "family_merged"],
			  strict_type => 1, store => \$chainKeyType},
	familyIDRef => { default => \$$, strict_type => 1, store => \$familyIDRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];
    
    my $chainKey;
    
    if ($chainKeyType eq "parallel") {  #Push parallel jobs

	if (${$scriptParameterHashRef}{analysisType} eq "rapid" && ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{pBwaMem}{sbatchBatchProcesses}) {  #Rapid run

	    for (my $sbatchCounter=0;$sbatchCounter<${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{pBwaMem}{sbatchBatchProcesses};$sbatchCounter++) {  #Iterate over sbatch processes instead of infile(s)

		$chainKey = $sampleID."_".$chainKeyType."_".$path.$sbatchCounter;  #Set key

		if (${$jobIDHashRef}{$familyIDChainKey}{$chainKey}) {  #Job exists
		    
		    for (my $jobCounter=0;$jobCounter<scalar( @{ ${$jobIDHashRef}{$familyIDChainKey}{$chainKey} });$jobCounter++) {  #All previous jobs i.e. jobs in this case equals to infiles in number
			
			push ( @{ ${$jobIDHashRef}{$familyIDChainKey}{$sampleIDChainKey} }, ${$jobIDHashRef}{$familyIDChainKey}{$chainKey}[$jobCounter]);  #Add jobID to hash
		    }    
		}
	    }	
	    ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{pBwaMem}{sbatchBatchProcesses} = ();
	}
	else {

	    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infilesLaneNoEndingHashRef}{$sampleID} });$infileCounter++) {  #All infiles
		
		$chainKey = $sampleID."_".$chainKeyType."_".$path.$infileCounter;  #Set key
		
		if (${$jobIDHashRef}{$familyIDChainKey}{$chainKey}) {  #Job exists
		    
		    for (my $jobCounter=0;$jobCounter<scalar( @{ ${$jobIDHashRef}{$familyIDChainKey}{$chainKey} });$jobCounter++) {  #All previous jobs i.e. jobs in this case equals to infiles in number
			
			push ( @{ ${$jobIDHashRef}{$familyIDChainKey}{$sampleIDChainKey} }, ${$jobIDHashRef}{$familyIDChainKey}{$chainKey}[$jobCounter]);  #Add jobID to hash
		    }    
		}
	    }
	}
    }
    elsif ( ($chainKeyType eq "merged") || ($chainKeyType eq "family_merged")  ) {  #Push merged jobs
	
	$chainKey = $familyIDChainKey."_".$sampleIDChainKey;  #Set key
	
	if (${$jobIDHashRef}{$familyIDChainKey}{$chainKey}) {  #Job exists
	    
	    for (my $jobCounter=0;$jobCounter<scalar( @{ ${$jobIDHashRef}{$familyIDChainKey}{$chainKey} });$jobCounter++) {  #All previous jobs i.e. jobs in this case equals to infiles in number
		
		if ($chainKeyType eq "family_merged") {  #Use $familyIDChainKey instead of $sampleIDChainKey
		    
		    push ( @{ ${$jobIDHashRef}{$familyIDChainKey}{$familyIDChainKey} }, ${$jobIDHashRef}{$familyIDChainKey}{$chainKey}[$jobCounter]);  #Add jobID hash
		}
		else {
		    push ( @{ ${$jobIDHashRef}{$familyIDChainKey}{$sampleIDChainKey} }, ${$jobIDHashRef}{$familyIDChainKey}{$chainKey}[$jobCounter]);  #Add jobID to hash
		}
	    }    
	}
    }
}


sub FIDSubmitJob {

##FIDSubmitJob
    
##Function : Submits all jobIDs to SLURM using SLURM dependencies. The trunk is the "MAIN path" and any subsequent splits into  branches "other paths" later is handled by adding relevant previous jobIDs to the new paths key in jobID{family_path_key} hash. The subroutine supports parallel job within each step and submission which do not leave any dependencies. Currently any path downstream of MAIN inherits the relevant previous jobIds, but it is possible to merge back to MAIN for splited paths downstream.
##Returns  : ""
##Arguments: $scriptParameterHashRef, $sampleInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $parallelChainsArrayRef, $sampleID, $familyIDRef, $dependencies, $path, $sbatchFileName, $sbatchScriptTracker
##         : $scriptParameterHashRef            => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef                 => Info on samples and family hash {REF}
##         : $infilesLaneNoEndingHashRef        => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef                      => The info on jobIds hash {REF}
##         : $parallelChainsArrayRef            => The info on parallel chains array {REF}
##         : $sampleID                          => Sample id
##         : $familyIDRef                       => Family id {REF}
##         : $dependencies                      => Job dependencies
##         : $path                              => Trunk or Branch part of chainkey
##         : $sbatchFileName                    => Sbatch filename to submit
##         : $sbatchScriptTracker               => Track the number of parallel processes (e.g. sbatch scripts for a module)

###Dependencies
    
##-1 = Not dependent on earlier scripts, and are self cul-de-sâcs
##0 = Not dependent on earlier scripts
##1 = Dependent on earlier scripts (within sampleID_path or familyID_path)
##2 = Dependent on earlier scripts (within sampleID_path or familyID_path), but are self cul-de-sâcs. 
##3 = Dependent on earlier scripts and executed in parallel within step
##4 = Dependent on earlier scripts and parallel scripts and executed in parallel within step 
##5 = Dependent on earlier scripts both family and sample and adds to both familyID and sampleId jobs
##6 = Not dependent on earlier scripts and adds to sampleId jobs and familyId jobs, but sbatch is processed at family level i.e. affects all sampleID jobs e.g. building a reference
##7 = Dependent on all earlier scripts in selected chains for familyID jobs i.e. wait for chains jobs before launching

###Chain
##ALL = Dependent on all earlier scripts in all chains, sampleId and familyID jobs i.e. wait for all before launching

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $jobDependency = ${$argHashRef}{jobDependency} //= "afterok";

    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $sampleInfoHashRef;
    my $infilesLaneNoEndingHashRef;
    my $jobIDHashRef;
    my $parallelChainsArrayRef;
    my $sampleID;
    my $dependencies;
    my $path;
    my $sbatchFileName;
    my $sbatchScriptTracker;

    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	sampleInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$sampleInfoHashRef},
	infilesLaneNoEndingHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$infilesLaneNoEndingHashRef},
	jobIDHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$jobIDHashRef},
	parallelChainsArrayRef => { default => [], strict_type => 1, store => \$parallelChainsArrayRef},
	sampleID => { strict_type => 1, store => \$sampleID},
	dependencies => { required => 1, defined => 1, 
		  allow => [-1, 0, 1, 2, 3, 4, 5, 6, 7],
		  strict_type => 1, store => \$dependencies},
	path => { required => 1, defined => 1, strict_type => 1, store => \$path},
	sbatchFileName => { required => 1, defined => 1, strict_type => 1, store => \$sbatchFileName},
	sbatchScriptTracker => { allow => qr/^\d+$/,
				 strict_type => 1, store => \$sbatchScriptTracker},
	familyIDRef => { default => \$$, strict_type => 1, store => \$familyIDRef},
	jobDependency => { allow => ["afterany", "afterok"],
			   strict_type => 1, store => \$jobDependency},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $sampleIDChainKey;
    my $sampleIDParallelChainKey;
    my $familyIDParallelChainKey;

    if (defined($sampleID)) {

	$sampleIDChainKey = $sampleID."_".$path;  #Sample chainkey
    }
    if ( (defined($sbatchScriptTracker)) ) {

	$familyIDParallelChainKey = $$familyIDRef."_parallel_".$path.$sbatchScriptTracker;  #Family parallel chainkey

	if (defined($sampleID)) {

	    $sampleIDParallelChainKey = $sampleID."_parallel_".$path.$sbatchScriptTracker;  #Sample parallel chainkey
	}
    }
    my $jobIDs = "";  #Create string with all previous jobIDs
    my $jobIDsReturn;  #Return jobID
    my $familyIDChainKey = $$familyIDRef."_".$path;  #Family chainkey
    my $jobID;  #The jobID that is returned from submission
    
    if ($dependencies == -1) {  #Initiate chain - No dependencies, lonely program "sapling"
	
	$jobIDsReturn = `sbatch $sbatchFileName`;  #No jobs have been run: submit
	($jobID) = ($jobIDsReturn =~ /Submitted batch job (\d+)/);  #Just submitted jobID
    }
    if ($dependencies == 6) {  #Initiate chain - No dependencies, adds to all sampleID(s) and familyID
	
	$jobIDsReturn = `sbatch $sbatchFileName`;  #No jobs have been run: submit
	($jobID) = ($jobIDsReturn =~ /Submitted batch job (\d+)/);  #Just submitted jobID
	
	for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {

	    my $sampleIDChainKey =  ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter]."_".$path;
	    push ( @{ ${$jobIDHashRef}{$familyIDChainKey}{$sampleIDChainKey} }, $jobID);  #Add jobID to hash
	    &PushToJobID({scriptParameterHashRef => $scriptParameterHashRef,
			  sampleInfoHashRef => $sampleInfoHashRef,
			  infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			  jobIDHashRef => $jobIDHashRef,
			  familyIDChainKey => $familyIDChainKey,
			  sampleIDChainKey => $sampleIDChainKey,
			  sampleID => $sampleID,
			  path => $path,
			  chainKeyType => "family_merged",
			  });
	}
    }
    elsif ($dependencies == 0) {  #Initiate chain - No dependencies, initiate Trunk (Main or other)
	
	$jobIDsReturn = `sbatch $sbatchFileName`;  #No jobs have been run: submit
	($jobID) = ($jobIDsReturn =~ /Submitted batch job (\d+)/);  #Just submitted jobID
	push ( @{ ${$jobIDHashRef}{$familyIDChainKey}{$sampleIDChainKey} }, $jobID);  #Add jobID to hash
    }
    else {  #Dependent on earlier scripts and/or parallel. JobIDs that do not leave dependencies do not get pushed to jobID hash
	
	if (defined($sampleID)) {  #Check jobs within sampleID (exception if dependencies = 5) 
	    
	    if ($dependencies == 5) {  #Add familyID_sampleID jobs to current sampleID chain
		
		&PushToJobID({scriptParameterHashRef => $scriptParameterHashRef,
			      sampleInfoHashRef => $sampleInfoHashRef,
			      infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			      jobIDHashRef => $jobIDHashRef,
			      familyIDChainKey => $familyIDChainKey,
			      sampleIDChainKey => $sampleIDChainKey,
			      sampleID => $sampleID,
			      path => $path,
			      chainKeyType => "merged",
			     });
	    }
	    if ( ($dependencies == 1) || ($dependencies == 2) ) {  #Not parallel jobs, but check if last job submission was parallel
		
		&PushToJobID({scriptParameterHashRef => $scriptParameterHashRef,
			      sampleInfoHashRef => $sampleInfoHashRef,
			      infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			      jobIDHashRef => $jobIDHashRef,
			      familyIDChainKey => $familyIDChainKey,
			      sampleIDChainKey => $sampleIDChainKey,
			      sampleID => $sampleID,
			      path => $path,
			      chainKeyType => "parallel",
			     });
	    }
	    if ( (defined($path)) && ($path eq "MAIN") ) {
		
		if ( ($dependencies == 4) || ($dependencies == 3) ) {  #Parallel jobs
		    
		    $jobIDs = &AddToJobID({jobIDHashRef => $jobIDHashRef,
					   familyIDChainKey => $familyIDChainKey,
					   chainKey => $sampleIDParallelChainKey,
					  });  #Add to jobID string
    
		    if (${$jobIDHashRef}{$familyIDChainKey}{$sampleIDChainKey}) {  #Check for previous single jobs - required to initiate broken chain with correct dependencies 
               
			$jobIDs .= &AddToJobID({jobIDHashRef => $jobIDHashRef,
						familyIDChainKey => $familyIDChainKey,
						chainKey => $sampleIDChainKey,
					       });  #Add to jobID string
		    }
		    
		}
		else {  #Previous job was a single job
		    
		    $jobIDs = &AddToJobID({jobIDHashRef => $jobIDHashRef,
					   familyIDChainKey => $familyIDChainKey,
					   chainKey => $sampleIDChainKey,
					  });  #Add to jobID string
		}
	    }
	    if ( (defined($path)) && ($path ne "MAIN") ) {  #Check for any previous jobIDs within path current PATH. Branch.
		
		if (${$jobIDHashRef}{$familyIDChainKey}{$sampleIDChainKey}) {  #Second or later in branch chain
		    
		    $jobIDs = &AddToJobID({jobIDHashRef => $jobIDHashRef,
					   familyIDChainKey => $familyIDChainKey,
					   chainKey => $sampleIDChainKey,
					  });
		}
		elsif (${$jobIDHashRef}{$$familyIDRef."_MAIN"}{$sampleID."_MAIN"}) {  #Inherit from potential MAIN. Trunk
		    
		    $jobIDs = &AddToJobID({jobIDHashRef => $jobIDHashRef,
					   familyIDChainKey => $$familyIDRef."_MAIN",
					   chainKey => $sampleID."_MAIN",
					  });
		}
	    }
	    if ( (defined($path)) && ($path eq "ALL") ) {  #Inherit from all previous jobs
		
		$jobIDs = &AddToJobID({jobIDHashRef => $jobIDHashRef,
				       familyIDChainKey => "ALL",
				       chainKey => "ALL",
				      });
	    }
	    if ($jobIDs) {  #Previous jobs for chainkey exists

		$jobIDsReturn = `sbatch --dependency=$jobDependency$jobIDs $sbatchFileName`;  #Supply with dependency of previous jobs that this one is dependent on
		($jobID) = ($jobIDsReturn =~ /Submitted batch job (\d+)/);  #Just submitted jobID
	    }
	    else {  #No previous jobs

		$jobIDsReturn = `sbatch $sbatchFileName`;  #No jobs have been run: submit
		($jobID) = ($jobIDsReturn =~ /Submitted batch job (\d+)/);  #Just submitted jobID
	    }
	    if ($dependencies == 1) {  #Ordinary job push to array
		
		@{ ${$jobIDHashRef}{$familyIDChainKey}{$sampleIDChainKey} } = ();  #Clear latest familyID/sampleID chain submission
		
		##Clear all latest parallel jobs within chainkey
		for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infilesLaneNoEndingHashRef}{$sampleID} });$infileCounter++) {
		    
		    my $sampleIDParallelChainKey = $sampleID."_parallel_".$path.$infileCounter;  #Create key
		    
		    if (${$jobIDHashRef}{$familyIDChainKey}{$sampleIDParallelChainKey}) {  #Parallel job exists
			
			@{ ${$jobIDHashRef}{$familyIDChainKey}{$sampleIDParallelChainKey} } = ();  #Clear latest familyID/sampleID chain submission
                    }
		}
		push ( @{ ${$jobIDHashRef}{$familyIDChainKey}{$sampleIDChainKey} }, $jobID);  #Add jobID to hash{$sampleID}[]
	    }
	    if ( ($dependencies == 3) || ($dependencies == 4) ) {  #Parallel job wait to push to array until all parallel jobs are finished within step
		
		push ( @{ ${$jobIDHashRef}{$familyIDChainKey}{$sampleIDParallelChainKey} }, $jobID);  #Add jobID to hash
	    }
	    if ($dependencies == 5) {  #Job dependent on both familyID and sampleID push to array
		
		@{ ${$jobIDHashRef}{$familyIDChainKey}{$familyIDChainKey."_".$sampleIDChainKey} } = ();  #Clear latest familyID_sampleID chainkey
		@{ ${$jobIDHashRef}{$familyIDChainKey}{$sampleIDChainKey} } = ();  #Clear latest sampleID chainkey
		push ( @{ ${$jobIDHashRef}{$familyIDChainKey}{$familyIDChainKey."_".$sampleIDChainKey} }, $jobID);  #Add jobID to hash
	    }

	    ## Keeps the jobID string dependecy within reasonable limits
	    if ( (defined(${$jobIDHashRef}{"ALL"}{"ALL"})) && (scalar(@{ ${$jobIDHashRef}{"ALL"}{"ALL"} } >= 100)) ) {
		
		shift( @{ ${$jobIDHashRef}{"ALL"}{"ALL"} });  #Remove oldest jobID.
	    }
	    ## Job dependent on all jobs
	    push ( @{ ${$jobIDHashRef}{"ALL"}{"ALL"} }, $jobID);  #Add jobID to hash
	}
	else {  #AFTER merging to familyID
	    
	    if ($dependencies == 5) {  #Add familyID_sampleID jobs to current familyID chain
		
		for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {  #Check jobs for sampleID          
		    
		    my $sampleIDChainKey = ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter]."_".$path;  #Current chain
		    &PushToJobID({scriptParameterHashRef => $scriptParameterHashRef,
				  sampleInfoHashRef => $sampleInfoHashRef,
				  infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
				  jobIDHashRef => $jobIDHashRef,
				  familyIDChainKey => $familyIDChainKey,
				  sampleIDChainKey => $sampleIDChainKey,
				  sampleID => $sampleID,
				  path => $path,
				  chainKeyType => "family_merged",
				 });
		}
	    }
	    if ( ($dependencies == 1) || ($dependencies == 2) ) {  #Not parallel jobs, but check if last job submission was parallel

		foreach my $familyIDParallelChainKey (keys%{ ${$jobIDHashRef}{$familyIDChainKey} }) {
		       
		    $jobIDs .= &AddToJobID({jobIDHashRef => $jobIDHashRef,
					    familyIDChainKey => $familyIDChainKey,
					    chainKey => $familyIDParallelChainKey,
					   });  #Add to jobID string
		    }
	    }
	    if ( (defined($path)) && ($path eq "MAIN") && (${$jobIDHashRef}{$familyIDChainKey}{$familyIDChainKey}) ) {  #Check for any previous jobIDs within path MAIN. Test for previous must be done to allow initiating from broken chain. Trunk and not first in chain

		if ( ($dependencies == 4) || ($dependencies == 3) ) {  #Parallel jobs
		    
		    $jobIDs = &AddToJobID({jobIDHashRef => $jobIDHashRef,
					   familyIDChainKey => $familyIDChainKey,
					   chainKey => $familyIDParallelChainKey,
					  });  #Add to jobID string
		}
		else {  #Previous job was a single job 
		    
		    $jobIDs = &AddToJobID({jobIDHashRef => $jobIDHashRef,
					   familyIDChainKey => $familyIDChainKey,
					   chainKey => $familyIDChainKey,
					  });  #Add to jobID string
		}
		if ($dependencies == 7) {  #Add jobs from other parallel chains that have branched of from MAIN i.e. merge branch back again
			
		    foreach my $parallelChain (@{$parallelChainsArrayRef}) {
			
			$jobIDs .= &AddToJobID({jobIDHashRef => $jobIDHashRef,
						familyIDChainKey => $$familyIDRef."_".$parallelChain,
						chainKey => $$familyIDRef."_".$parallelChain,
					       });  #Add to jobID string
		    }
		}
	    }
	    elsif ((defined($path)) && $path eq "MAIN") {  #First familyID MAIN chain 
		
		##Add all previous jobId(s) from sampleID chainkey(s)
		for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {
		    
		    my $sampleIDChainKey = ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter]."_".$path;
		    
		    if (${$jobIDHashRef}{$familyIDChainKey}{$sampleIDChainKey}) {
			
			$jobIDs .= &AddToJobID({jobIDHashRef => $jobIDHashRef,
						familyIDChainKey => $familyIDChainKey,
						chainKey => $sampleIDChainKey,
					       });  #Add to jobID string, while keeping previous additions
			
		    }
		    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter] } });$infileCounter++) {
			
			my $sampleIDParallelChainKey = ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter]."_parallel_".$path.$infileCounter;  #Create key
			
			if (${$jobIDHashRef}{$familyIDChainKey}{$sampleIDParallelChainKey}) {  #Parallel job exists
			    
			    $jobIDs .= &AddToJobID({jobIDHashRef => $jobIDHashRef,
						    familyIDChainKey => $familyIDChainKey,
						    chainKey => $sampleIDParallelChainKey,
						   });  #Add to jobID string, while keeping previous additions
			}
		    }
		}
	    }
	    if ((defined($path)) && $path ne "MAIN" ) {  #Check for any previous jobIDs within path current PATH. Branch
		
		if (${$jobIDHashRef}{$familyIDChainKey}{$familyIDChainKey}) {  #Second or later in branch chain
		    
		    $jobIDs = &AddToJobID({jobIDHashRef => $jobIDHashRef,
					   familyIDChainKey => $familyIDChainKey,
					   chainKey => $familyIDChainKey,
					  });  #Family chain
		}
		elsif ($dependencies == 7) {  #Add jobs from other parallel chains that have branched of from MAIN i.e. merge branch back again
		    
		    foreach my $parallelChain (@{$parallelChainsArrayRef}) {

			foreach my $sampleID (@{${$scriptParameterHashRef}{sampleIDs}}) {
			    
			    $jobIDs .= &AddToJobID({jobIDHashRef => $jobIDHashRef,
						    familyIDChainKey => $$familyIDRef."_".$parallelChain,
						    chainKey => $sampleID."_".$parallelChain,
						   });  #Add to jobID string
			}

			## Jobs processed per family
			$jobIDs .= &AddToJobID({jobIDHashRef => $jobIDHashRef,
						familyIDChainKey => $$familyIDRef."_".$parallelChain,
						chainKey => $$familyIDRef."_".$parallelChain,
					       });  #Add to jobID string
		    }
		}
		elsif (${$jobIDHashRef}{$$familyIDRef."_MAIN"}{$$familyIDRef."_MAIN"}) {  #Inherit from potential MAIN. Trunk
		    
		    $jobIDs = &AddToJobID({jobIDHashRef => $jobIDHashRef,
					   familyIDChainKey => $$familyIDRef."_MAIN",
					   chainKey => $$familyIDRef."_MAIN",
					  });
		}
		else {  #First job in new path and first familyID MAIN chain 
		    
		    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {
			
			my $familyIDChainKey = $$familyIDRef."_MAIN";
			my $sampleIDChainKey = ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter]."_MAIN";
			
			if (${$jobIDHashRef}{$familyIDChainKey}{$sampleIDChainKey}) {
			    
			    $jobIDs .= &AddToJobID({jobIDHashRef => $jobIDHashRef,
						    familyIDChainKey => $familyIDChainKey,
						    chainKey => $sampleIDChainKey,
						   }); 
			}
		    }
		}
	    }
	    if ( (defined($path)) && ($path eq "ALL") ) {  #Inherit from all previous jobs
		
		$jobIDs = &AddToJobID({jobIDHashRef => $jobIDHashRef,
				       familyIDChainKey => "ALL",
				       chainKey => "ALL",
				      });
	    }
	    if ($jobIDs) {

		$jobIDsReturn = `sbatch --dependency=$jobDependency$jobIDs $sbatchFileName`;  #Supply with dependency of previous jobs that this one is dependent on
		($jobID) = ($jobIDsReturn =~ /Submitted batch job (\d+)/);
	    }
	    else {

		$jobIDsReturn = `sbatch $sbatchFileName`;  #No jobs have been run: submit
		($jobID) = ($jobIDsReturn =~ /Submitted batch job (\d+)/);
	    }
	    if ( ($dependencies == 1) || ($dependencies == 7) ) {  #Ordinary job push to array
		
		@{ ${$jobIDHashRef}{$familyIDChainKey}{$familyIDChainKey} } = ();  #Clear latest familyID/sampleID chain submission
		
		##Clear all latest parallel jobs within chainkey
		foreach my $chainKey (keys%{ ${$jobIDHashRef}{$familyIDChainKey} }) {
			
		    @{ ${$jobIDHashRef}{$familyIDChainKey}{$chainKey} } = ();  #Clear latest familyID/sampleID chain submission		    
		}
		push ( @{ ${$jobIDHashRef}{$familyIDChainKey}{$familyIDChainKey} }, $jobID);  #Add jobID to hash{$$familyIDRef}[]
	    }
	    if ( ($dependencies == 3) || ($dependencies == 4) ) {  #Parallel job wait to push to array until all parallel jobs are finished within step

		push ( @{ ${$jobIDHashRef}{$familyIDChainKey}{$familyIDParallelChainKey} }, $jobID);  #Add jobID to hash{$familyID_parallel}[].
	    }    
	    if ($dependencies == 5) {  #Job dependent on both familyID and sampleID push to array
		
		for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {  #Check jobs for sampleID          
		    
		    my $sampleIDChainKey = ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter]."_".$path;  #Current chain
		    @{ ${$jobIDHashRef}{$familyIDChainKey}{$familyIDChainKey."_".$sampleIDChainKey} } = ();
		    @{ ${$jobIDHashRef}{$familyIDChainKey}{$familyIDChainKey} } = ();  #Clear latest sampleID chainkey
		    push ( @{ ${$jobIDHashRef}{$familyIDChainKey}{$familyIDChainKey."_".$sampleIDChainKey} }, $jobID);   
		}
	    }

	    ## Keeps the jobID string dependecy within reasonable limits
	    if ( (defined(${$jobIDHashRef}{"ALL"}{"ALL"})) && (scalar(@{ ${$jobIDHashRef}{"ALL"}{"ALL"} } >= 100)) ) {

		shift( @{ ${$jobIDHashRef}{"ALL"}{"ALL"} });  #Remove oldest jobID.
	    }
	    ## Job dependent on all jobs
	    push( @{ ${$jobIDHashRef}{"ALL"}{"ALL"} }, $jobID);  #Add jobID to hash
	}
    }
    if ($jobIDsReturn !~/\d+/) {  #Catch errors since, propper sbatch submission should only return numbers

	$logger->fatal($jobIDsReturn."\n");
	$logger->fatal("MIP: Aborting run.\n");
	exit 1;
    }
    $logger->info("Sbatch script submitted, job id: $jobID\n");
    $logger->info("To check status of job, please run \'squeue -j $jobID\'\n");
    $logger->info("To cancel job, please run \'scancel $jobID\'\n");

    push( @{ ${$jobIDHashRef}{"Pan"}{"Pan"} }, $jobID);  #Add jobID to hash for sacct processing downstream
}


sub NrofCoresPerSbatch {

##NrofCoresPerSbatch
    
##Function : Set the number of cores to allocate per sbatch job.
##Returns  : "$nrCores"
##Arguments: $scriptParameterHashRef, $nrCores
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $nrCores                => The number of cores to allocate

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $nrCores = ${$argHashRef}{nrCores};
    
    if ($nrCores > ${$scriptParameterHashRef}{maximumCores}) {  #Set number of cores depending on how many lanes to process
	
	$nrCores = ${$scriptParameterHashRef}{maximumCores};  #Set to max on cluster
    }
    return $nrCores;
}


sub CollectInfiles {

##CollectInfiles
    
##Function : Collects the ".fastq(.gz)" files from the supplied infiles directory. Checks if any files exist.
##Returns  : ""
##Arguments: $scriptParameterHashRef, $inDirPathHashRef, $infileHashRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $inDirPathHashRef       => The indirectories path(s) hash {REF}
##         : $infileHashRef          => The infiles hash {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $inDirPathHashRef;
    my $infileHashRef;

    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	inDirPathHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$inDirPathHashRef},
	infileHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$infileHashRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    $logger->info("Reads from Platform\n");

    for (my $inputDirectoryCounter=0;$inputDirectoryCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$inputDirectoryCounter++) {  #Collects inputfiles govern by sampleIDs
	
	my $inFileDirectoryRef = \${$scriptParameterHashRef}{inFilesDirs}[$inputDirectoryCounter];  #Alias
	my $sampleIDRef = \${$scriptParameterHashRef}{sampleIDs}[$inputDirectoryCounter];  #Alias 
	my @infiles;

	## Collect all fastq files in supplied indirectories
	my $rule = Path::Iterator::Rule->new;
	$rule->name("*.fastq*");  #Only look for fastq or fastq.gz files
	my $it = $rule->iter( $$inFileDirectoryRef );

	while ( my $file = $it->() ) {  #Iterate over directory

	    my ($volume, $directories, $fastqFile) = File::Spec->splitpath($file);
	    push(@infiles, $fastqFile);
	}
	chomp(@infiles);   #Remove newline from every entry in array

	if (!@infiles) {  #No "*.fastq*" infiles
	    
	    $logger->fatal("Could not find any '.fastq' files in supplied infiles directory ".$$inFileDirectoryRef, "\n");
	    exit 1;
	}
	foreach my $infile (@infiles) {  #Check that inFileDirs/infile contains sampleID in filename

	    unless ( $infile =~/$$sampleIDRef/) {

		$logger->fatal("Could not detect sampleID: ".$$sampleIDRef." in supplied infile: ".$$inFileDirectoryRef."/".$infile, "\n");
		$logger->fatal("Check that the order of supplied: '--sampleIDs' and '--inFilesDirs' correlate.", "\n");
		$logger->fatal("NOTE: SampleIDs read from pedigree are lexiographically sorted and for instance '--inFileDirs' supplied need to be supplied in the same order to correlate", "\n");
		exit 1;
	    }
	}
	$logger->info("Sample ID: ".$$sampleIDRef."\n");
	$logger->info("\tInputfiles:\n");

	## Log each file from platform
	foreach my $file (@infiles) {

	    $logger->info("\t\t", $file, "\n");  #Indent for visability
	}
	${$inDirPathHashRef}{ $$sampleIDRef } = $$inFileDirectoryRef;   #Catch inputdir path
	${$infileHashRef}{ $$sampleIDRef }  = [@infiles];  #Reload files into hash
    }
}


sub InfilesReFormat {

##InfilesReFormat
    
##Function : Reformat files for MIP output, which have not yet been created into, correct format so that a sbatch script can be generated with the correct filenames.
##Returns  : "$uncompressedFileCounter"
##Arguments: $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infileHashRef, $inDirPathHashRef, $infilesLaneNoEndingHashRef, $infilesBothStrandsNoEndingHashRef, $laneHashRef, $jobIDHashRef, $programName, $alignerOutDirRef
##         : $scriptParameterHashRef            => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef                 => Info on samples and family hash {REF}
##         : $fileInfoHashRef                   => The fileInfo hash {REF}
##         : $infileHashRef                     => The infiles hash {REF}
##         : $inDirPathHashRef                  => The indirectories path(s) hash {REF}
##         : $infilesLaneNoEndingHashRef        => The infile(s) without the ".ending" {REF}
##         : $infilesBothStrandsNoEndingHashRef => The infile(s) without the ".ending" and strand info {REF}
##         : $laneHashRef                       => The lane info hash {REF}
##         : $jobIDHashRef                      => The jobID hash {REF}
##         : $programName                       => The program name {REF}
##         : $alignerOutDirRef                  => The alignerOutDir used in the analysis {REF}

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};

    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $sampleInfoHashRef;
    my $fileInfoHashRef;
    my $infileHashRef;
    my $inDirPathHashRef;
    my $infilesLaneNoEndingHashRef;
    my $infilesBothStrandsNoEndingHashRef;
    my $laneHashRef;
    my $jobIDHashRef;
    my $programName;
    
    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	sampleInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$sampleInfoHashRef},
	fileInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$fileInfoHashRef},
	infileHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$infileHashRef},
	inDirPathHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$inDirPathHashRef},
	infilesLaneNoEndingHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$infilesLaneNoEndingHashRef},
	infilesBothStrandsNoEndingHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$infilesBothStrandsNoEndingHashRef},
	laneHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$laneHashRef},
	jobIDHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$jobIDHashRef},
	programName => { required => 1, defined => 1, strict_type => 1, store => \$programName},
	alignerOutDirRef => { default => \$$, strict_type => 1},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $uncompressedFileCounter = 0;  #Used to decide later if any inputfiles needs to be compressed before starting analysis 

    for my $sampleID (keys %{$infileHashRef}) {  #For every sampleID                                                                                       
	
        my $laneTracker=0;  #Needed to be able to track when lanes are finished                                                                  
	
        for (my $infileCounter=0;$infileCounter<scalar( @ { ${$infileHashRef}{$sampleID} });$infileCounter++) {  #All inputfiles for all fastq dir and remakes format
	    
            if (${$infileHashRef}{$sampleID}[$infileCounter] =~/(\d+)_(\d+)_([^_]+)_([^_]+)_index([^_]+)_(\d).fastq/) {  #Parse 'new' no "index" format $1=lane, $2=date, $3=Flow-cell, $4=SampleID, $5=index,$6=direction                             
		
		## Check if a file is gzipped.
		my $compressedSwitch = &CheckGzipped({fileNameRef => \${$infileHashRef}{$sampleID}[$infileCounter],
						     });
		
		if (! $compressedSwitch) { #Not compressed
		    
		    $uncompressedFileCounter = "unCompressed";  #File needs compression before starting analysis. Note: All files are rechecked downstream and uncompressed ones are gzipped automatically           
		}
		## Check that the sampleID provided and sampleID in infile name match.
		&CheckSampleIDMatch({scriptParameterHashRef => $scriptParameterHashRef,
				     infileHashRef => $infileHashRef,
				     sampleID => $sampleID,
				     infileSampleID => $4,  #$4 = SampleID from filename
				     infileCounter => $infileCounter,
				    });

		## Adds information derived from infile name to sampleInfo hash. Tracks the number of lanes sequenced and checks unique array elementents.
		&AddInfileInfo({scriptParameterHashRef => $scriptParameterHashRef,
				sampleInfoHashRef => $sampleInfoHashRef,
				fileInfoHashRef => $fileInfoHashRef,
				laneHashRef => $laneHashRef,
				infileHashRef => $infileHashRef,
				inDirPathHashRef => $inDirPathHashRef,
				infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
				infilesBothStrandsNoEndingHashRef => $infilesBothStrandsNoEndingHashRef,
				lane => $1,
				date => $2,
				flowCell => $3,
				sampleID => $4,
				index => $5,
				direction => $6,
				laneTrackerRef => \$laneTracker,
				infileCounter => $infileCounter,
				compressedInfo => $compressedSwitch,
			       });
	    }
            elsif (${$infileHashRef}{$sampleID}[$infileCounter] =~/(\d+)_(\d+)_([^_]+)_([^_]+)_([^_]+)_(\d).fastq/) {  #Parse 'new' no "index" format $1=lane, $2=date, $3=Flow-cell, $4=SampleID, $5=index,$6=direction                             
		
		## Check if a file is gzipped.
		my $compressedSwitch = &CheckGzipped({fileNameRef => \${$infileHashRef}{$sampleID}[$infileCounter],
						     });

		if ( ! $compressedSwitch) { #Not compressed
		   
		    $uncompressedFileCounter = "unCompressed";  #File needs compression before starting analysis. Note: All files are rechecked downstream and uncompressed ones are gzipped automatically           
		}
		## Check that the sampleID provided and sampleID in infile name match.
		&CheckSampleIDMatch({scriptParameterHashRef => $scriptParameterHashRef,
				     infileHashRef => $infileHashRef,
				     sampleID => $sampleID,
				     infileSampleID => $4,  #$4 = SampleID from filename
				     infileCounter => $infileCounter,
				    });

		## Adds information derived from infile name to sampleInfo hash. Tracks the number of lanes sequenced and checks unique array elementents.
		&AddInfileInfo({scriptParameterHashRef => $scriptParameterHashRef,
				sampleInfoHashRef => $sampleInfoHashRef,
				fileInfoHashRef => $fileInfoHashRef,
				laneHashRef => $laneHashRef,
				infileHashRef => $infileHashRef,
				inDirPathHashRef => $inDirPathHashRef,
				infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
				infilesBothStrandsNoEndingHashRef => $infilesBothStrandsNoEndingHashRef,
				lane => $1,
				date => $2,
				flowCell => $3,
				sampleID => $4,
				index => $5,
				direction => $6,
				laneTrackerRef => \$laneTracker,
				infileCounter => $infileCounter,
				compressedSwitch => $compressedSwitch,
			       });		
	    }
	    else {  #No regexp match i.e. file does not follow filename convention 

		$logger->fatal("Could not detect MIP file name convention for file: ".${$infileHashRef}{$sampleID}[$infileCounter].". \n");
		$logger->fatal("Please check that the file name follows the specified convention.", "\n");
		exit 1;
	    }
        }
    }
    return $uncompressedFileCounter;
}


sub CheckSampleIDMatch {

##CheckSampleIDMatch
    
##Function : Check that the sampleID provided and sampleID in infile name match.
##Returns  : ""
##Arguments: $scriptParameterHashRef, $infileHashRef, $sampleID, $infileSampleID, $infileCounter
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $infileHashRef          => The infiles hash {REF}
##         : $sampleID               => Sample id from user
##         : $infileSampleID         => SampleID collect with regexp from infile
##         : $infileCounter          => Counts the number of infiles

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $infileHashRef;
    my $sampleID;
    my $infileSampleID;
    my $infileCounter;

    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	infileHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$infileHashRef},
	sampleID => { required => 1, defined => 1, strict_type => 1, store => \$sampleID},
	infileSampleID => { required => 1, defined => 1, strict_type => 1, store => \$infileSampleID},
	infileCounter => { required => 1, defined => 1, strict_type => 1, store => \$infileCounter},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];
    
    my %seen = ($infileSampleID => 1);  #Add input as first increment

    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {
	
	$seen{${$scriptParameterHashRef}{sampleIDs}[ $sampleIDCounter]}++;
    }
    unless ($seen{$infileSampleID} > 1) {

	$logger->fatal($sampleID." supplied and sampleID ".$infileSampleID." found in file : ".${$infileHashRef}{$sampleID}[$infileCounter]." does not match. Please rename file to match sampleID: ".$sampleID."\n");
	exit 1;
    }
}

sub AddInfileInfo {
  
##AddInfileInfo
    
##Function : Adds information derived from infile name to sampleInfo hash. Tracks the number of lanes sequenced and checks unique array elementents.
##Returns  : ""
##Arguments: $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $infileHashRef, $infilesLaneNoEndingHashRef, $infilesBothStrandsNoEndingHashRef, $inDirPathHashRef, $laneHashRef, $lane, $date, $flowCell, $sampleID, $index, $direction, $laneTrackerRef, $infileCounter, $compressedSwitch
##         : $scriptParameterHashRef            => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef                 => Info on samples and family hash {REF}
##         : $fileInfoHashRef                   => The fileInfo hash {REF}
##         : $infileHashRef                     => The infiles hash {REF}
##         : $infilesLaneNoEndingHashRef        => The infile(s) without the ".ending" {REF}
##         : $infilesBothStrandsNoEndingHashRef => The infile(s) without the ".ending" and strand info {REF}
##         : $inDirPathHashRef                  => The indirectories path(s) hash {REF}
##         : $laneHashRef                       => The lane info hash {REF}
##         : $lane                              => Flow-cell lane
##         : $date                              => Flow-cell sequencing date
##         : $flowCell                          => Flow-cell id
##         : $sampleID                          => Sample id
##         : $index                             => The DNA library preparation molecular barcode
##         : $direction                         => Sequencing read direction
##         : $laneTrackerRef                    => Counts the number of lanes sequenced {REF}
##         : $infileCounter                     => Counts the number of infiles
##         : $compressedSwitch                  => ".fastq.gz" or ".fastq" info governs zcat or cat downstream

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};

    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $sampleInfoHashRef;
    my $fileInfoHashRef;
    my $infileHashRef;
    my $inDirPathHashRef;
    my $infilesLaneNoEndingHashRef;
    my $infilesBothStrandsNoEndingHashRef;
    my $laneHashRef;
    my $laneTrackerRef;
    my $sampleID;
    my $lane;
    my $date;
    my $flowCell;
    my $index;
    my $direction;
    my $infileCounter;
    my $compressedSwitch;
    
    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	sampleInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$sampleInfoHashRef},
	fileInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$fileInfoHashRef},
	infileHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$infileHashRef},
	inDirPathHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$inDirPathHashRef},
	infilesLaneNoEndingHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$infilesLaneNoEndingHashRef},
	infilesBothStrandsNoEndingHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$infilesBothStrandsNoEndingHashRef},
	laneHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$laneHashRef},
	sampleID => { required => 1, defined => 1, strict_type => 1, store => \$sampleID},
	lane => { required => 1, defined => 1, 
		  allow => qr/^\d+$/,
		  strict_type => 1, store => \$lane},
	laneTrackerRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$laneTrackerRef},
	date => { required => 1, defined => 1, strict_type => 1, store => \$date},
	flowCell => { required => 1, defined => 1, strict_type => 1, store => \$flowCell},
	index => { required => 1, defined => 1, strict_type => 1, store => \$index},
	direction => { required => 1, defined => 1,
		       allow => [1, 2],
		       strict_type => 1, store => \$direction},
	infileCounter => { required => 1, defined => 1,
			   allow => qr/^\d+$/,
			   strict_type => 1, store => \$infileCounter},
	compressedSwitch => { required => 1, defined => 1, 
			      allow => [0, 1],
			      strict_type => 1, store => \$compressedSwitch},
	familyIDRef => { default => \$$, strict_type => 1, store => \$familyIDRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $readFile;
    my $fileAtLaneLevelRef;
    my $fileAtDirectionLevelRef;

    my $parsedDate = Time::Piece->strptime($date, "%y%m%d");
    $parsedDate = $parsedDate->ymd;

    if ($compressedSwitch) {

	$readFile = "zcat";  #Read file in compressed format
    }
    else {

	$readFile = "cat";  #Read file in uncompressed format
    }

    if ($direction == 1) {  #Read 1

	push( @{${$laneHashRef}{$sampleID}}, $lane);  #Lane
	${$infilesLaneNoEndingHashRef}{$sampleID}[$$laneTrackerRef] = $sampleID.".".$date."_".$flowCell."_".$index.".lane".$1;  #Save new format (sampleID_date_flow-cell_index_lane) in hash with samplid as keys and inputfiles in array. Note: These files have not been created yet and there is one entry into hash for both strands and .ending is removed (.fastq).

	$fileAtLaneLevelRef = \${$infilesLaneNoEndingHashRef}{$sampleID}[$$laneTrackerRef];  #Alias
	${$sampleInfoHashRef}{$$familyIDRef}{$sampleID}{File}{$$fileAtLaneLevelRef}{SequenceRunType} = "Single-end";  #Single-end until proven otherwise

	## Collect read length from an infile
	${$sampleInfoHashRef}{$$familyIDRef}{$sampleID}{File}{$$fileAtLaneLevelRef}{SequenceLength} = &CollectReadLength({directory => ${$inDirPathHashRef}{$sampleID},
															  readFileCommand => $readFile,
															  file => ${$infileHashRef}{$sampleID}[$infileCounter],
															 });
	## Detect "regExp" in string
	${$fileInfoHashRef}{undeterminedInFileName}{ ${$infilesLaneNoEndingHashRef}{$sampleID}[$$laneTrackerRef] } = &CheckString({string => $flowCell,
																   regExp => "Undetermined",
																  });	
	$$laneTrackerRef++;
    }
    if ($direction == 2) {  #2nd read direction

	$fileAtLaneLevelRef = \${$infilesLaneNoEndingHashRef}{ $sampleID }[$$laneTrackerRef-1];  #Alias
	${$sampleInfoHashRef}{$$familyIDRef}{$sampleID}{File}{$$fileAtLaneLevelRef}{SequenceRunType} = "Paired-end";  #$laneTracker -1 since it gets incremented after direction eq 1. 
    }
    
    ${$infilesBothStrandsNoEndingHashRef}{ $sampleID }[$infileCounter] = $sampleID.".".$date."_".$flowCell."_".$index.".lane".$1."_".$direction;  #Save new format in hash with samplid as keys and inputfiles in array. Note: These files have not been created yet and there is one entry per strand and .ending is removed (.fastq).

    $fileAtDirectionLevelRef = \${$infilesBothStrandsNoEndingHashRef}{ $sampleID }[$infileCounter];  #Alias
    ${$sampleInfoHashRef}{$$familyIDRef}{$sampleID}{File}{$$fileAtLaneLevelRef}{ReadDirectionFile}{$$fileAtDirectionLevelRef}{OriginalFileName} = ${$infileHashRef}{$sampleID}[$infileCounter];  #Original fileName

    ${$sampleInfoHashRef}{$$familyIDRef}{$sampleID}{File}{$$fileAtLaneLevelRef}{ReadDirectionFile}{$$fileAtDirectionLevelRef}{OriginalFileNameNoEnding} = $1."_".$date."_".$flowCell."_".$sampleID."_".$index."_".$direction;  #Original fileName, but no ending

    ${$sampleInfoHashRef}{$$familyIDRef}{$sampleID}{File}{$$fileAtLaneLevelRef}{ReadDirectionFile}{$$fileAtDirectionLevelRef}{Lane} = $1;  #Save sample lane                  

    ${$sampleInfoHashRef}{$$familyIDRef}{$sampleID}{File}{$$fileAtLaneLevelRef}{ReadDirectionFile}{$$fileAtDirectionLevelRef}{Date} = $parsedDate;  #Save Sequence run date

    ${$sampleInfoHashRef}{$$familyIDRef}{$sampleID}{File}{$$fileAtLaneLevelRef}{ReadDirectionFile}{$$fileAtDirectionLevelRef}{'Flow-cell'} = $flowCell;  #Save Sequence flow-cell        

    ${$sampleInfoHashRef}{$$familyIDRef}{$sampleID}{File}{$$fileAtLaneLevelRef}{ReadDirectionFile}{$$fileAtDirectionLevelRef}{SampleBarcode} = $index;  #Save sample barcode

    ${$sampleInfoHashRef}{$$familyIDRef}{$sampleID}{File}{$$fileAtLaneLevelRef}{ReadDirectionFile}{$$fileAtDirectionLevelRef}{RunBarcode} = $date."_".$flowCell."_".$1."_".$index;  #Save run barcode
    
    ${$sampleInfoHashRef}{$$familyIDRef}{$sampleID}{File}{$$fileAtLaneLevelRef}{ReadDirectionFile}{$$fileAtDirectionLevelRef}{ReadDirection} = $direction;   
}


sub CheckFileNameExists {

##CheckFileNameExists
    
##Function : Check if a file with with a filename consisting of $filePathRef.$fileCounter.$fileEndingRef exist. If so bumps the version number and return new filename and sbatch version number.
##Returns  : "$fileName, $fileNameTracker"
##Arguments: $filePathRef, $fileEndingRef
##         : $filePathRef   => The file path {REF}
##         : $fileEndingRef => The file ending {REF}

    my $filePathRef = $_[0];
    my $fileEndingRef = $_[1];

    my $fileName;  #Temp filename
    my $fileNameTracker = 0;  #Nr of sbatch scripts with identical filenames i.e. version number
  
    for (my $fileCounter=0;$fileCounter<9999;$fileCounter++) {  #Number of possible files with the same name
	
	$fileName = $$filePathRef.$fileCounter.$$fileEndingRef;  #Filename, filenr and fileending
	$fileNameTracker = $fileCounter;  #Nr of sbatch scripts with identical filenames

	unless (-f $fileName) {  #File exists

	    last;  #No file exists
	}	
    }
    return ($fileName, $fileNameTracker);
}


sub AddToScriptParameter {

##AddToScriptParameter
    
##Function : Checks and sets user input or default values to scriptParameters.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoRef, $supportedCaptureKitHashRef, $broadcastsArrayRef, $parameterName, $associatedPrograms
##         : $parameterHashRef                         => Holds all parameters
##         : $scriptParameterHashRef                   => Holds all set parameter for analysis
##         : $sampleInfoHashRef                        => Info on samples and family hash {REF}
##         : $fileInfoHashRef                          => The fileInfo hash {
##         : $supportedCaptureKitHashRef               => The supported capture kits hash {REF}
##         : $broadcastsArrayRef                       => Holds the parameters info for broadcasting later {REF}
##         : $parameterName                            => Parameter name
##         : $associatedPrograms                       => The parameters program(s) {array, REF}
    
    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};

    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;
    my $sampleInfoHashRef;
    my $fileInfoHashRef;
    my $supportedCaptureKitHashRef;
    my $broadcastsArrayRef;
    my $associatedProgramsArrayRef;
    my $parameterName;

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	sampleInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$sampleInfoHashRef},
	fileInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$fileInfoHashRef},
	supportedCaptureKitHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$supportedCaptureKitHashRef},
	broadcastsArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$broadcastsArrayRef},
	associatedProgramsArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$associatedProgramsArrayRef},
	parameterName => { required => 1, defined => 1, store => \$parameterName},
	familyIDRef => {default => \$$, strict_type => 1},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $elementSeparatorRef = \${$parameterHashRef}{$parameterName}{elementSeparator};

    foreach my $associatedProgram (@{$associatedProgramsArrayRef}) {  #Check all programs that use parameter

	my $parameterSetSwitch = 0;
	
	if (defined(${$scriptParameterHashRef}{$associatedProgram}) && (${$scriptParameterHashRef}{$associatedProgram} > 0) ) {  #Only add active programs parameters	    

	    $parameterSetSwitch = 1;

	    ## Input from cmd
	    if ( (${$parameterHashRef}{$parameterName}{dataType} eq "ARRAY") && (defined(${$parameterHashRef}{$parameterName}{value}[0])) )  {  #Array reference

		my $valuesArrayRef = \@{ ${$parameterHashRef}{$parameterName}{value} };
		@{${$scriptParameterHashRef}{$parameterName}} = split($$elementSeparatorRef, join($$elementSeparatorRef, @{$valuesArrayRef}) );
	    }
	    elsif ( (${$parameterHashRef}{$parameterName}{dataType} eq "HASH") && (keys %{${$parameterHashRef}{$parameterName}{value}})) {  #Hash reference

		${$scriptParameterHashRef}{$parameterName} = ${$parameterHashRef}{$parameterName}{value};
	    }
	    elsif (defined(${$parameterHashRef}{$parameterName}{value}) && (ref(${$parameterHashRef}{$parameterName}{value})!~/ARRAY|HASH/)) {  #Scalar input from cmd

		${$scriptParameterHashRef}{$parameterName} = ${$parameterHashRef}{$parameterName}{value};
	    }
	    else {
	
		if (defined(${$scriptParameterHashRef}{$parameterName})) {  #Input from config file
	
		}
		elsif (exists(${$parameterHashRef}{$parameterName}{default})) {  #Default exists

		    if (${$parameterHashRef}{$parameterName}{dataType} eq "ARRAY") {  #Array reference
			
			## Build default for inFilesDirs
			if ($parameterName eq "inFilesDirs") {
			    
			    for (my $indirectoryCount=0;$indirectoryCount<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$indirectoryCount++) {
				
				push(@{${$scriptParameterHashRef}{inFilesDirs}}, catfile(${$scriptParameterHashRef}{clusterConstantPath}, ${$scriptParameterHashRef}{analysisType}, ${$scriptParameterHashRef}{sampleIDs}[$indirectoryCount], "fastq"));
			    }
			}
			else {
			    
			    push(@{${$scriptParameterHashRef}{$parameterName}}, @{ ${$parameterHashRef}{$parameterName}{default} });
			}
		    }
		    elsif (${$parameterHashRef}{$parameterName}{dataType} eq "HASH") {

			${$scriptParameterHashRef}{$parameterName} = ${$parameterHashRef}{$parameterName}{default};
		    }
		    else {  #Scalar
			
			${$scriptParameterHashRef}{$parameterName} = ${$parameterHashRef}{$parameterName}{default};
		    }
		}
		else {  ## No default
		    
		    if ( (exists(${$parameterHashRef}{$parameterName}{mandatory})) && (${$parameterHashRef}{$parameterName}{mandatory} eq "no") ) {  #Not mandatory
		    }
		    else {

			## Special cases where the requirement is depending on other variabels
			if ( ($parameterName eq "bwaMemRapidDb") && (${$scriptParameterHashRef}{analysisType} ne "rapid")) {  #Do nothing since file is not required unless rapid mode is enabled
			}
			elsif ( ($parameterName eq "GATKGenoTypeGVCFsRefGVCF") && (${$scriptParameterHashRef}{analysisType} =~/genomes/) ) {  #Do nothing since file is not required unless exome or rapid mode is enabled
			}
			elsif ( ($parameterName eq "vcfParserRangeFeatureAnnotationColumns") && ( ${$scriptParameterHashRef}{vcfParserRangeFeatureFile} eq "noUserInfo") ) {  #Do nothing since no SelectFile was given
			} 
			elsif ( ($parameterName eq "vcfParserSelectFeatureAnnotationColumns") && ( ${$scriptParameterHashRef}{vcfParserSelectFile} eq "noUserInfo") ) {  #Do nothing since no SelectFile was given
			}
			elsif ( ($parameterName eq "vcfParserSelectFileMatchingColumn") && ( ${$scriptParameterHashRef}{vcfParserSelectFile} eq "noUserInfo") ) {  #Do nothing since no SelectFile was given
			}
			elsif ( ($parameterName eq "rankModelFile") && (!defined(${$scriptParameterHashRef}{rankModelFile}) ) ) {  #Do nothing since no rank model was given i.e. use rank scripts deafult supplied with distribution
			}
			elsif ( ($parameterName eq "genmodModelsReducedPenetranceFile") && (!defined(${$scriptParameterHashRef}{genmodModelsReducedPenetranceFile}) ) ) {  #Do nothing since no reduced penetrance should be performed
			}
			elsif  ($parameterName eq "exomeTargetBed") {
			    
			    ## Return a default capture kit as user supplied no info
			    my $captureKit = &AddCaptureKit({fileInfoHashRef => $fileInfoHashRef,
							     supportedCaptureKitHashRef => $supportedCaptureKitHashRef,
							     captureKit => "Latest", 
							    });
			    ${$scriptParameterHashRef}{$parameterName}{$captureKit} = join(",", @{${$scriptParameterHashRef}{sampleIDs}});
			    ## Update exomeTargetBed files with humanGenomeReferenceSourceRef and humanGenomeReferenceVersionRef
			    &UpdateExomeTargetBed({exomeTargetBedFileHashRef => ${$scriptParameterHashRef}{exomeTargetBed},
						   humanGenomeReferenceSourceRef => \${$fileInfoHashRef}{humanGenomeReferenceSource},
						   humanGenomeReferenceVersionRef => \${$fileInfoHashRef}{humanGenomeReferenceVersion},
						  });
			    $logger->warn("Could not detect a supplied capture kit. Will Try to use 'Latest' capture kit: ".$captureKit, "\n");
			}
			else {
			    
			    if (defined($logger)) {  #We have a logg object and somewhere to write
				
				$logger->fatal($USAGE, "\n");
				$logger->fatal("Supply '-".$parameterName."' if you want to run ".$associatedProgram, "\n");
			    }
			    else {
				
				warn($USAGE, "\n");
				warn("Supply '-".$parameterName."' if you want to run ".$associatedProgram, "\n");
			    }
			    exit 1;
			}
		    }
		}
	    }
	}
	if ($parameterSetSwitch eq 1) {  #No need to set parameter more than once
	    last;
	}
    }

    ## Parse Human Genome Reference
    if ($parameterName eq "humanGenomeReference") {
	
	## Detect version and source of the humanGenomeReference: Source (hg19 or GRCh).
	&ParseHumanGenomeReference({fileInfoHashRef => $fileInfoHashRef,
				    humanGenomeReferenceRef => \${$scriptParameterHashRef}{humanGenomeReference},
				   });

	## Update exomeTargetBed files with humanGenomeReferenceSourceRef and humanGenomeReferenceVersionRef
	&UpdateExomeTargetBed({exomeTargetBedFileHashRef => ${$scriptParameterHashRef}{exomeTargetBed},
			       humanGenomeReferenceSourceRef => \${$fileInfoHashRef}{humanGenomeReferenceSource},
			       humanGenomeReferenceVersionRef => \${$fileInfoHashRef}{humanGenomeReferenceVersion},
			      });
    }
    ## Parse pedigree file
    if ($parameterName eq "pedigreeFile") {
	
	## Reads familyID_pedigree file in PLINK format. Checks for pedigree data for allowed entries and correct format. Add data to sampleInfo depending on user info.
	&ReadPlinkPedigreeFile({parameterHashRef => $parameterHashRef,
				scriptParameterHashRef => $scriptParameterHashRef,
				sampleInfoHashRef => $sampleInfoHashRef,
				fileInfoHashRef => $fileInfoHashRef,
				supportedCaptureKitHashRef => $supportedCaptureKitHashRef,
				filePath => ${$scriptParameterHashRef}{pedigreeFile},
			       });
    }

    ## Parameter set
    if (defined(${$scriptParameterHashRef}{$parameterName})) {
	
	my $info = "";  #Hold parameters info
	
	if (ref(${$scriptParameterHashRef}{$parameterName}) eq "ARRAY") {  #Array reference
	    	    
	    $info = "Set ".$parameterName." to: ".join($$elementSeparatorRef, @{ ${$scriptParameterHashRef}{ $parameterName } });
	    push(@{$broadcastsArrayRef}, $info);  #Add info to broadcasts
	}
	elsif (ref(${$scriptParameterHashRef}{$parameterName}) eq "HASH") {

	    $info = "Set ".$parameterName." to: ".join(",", map { "$_=${$scriptParameterHashRef}{$parameterName}{$_}" } (keys %{${$scriptParameterHashRef}{$parameterName}}));
	    push(@{$broadcastsArrayRef}, $info);  #Add info to broadcasts
	}
	else {
   
	    $info = "Set ".$parameterName." to: ".${$scriptParameterHashRef}{$parameterName};
	    push(@{$broadcastsArrayRef}, $info);  #Add info to broadcasts
	}
    }
}

sub CheckParameterFiles {

##CheckParameterFiles
    
##Function : Checks that files/directories exists and if fileEndings need to be built also updates SampleInfoHash information with information from pedigree
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoRef, $supportedCaptureKitHashRef, $annovarTableHashRef, $broadcastsArrayRef, $annovarSupportedTableNamesArrayRef, $associatedProgramsArrayRef, $familyIDRef, $parameterName $parameterExistsCheck, $referencesDirRef
##         : $parameterHashRef                   => Holds all parameters
##         : $scriptParameterHashRef             => Holds all set parameter for analysis
##         : $sampleInfoHashRef                  => Info on samples and family hash {REF}
##         : $fileInfoHashRef                    => The fileInfo hash {REF}
##         : $supportedCaptureKitHashRef         => The supported capture kits hash {REF}
##         : $annovarTableHashRef                => annovarTableHashRef {REF}
##         : $broadcastsArrayRef                 => Holds the parameters info for broadcasting later {REF}
##         : $annovarSupportedTableNamesArrayRef => The supported annovar reference names array {REF}
##         : $associatedProgramsArrayRef         => The parameters program(s) {REF}
##         : $familyIDRef                        => The familyIDRef {REF}
##         : $parameterName                      => Parameter name
##         : $parameterExistsCheck               => Check if intendent file exists in reference directory
##         : $referencesDirRef                   => MIP reference directory

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};

    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;
    my $sampleInfoHashRef;
    my $fileInfoHashRef;
    my $supportedCaptureKitHashRef;
    my $broadcastsArrayRef;
    my $annovarTableHashRef;
    my $annovarSupportedTableNamesArrayRef;
    my $associatedProgramsArrayRef;
    my $parameterName;
    my $parameterExistsCheck;

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	sampleInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$sampleInfoHashRef},
	fileInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$fileInfoHashRef},
	supportedCaptureKitHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$supportedCaptureKitHashRef},
	broadcastsArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$broadcastsArrayRef},
	annovarTableHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$annovarTableHashRef},
	annovarSupportedTableNamesArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$annovarSupportedTableNamesArrayRef},
	associatedProgramsArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$associatedProgramsArrayRef},
	parameterName => { required => 1, defined => 1, strict_type => 1, store => \$parameterName},
	parameterExistsCheck => { required => 1, defined => 1, strict_type => 1, store => \$parameterExistsCheck},
	familyIDRef => { default => \$$, strict_type => 1, store => \$familyIDRef},
	referencesDirRef => { default => \$$, strict_type => 1, store => \$referencesDirRef},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $directory = "";  #Initialize for downstream path generation when required

    foreach my $associatedProgram (@{$associatedProgramsArrayRef}) {  #Check all programs that use parameter
	
	my $parameterSetSwitch = 0;
	
	if (defined(${$scriptParameterHashRef}{$associatedProgram}) && (${$scriptParameterHashRef}{$associatedProgram} > 0) ) {  #Only add active programs parameters	    
	    
	    $parameterSetSwitch = 1;		    

	    if (exists(${$parameterHashRef}{$parameterName}{reference})) {  #Expect file to be in referenceDirectory
		
		$directory = $$referencesDirRef;
	    }
	    if (defined(${$scriptParameterHashRef}{$parameterName}) ) {  #Check parameter existence
		
		if (${$parameterHashRef}{$parameterName}{dataType} eq "SCALAR") {
		    
		    my $path .= catfile($directory, ${$scriptParameterHashRef}{$parameterName});
		    
		    if ($parameterName eq "mosaikJumpDbStub") {
			
			## Checks files to be built by combining filename stub with fileendings
			&CheckFileEndingsToBeBuilt({parameterHashRef => $parameterHashRef,
						    scriptParameterHashRef => $scriptParameterHashRef,
						    fileEndingsArrayRef => \@{${$fileInfoHashRef}{mosaikJumpDbStubFileEndings}},
						    parameterName => "mosaikJumpDbStub",
						    fileName => ${$scriptParameterHashRef}{mosaikJumpDbStub},
						   }); 
		    }
		    elsif ($parameterName eq "bwaBuildReference") {
			
			## Checks files to be built by combining filename stub with fileendings
			&CheckFileEndingsToBeBuilt({parameterHashRef => $parameterHashRef,
						    scriptParameterHashRef => $scriptParameterHashRef,
						    fileEndingsArrayRef => \@{${$fileInfoHashRef}{bwaBuildReferenceFileEndings}},
						    parameterName => "bwaBuildReference",
						    fileName => ${$scriptParameterHashRef}{bwaBuildReference},
						   });
		    }
		    elsif ($parameterName eq "sampleInfoFile") {
			
			if (defined(${$scriptParameterHashRef}{sampleInfoFile})) {
			    
			    if (-f ${$scriptParameterHashRef}{sampleInfoFile}) {
				
				if (defined(${$scriptParameterHashRef}{logFile})) {
				    
				    $logger->info("Read Yaml file: ". ${$scriptParameterHashRef}{sampleInfoFile}, "\n");
				}

				##Loads a YAML file into an arbitrary hash and returns it. Load parameters from previous run from sampleInfoFile
				my %tempHash = &LoadYAML({yamlFile => ${$scriptParameterHashRef}{sampleInfoFile},
							 });  

				## Update sampleInfo with information from pedigree
				&UpdateSampleInfoHash({sampleInfoHashRef => $sampleInfoHashRef,
						       tempHashRef => \%tempHash,
						       familyIDRef => $familyIDRef,
						      });
			    }
			} 
		    }
		    elsif ( ($parameterName eq "genomicSet") && (${$scriptParameterHashRef}{genomicSet} eq "noUserInfo") ) {  #Do nothing since this is not a required feature
		    }
		    elsif ( ($parameterName eq "bwaMemRapidDb") && (${$scriptParameterHashRef}{analysisType} ne "rapid")) {  #Do nothing since file is not required unless rapid mode is enabled
		    }
		    elsif ( ($parameterName eq "GATKGenoTypeGVCFsRefGVCF") && (${$scriptParameterHashRef}{analysisType} =~/genomes/) ) {  #Do nothing since file is not required unless exome mode is enabled
		    }
		    elsif ( ($parameterName eq "vcfParserRangeFeatureFile") && ( ${$scriptParameterHashRef}{vcfParserRangeFeatureFile} eq "noUserInfo") ) {  #Do nothing since no RangeFile was given
		    }
		    elsif ($parameterName eq "vcfParserSelectFile") {
			
			if (${$scriptParameterHashRef}{vcfParserSelectFile} eq "noUserInfo") {  #No SelectFile was given
			    
			    ${$scriptParameterHashRef}{VcfParserOutputFileCount} = 1;  #To track if VCFParser was used with a vcfParserSelectFile (=2) or not (=1)
			}
			else {  #To enable addition of selectFile to sampleInfo                                                                       

			    &CheckExistance({parameterHashRef => $parameterHashRef,
					     scriptParameterHashRef => $scriptParameterHashRef,
					     itemNameRef => \$path,
					     parameterNameRef => \$parameterName,
					     itemTypeToCheck => $parameterExistsCheck,
					    });
			    
			    ## Collects sequences contigs used in select file
			    &CollectSelectFileContigs({contigsArrayRef => \@{${$fileInfoHashRef}{SelectFileContigs}},
						       selectFilePath => catfile($$referencesDirRef, ${$scriptParameterHashRef}{vcfParserSelectFile}),
						      });
			    
			    ${$scriptParameterHashRef}{VcfParserOutputFileCount} = 2;  #To track if VCFParser was used with a vcfParserSelectFile (=2) or not (=1)
			}
		    }
		    elsif ( ($parameterName eq "genmodModelsReducedPenetranceFile") && (!defined(${$scriptParameterHashRef}{genmodModelsReducedPenetranceFile}) ) ) {  #Do nothing since no reduced penetrance should be performed
		    }
		    elsif ($parameterName eq "rankModelFile") {  
			
			if (!defined(${$scriptParameterHashRef}{rankModelFile})) {  #Do nothing since no rank model config file was given. Use default supplied by ranking script
			}
			else {  #To enable addition of rankModel file and version to sampleInfo                                                                       
			    &CheckExistance({parameterHashRef => $parameterHashRef,
					     scriptParameterHashRef => $scriptParameterHashRef,
					     itemNameRef => \$path,
					     parameterNameRef => \$parameterName,
					     itemTypeToCheck => $parameterExistsCheck,
					    });
			}
		    }
		    else {
			
			&CheckExistance({parameterHashRef => $parameterHashRef,
					 scriptParameterHashRef => $scriptParameterHashRef,
					 itemNameRef => \$path,
					 parameterNameRef => \$parameterName,
					 itemTypeToCheck => $parameterExistsCheck,
					});
			if ($path =~/\.gz$/) {  #Check for tabix index as well
			 
			    $path .=".tbi";
			    &CheckExistance({parameterHashRef => $parameterHashRef,
					     scriptParameterHashRef => $scriptParameterHashRef,
					     itemNameRef => \$path,
					     parameterNameRef => \$parameterName,
					     itemTypeToCheck => $parameterExistsCheck,
					    });
			}
			
			if ($parameterName eq "humanGenomeReference") {		    
			    
			    ## Check the existance of associated Human genome files
			    &CheckHumanGenomeFileEndings({parameterHashRef => $parameterHashRef,
							  scriptParameterHashRef => $scriptParameterHashRef,
							  fileInfoHashRef => $fileInfoHashRef,
							  parameterNameRef => \$parameterName
							 });
			}
		    }
		}
		if (${$parameterHashRef}{$parameterName}{dataType} eq "ARRAY") {
		    
		    if ($parameterName eq "annovarTableNames") {
			
			## Defines and adds annovar tables parameters to hash
			%{$annovarTableHashRef} = &DefineAnnovarTables({parameterHashRef => $parameterHashRef,
									annovarSupportedTableNamesArrayRef => $annovarSupportedTableNamesArrayRef,
									annovarGenomeBuildVersionRef => \$scriptParameter{annovarGenomeBuildVersion},
								       }); 

			## Checks supported Annovar Tables and that the supplied supported ones exists
			&CheckAnnovarTables({parameterHashRef => $parameterHashRef,
					     scriptParameterHashRef => $scriptParameterHashRef,
					     annovarTableHashRef => $annovarTableHashRef,
					     annovarSupportedTableNamesArrayRef => $annovarSupportedTableNamesArrayRef,
					    });
		    }
		    else {
			
			foreach my $file (@{${$scriptParameterHashRef}{$parameterName}}) {
			    
			    my $path .= catfile($directory, $file);
			    &CheckExistance({parameterHashRef => $parameterHashRef,
					     scriptParameterHashRef => $scriptParameterHashRef,
					     itemNameRef => \$path,
					     parameterNameRef => \$parameterName,
					     itemTypeToCheck => $parameterExistsCheck,
					    });

			    if ($file =~/\.gz$/) {  #Check for tabix index as well
				
				my $fileIndex = $file.".tbi";
				$path .=".tbi";
				&CheckExistance({parameterHashRef => $parameterHashRef,
						 scriptParameterHashRef => $scriptParameterHashRef,
						 itemNameRef => \$path,
						 parameterNameRef => \$fileIndex,
						 itemTypeToCheck => $parameterExistsCheck,
					    });
			    }
			}
		    }
		}
		if (${$parameterHashRef}{$parameterName}{dataType} eq "HASH") { 
		    
		    for my $file (keys %{${$scriptParameterHashRef}{$parameterName}}) {

			my $path .= catfile($directory, $file);

			if ($parameterName eq "exomeTargetBed") {

			    ## Check that supplied target file ends with ".bed" and otherwise exists
			    &CheckTargetExistFileBed({scriptParameterHashRef => $scriptParameterHashRef,
						      file => $file,
						      parameterName => $parameterName,
						     });
			    ## Checks files to be built by combining filename stub with fileendings
			    &CheckFileEndingsToBeBuilt({parameterHashRef => $parameterHashRef,
							scriptParameterHashRef => $scriptParameterHashRef,
							fileEndingsArrayRef => \@{${$fileInfoHashRef}{exomeTargetBed}},
							parameterName => "exomeTargetBed",
							fileName => $file,
						       }); 			    
			}
			&CheckExistance({parameterHashRef => $parameterHashRef,
					 scriptParameterHashRef => $scriptParameterHashRef,
					 itemNameRef => \$path,
					 parameterNameRef => \$file,
					 itemTypeToCheck => $parameterExistsCheck,
					});

			
			if ($file =~/\.gz$/) {  #Check for tabix index as well
			    
			    my $fileIndex = $file.".tbi";
			    $path .=".tbi";
			    &CheckExistance({parameterHashRef => $parameterHashRef,
					     scriptParameterHashRef => $scriptParameterHashRef,
					     itemNameRef => \$path,
					     parameterNameRef => \$fileIndex,
					     itemTypeToCheck => $parameterExistsCheck,
					    });
			}
			if ($parameterName eq "snpSiftAnnotationFiles"){
			    
			    my %snpEffFile = &DefineSnpEffFiles({parameterHashRef => $parameterHashRef,
								});
			}
		    }
		}		    
	    }
	}
	if ($parameterSetSwitch eq 1) {  #No need to set parameter more than once
	    last;
	}
    }
}


sub CreateFileEndings {

##CreateFileEndings
    
##Function : Creates the fileTags depending on which modules are used by the user to relevant chain.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $fileInfoHashRef, $infilesLaneNoEndingHashRef, $orderParametersArrayRef, $familyIDRef
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $fileInfoHashRef            => Info on files hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $orderParametersArrayRef    => Order of addition to parameter array {REF}
##         : $familyIDRef                => The familyID {REF}

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $orderParametersArrayRef = ${$argHashRef}{orderParametersArrayRef};

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	fileInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$fileInfoHashRef},
	infilesLaneNoEndingHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$infilesLaneNoEndingHashRef},
	orderParametersArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$orderParametersArrayRef},
	familyIDRef => { default => \$$, strict_type => 1, store => \$familyIDRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my %tempFileEnding;  #Used to enable seqential build-up of fileTags between modules
    
    foreach my $orderParameterElement (@{$orderParametersArrayRef}) {
	
	if (defined(${$scriptParameterHashRef}{$orderParameterElement})) {  #Only active parameters

	    if ( ( any {$_ eq $orderParameterElement} @{${$parameterHashRef}{dynamicParameters}{program}} ) ) { #Only process programs
		
		if (${$parameterHashRef}{$orderParameterElement}{chain} eq "MAIN") {  #MAIN chain
		    
		    if (${$parameterHashRef}{$orderParameterElement}{fileTag} ne "nofileTag") {  #FileEnding exist
			
###MAIN/Per sampleID
			for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {
			    
			    my $sampleID = ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter];  #Alias

			    if (${$scriptParameterHashRef}{$orderParameterElement} > 0) {  #Fileending should be added    
				
				if ($orderParameterElement eq "pPicardToolsMergeSamFiles") {  #Special case
				    
				    if (defined(${$scriptParameterHashRef}{picardToolsMergeSamFilesPrevious})) {  #Sanity check that we have something to merge and hence to fileTag should be added
					
					${$fileInfoHashRef}{ $$familyIDRef }{ $sampleID }{pPicardToolsMergeSamFiles}{fileTag} = $tempFileEnding{ $sampleID }.${$parameterHashRef}{$orderParameterElement}{fileTag};  #Adds from previous entry 
				    }
				    else {
					
					${$fileInfoHashRef}{ $$familyIDRef }{ $sampleID }{pPicardToolsMergeSamFiles}{fileTag} = $tempFileEnding{ $sampleID }."";
				    }
				}
				else {

				    if (defined($tempFileEnding{ $sampleID })) {
					
					${$fileInfoHashRef}{ $$familyIDRef }{ $sampleID }{$orderParameterElement}{fileTag} = $tempFileEnding{ $sampleID }.${$parameterHashRef}{$orderParameterElement}{fileTag};
				    }
				    else  {  #First module that should add filending

					${$fileInfoHashRef}{ $$familyIDRef }{ $sampleID }{$orderParameterElement}{fileTag} = ${$parameterHashRef}{$orderParameterElement}{fileTag};
				    } 
				}
			    }
			    else {  #Do not add new module fileTag

				${$fileInfoHashRef}{ $$familyIDRef }{ $sampleID }{$orderParameterElement}{fileTag} = $tempFileEnding{ $sampleID };
			    }
			    $tempFileEnding{ $sampleID } = ${$fileInfoHashRef}{ $$familyIDRef }{ $sampleID }{$orderParameterElement}{fileTag};  #To enable sequential build-up of fileending
			}
			
###MAIN/Per familyID
			if (${$scriptParameterHashRef}{$orderParameterElement} > 0) {  #Fileending should be added 

			    if ($orderParameterElement eq "pPicardToolsMergeSamFiles") {  #Special case - do nothing
			    }
			    elsif ( ($orderParameterElement eq "pPicardToolsMergeRapidReads") && (${$scriptParameterHashRef}{analysisType} ne "rapid") ) {  #Special case - do nothing
			    }
			    else {
				
				if (defined($tempFileEnding{$$familyIDRef})) {
			
				    ${$fileInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{$orderParameterElement}{fileTag} = $tempFileEnding{$$familyIDRef}.${$parameterHashRef}{$orderParameterElement}{fileTag};
				}
				else  {  #First module that should add filending
				    
				    ${$fileInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{$orderParameterElement}{fileTag} = ${$parameterHashRef}{$orderParameterElement}{fileTag};
				}
				$tempFileEnding{ $$familyIDRef } = ${$fileInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{$orderParameterElement}{fileTag};  #To enable sequential build-up of fileending 
			    }		
			}
			else {  #Do not add new module fileTag
			 
			    ${$fileInfoHashRef}{ $$familyIDRef }{  $$familyIDRef }{$orderParameterElement}{fileTag} = $tempFileEnding{ $$familyIDRef };
			}
		    }
		}
		if (${$parameterHashRef}{$orderParameterElement}{chain} ne "MAIN") {  #Other chain(s)
		    
		    my $chainfork = ${$parameterHashRef}{$orderParameterElement}{chain}; 

		    if (${$parameterHashRef}{$orderParameterElement}{fileTag} ne "nofileTag") {  #FileEnding exist
			
###OTHER/Per sampleID
			for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {
			    
			    my $sampleID = ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter];  #Alias

			    if (${$scriptParameterHashRef}{$orderParameterElement} > 0) {  #Fileending should be added    
			
				unless (defined($tempFileEnding{$chainfork}{ $sampleID })) {	

				    $tempFileEnding{$chainfork}{ $sampleID } = $tempFileEnding{ $sampleID };  #Inherit current MAIN chain. 
				}
				if (defined($tempFileEnding{$chainfork}{ $sampleID })) {

				    ${$fileInfoHashRef}{ $$familyIDRef }{ $sampleID }{$orderParameterElement}{fileTag} = $tempFileEnding{$chainfork}{ $sampleID }.${$parameterHashRef}{$orderParameterElement}{fileTag};
				}
				else  {  #First module that should add filending

				    ${$fileInfoHashRef}{ $$familyIDRef }{ $sampleID }{$orderParameterElement}{fileTag} = ${$parameterHashRef}{$orderParameterElement}{fileTag};
				} 
			    }
			    else {  #Do not add new module fileTag

				${$fileInfoHashRef}{ $$familyIDRef }{ $sampleID }{$orderParameterElement}{fileTag} = $tempFileEnding{$chainfork}{ $sampleID };
			    }
			    $tempFileEnding{$chainfork}{ $sampleID } = ${$fileInfoHashRef}{ $$familyIDRef }{ $sampleID }{$orderParameterElement}{fileTag};  #To enable sequential build-up of fileending
			}
###Other/Per familyID

			if (${$scriptParameterHashRef}{$orderParameterElement} > 0) {  #File ending should be added
			    
			    unless (defined($tempFileEnding{$chainfork}{$$familyIDRef})) {	

				$tempFileEnding{$chainfork}{$$familyIDRef} =  $tempFileEnding{$$familyIDRef};  #Inherit current MAIN chain. 
			    }
			    if (defined($tempFileEnding{$chainfork}{$$familyIDRef})) {

				${$fileInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{$orderParameterElement}{fileTag} = $tempFileEnding{$chainfork}{$$familyIDRef}.${$parameterHashRef}{$orderParameterElement}{fileTag};
			    }
			    else  {  #First module that should add filending

				${$fileInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{$orderParameterElement}{fileTag} = ${$parameterHashRef}{$orderParameterElement}{fileTag};
			    }
			    $tempFileEnding{$chainfork}{$$familyIDRef} = ${$fileInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{$orderParameterElement}{fileTag};  #To enable sequential build-up of fileending 
			}
			else {  #Do not add new module fileTag
			    
			    ${$fileInfoHashRef}{ $$familyIDRef }{  $$familyIDRef }{$orderParameterElement}{fileTag} = $tempFileEnding{$chainfork}{ $$familyIDRef };
			}
		    }
		}
	    }
	}
    }
}


sub ProgramPreRequisites {

##ProgramPreRequisites
    
##Function : Creates program directories (info & programData & programScript), program script filenames and writes sbatch header.
##Returns  : Path to stdout
##Arguments: $scriptParameterHashRef, $jobIDHashRef, $sourceEnvironmentCommandArrayRef, $FILEHANDLE, $emailType, $outDataDir, $outScriptDir, $directoryID, $programDirectory, $programName, $callType, $nrofCores, $processTime, $tempDirectory, $errorTrap, $pipefail
##         : $scriptParameterHashRef           => The active parameters for this analysis hash {REF}
##         : $jobIDHashRef                     => The jobID hash {REF}
##         : $sourceEnvironmentCommandArrayRef => Source environment command {REF}
##         : $FILEHANDLE                       => FILEHANDLE to write to
##         : $emailType                        => The email type
##         : $outDataDir                       => The MIP out data directory
##         : $outScriptDir                     => The MIP out script directory
##         : $directoryID                      => $samplID|$familyID
##         : $programDirectory                 => Builds from $directoryID/$alignerOutDir
##         : $programName                      => Assigns filename to sbatch script
##         : $callType                         => SNV,INDEL or BOTH
##         : $nrofCores                        => The number of cores to allocate
##         : $processTime                      => Hours
##         : $tempDirectory                    => Temporary directory for program {Optional}
##         : $errorTrap                        => Error trap switch
##         : $pipefail                         => Pipe fail switch
 
    my ($argHashRef) = @_;

    ## Default(s)
    my $outDataDir = ${$argHashRef}{outDataDir} //= ${$argHashRef}{scriptParameterHashRef}{outDataDir};
    my $outScriptDir = ${$argHashRef}{outScriptDir} //= ${$argHashRef}{scriptParameterHashRef}{outScriptDir};
    my $tempDirectory = ${$argHashRef}{tempDirectory} //= ${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $emailType = ${$argHashRef}{emailType} //= ${$argHashRef}{scriptParameterHashRef}{emailType};
    my $sourceEnvironmentCommandArrayRef = ${$argHashRef}{sourceEnvironmentCommandArrayRef} //= ${$argHashRef}{scriptParameterHashRef}{sourceEnvironmentCommand};
    my $nrofCores = ${$argHashRef}{nrofCores} //= 1;
    my $processTime = ${$argHashRef}{processTime} //= 1;
    my $pipefail = ${$argHashRef}{pipefail} //= 1;
    my $errorTrap = ${$argHashRef}{errorTrap} //= 1;

    if (defined(${$argHashRef}{callType})) {
	
	${$argHashRef}{callType} = "_".${$argHashRef}{callType};
    }
    ${$argHashRef}{callType} //= "";
    
    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $jobIDHashRef;
    my $FILEHANDLE;
    my $directoryID;
    my $programDirectory;
    my $programName;
    my $callType;
   
    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	jobIDHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$jobIDHashRef},
	FILEHANDLE => { store => \$FILEHANDLE},
	directoryID => { required => 1, defined => 1, strict_type => 1, store => \$directoryID},
	programDirectory => { required => 1, defined => 1, strict_type => 1, store => \$programDirectory},
	programName => { required => 1, defined => 1, strict_type => 1, store => \$programName},
	callType => { strict_type => 1, store => \$callType},
	outDataDir => { strict_type => 1 },
	outScriptDir => { strict_type => 1 },
	tempDirectory => { strict_type => 1 },
	emailType => { strict_type => 1 },
	sourceEnvironmentCommandArrayRef => { default => [], strict_type => 1 },
	nrofCores => { default => 1,
		       allow => qr/^\d+$/,
		       strict_type => 1, store => \$nrofCores},
	processTime => { default => 1,
			 allow => qr/^\d+$/,
			 strict_type => 1, store => \$processTime},
	pipefail => { default => 1,
		      allow => [0, 1],
		      strict_type => 1, store => \$pipefail},
	errorTrap  => { default => 1,
			allow => [0, 1],
			strict_type => 1, store => \$errorTrap},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    ### Sbatch script names and directory creation

    my $fileNameEnd = ".sh";
    my $fileName;  #The sbatch script - to be created filename
    my $fileNameTracker;

    my $programDataDirectory = catdir($outDataDir, $directoryID, $programDirectory);
    my $fileNamePath = catfile($outScriptDir, $directoryID, $programDirectory, $programName."_".$directoryID.$callType).".";
    my $dryRunFilenamePath = catfile($outScriptDir, $directoryID, $programDirectory, "dry_run_".$programName."_".$directoryID.$callType).".";
    my $fileInfoPath = catfile($outDataDir, $directoryID, $programDirectory, "info", $programName."_".$directoryID.$callType).".";
    my $dryRunFileInfoPath = catfile($outDataDir, $directoryID, $programDirectory, "info", "dry_run_".$programName."_".$directoryID.$callType).".";

    ## Create directories
    make_path(catfile($outDataDir, $directoryID, $programDirectory, "info"),  #Creates the alignerOutDir folder and info data file directory
	      $programDataDirectory,  #Creates the alignerOutDir folder and if supplied the program data file directory
	      catfile($outScriptDir, $directoryID, $programDirectory),  #Creates the alignerOutDir folder script file directory
	);

    ## Set paths depending on dry run or not
    if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	$fileName = $fileNamePath;
    }
    elsif (${$scriptParameterHashRef}{"p".$programName} == 2) {  #Dry run single program

	$fileName = $dryRunFilenamePath;
	$fileInfoPath = $dryRunFileInfoPath;
	$logger->info("Dry Run:\n");
    }
    else {  #Dry run

	$fileName = $dryRunFilenamePath;
	$fileInfoPath = $dryRunFileInfoPath;
	$logger->info("Dry Run:\n");
    }

    ($fileName, $fileNameTracker) = &CheckFileNameExists(\$fileName, \$fileNameEnd);

###Info and Log
    $logger->info("Creating sbatch script for ".$programName." and writing script file(s) to: ".$fileName."\n");
    $logger->info("Sbatch script ".$programName." data files will be written to: ".$programDataDirectory."\n");

###Sbatch header
    open ($FILEHANDLE, ">",$fileName) or $logger->logdie("Can't write to '".$fileName."' :".$!."\n");
    
    say $FILEHANDLE "#! /bin/bash -l";

    if ($pipefail == 1) {

	say $FILEHANDLE "set -o pipefail";  #Detect errors within pipes 
    }
    say $FILEHANDLE "#SBATCH -A ".${$scriptParameterHashRef}{projectID};
    say $FILEHANDLE "#SBATCH -n ".$nrofCores;
    say $FILEHANDLE "#SBATCH -t ".$processTime.":00:00";	
    say $FILEHANDLE "#SBATCH -J ".$programName."_".$directoryID.$callType;
    say $FILEHANDLE "#SBATCH -e ".$fileInfoPath.$fileNameTracker.".stderr.txt";
    say $FILEHANDLE "#SBATCH -o ".$fileInfoPath.$fileNameTracker.".stdout.txt";
    
    if (exists(${$scriptParameterHashRef}{email})) {
	
	if ($emailType =~/B/i) {

	    say $FILEHANDLE "#SBATCH --mail-type=BEGIN";
	}
	if ($emailType =~/E/i) {
	 
	    say $FILEHANDLE "#SBATCH --mail-type=END";
	}
	if ($emailType =~/F/i) {
	    
	    say $FILEHANDLE "#SBATCH --mail-type=FAIL";
	}
	say $FILEHANDLE "#SBATCH --mail-user=".${$scriptParameterHashRef}{email}, "\n";	
    }
    
    say $FILEHANDLE q?echo "Running on: $(hostname)"?;
    say $FILEHANDLE q?PROGNAME=$(basename $0)?,"\n";

    if (@{$sourceEnvironmentCommandArrayRef}) {

	say $FILEHANDLE "##Activate environment";
	say $FILEHANDLE join(' ', @{$sourceEnvironmentCommandArrayRef}), "\n";
    }
    if (defined($tempDirectory)) {  #Not all programs need a temporary directory

	say $FILEHANDLE "## Create temporary directory";
	say $FILEHANDLE q?tempDirectory="?.$tempDirectory.q?"?;  #Assign batch variable
	say $FILEHANDLE q?mkdir -p $tempDirectory?, "\n";
	
	##Create housekeeping function and trap
	say $FILEHANDLE q?finish() {?, "\n";
	say $FILEHANDLE "\t".q?## Perform sbatch exit housekeeping?;
	say $FILEHANDLE "\t".q?rm -rf $tempDirectory?;

	## Output SLURM info on each job via Sacct command and write to MIP Log file(.status)
	&TrackProgress({jobIDHashRef => $jobIDHashRef,
			FILEHANDLE => $FILEHANDLE,
			logFileRef => \${$scriptParameterHashRef}{logFile},
		       });

	say $FILEHANDLE q?}?; 
	say $FILEHANDLE q?trap finish EXIT TERM INT?, "\n";
    }

    if ($errorTrap == 1) {

	## Create error handling function and trap
	say $FILEHANDLE q?error() {?, "\n";
	say $FILEHANDLE "\t".q?## Display error message and exit?;
	say $FILEHANDLE "\t".q{ret="$?"};
	say $FILEHANDLE "\t".q?echo "${PROGNAME}: ${1:-"Unknown Error - ExitCode="$ret}" 1>&2?, "\n";
	say $FILEHANDLE "\t".q?exit 1?;
	
	## Output SLURM info on each job via Sacct command and write to MIP Log file(.status)
	&TrackProgress({jobIDHashRef => $jobIDHashRef,
			FILEHANDLE => $FILEHANDLE,
			logFileRef => \${$scriptParameterHashRef}{logFile},
		       });

	say $FILEHANDLE q?}?;
	say $FILEHANDLE q?trap error ERR?, "\n";
    }
    return ($fileName, $fileInfoPath.$fileNameTracker);  #Return filen name, file path for stdout/stderr for QC check later
}



sub AddMergedInfileName {

##AddMergedInfileName
    
##Function : Add merged infile name after merging all BAM files per sampleID
##Returns  : ""
##Arguments: $scriptParameterHashRef, $sampleInfoHashRef, $laneHashRef, $infilesLaneNoEndingHashRef, $sampleID
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $sampleID                   => The sampleID

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $sampleID = ${$argHashRef}{sampleID};

    ## Mandatory arguments
    my %mandatoryArgument = (scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     sampleID => $sampleID,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "AddMergedInfileName");

    my $infile;
    my $mergeLanes;  #To pick up merged lanes later 
    my $picardToolsMergeSamFilesPrevious = ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{picardToolsMergeSamFilesPrevious};  #Alias

    if ( (defined($picardToolsMergeSamFilesPrevious)) && ($picardToolsMergeSamFilesPrevious == 1) ) {  # Files merged this round with merged file from previous round
	
	for (my $mergeFileCounter=0;$mergeFileCounter<scalar(@{${$scriptParameterHashRef}{picardToolsMergeSamFilesPrevious}});$mergeFileCounter++) {
	    
	    if (${$scriptParameterHashRef}{picardToolsMergeSamFilesPrevious}[$mergeFileCounter] =~ /lane(\d+)|s_(\d+)/) {  #Look for lanes_ or lane\d in previously generated file to be merged with current run to be able to extract previous lanes
		
		##Make sure to always supply lanes from previous regexp 
		if($1) {
		
		    $mergeLanes = $1;
		} 
		else {

		    $mergeLanes = $2;
		}  
		$infile = $sampleID."_lanes_".$mergeLanes;

		for (my $laneCounter=0;$laneCounter<scalar(@ { ${$laneHashRef}{$sampleID} });$laneCounter++) {
		
		    $infile .= ${$laneHashRef}{$sampleID}[$laneCounter];  #Extract lanes per sampleID
		}
	    }
	}
    }
    else {  #Build infile name again

	$infile = $sampleID."_lanes_";

	for (my $laneCounter=0;$laneCounter<scalar(@ { ${$laneHashRef}{$sampleID} });$laneCounter++) {
	   
	    $infile .= ${$laneHashRef}{$sampleID}[$laneCounter];  #Extract lanes per sampleID
	}
    }
    ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{MergeInfile} = $infile;
}


sub SampleInfoQC {

##SampleInfoQC
    
##Function : Adds outDirectory and outfile to sampleInfo to track all files that QC metrics are to be extracted from later
##Returns  : ""
##Arguments: $sampleInfoHashRef, $familyID, $sampleID, $programName, $infile, $outDirectory, $outfileEnding, $outDataType
##         : $sampleInfoHashRef => Info on samples and family hash {REF}
##         : $familyID          => The familyID
##         : $sampleID          => SampleID or "noSampleID" for family level data
##         : $programName       => The program
##         : $infile            => Infile or "noInFile" for family level data
##         : $outDirectory      => The outdirectory of the QC file
##         : $outfileEnding     => The outfile ending. Actually complete outfile for "static" & "infoDirectory"
##         : $outDataType       => Type of data produced by program (infoDirectory|infileDependent|static) 

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $familyID = ${$argHashRef}{familyID};
    my $sampleID = ${$argHashRef}{sampleID};
    my $programName = ${$argHashRef}{programName};
    my $infile = ${$argHashRef}{infile};
    my $outDirectory = ${$argHashRef}{outDirectory};
    my $outfileEnding = ${$argHashRef}{outfileEnding};
    my $outDataType = ${$argHashRef}{outDataType};

    unless (defined($sampleID)) {

	${$sampleInfoHashRef}{ $familyID }{ $familyID }{Program}{ $programName }{OutDirectory} = $outDirectory;  #OutDirectory of QC file
                                                            
	if ($outDataType eq "static") {  #Programs which add a static file in its own directory                                                                                                 

	    ${$sampleInfoHashRef}{ $familyID }{ $familyID }{Program}{ $programName }{OutFile} = $outfileEnding;  #Static QC outfile                                                                     
	}
	if ($outDataType eq "infoDirectory") {  #QC metrics are sent to info files                                                                                                                   

	    ${$sampleInfoHashRef}{ $familyID }{ $familyID }{Program}{ $programName }{OutFile} = $outfileEnding;  #Info stdout file                                                                      
	}
	if ($outDataType eq "infileDependent") {  #Programs which add a filending to infile                                                                                                          

	    ${$sampleInfoHashRef}{ $familyID }{ $familyID }{Program}{ $programName }{OutFile} = $outfileEnding;  #Infile dependent QC outfile                                                                                                                                                                                       
	}

    }
    else {
	
	${$sampleInfoHashRef}{ $familyID }{ $sampleID }{Program}{ $programName }{ $infile }{OutDirectory} = $outDirectory;  #OutDirectory of QC file                                                              

	if ($outDataType eq "static") {  #Programs which add a static file in its own directory 
	    
	    ${$sampleInfoHashRef}{ $familyID }{ $sampleID }{Program}{ $programName }{ $infile }{OutFile} = $outfileEnding;  #Static QC outfile
	}
	if ($outDataType eq "infoDirectory") {  #QC metrics are sent to info files
	    
	    ${$sampleInfoHashRef}{ $familyID }{ $sampleID }{Program}{ $programName }{ $infile }{OutFile} = $outfileEnding;  #Info stdout file
	}
	if ($outDataType eq "infileDependent") {  #Programs which add a filending to infile
	    
	    ${$sampleInfoHashRef}{ $familyID }{ $sampleID }{Program}{ $programName }{ $infile }{OutFile} = $infile.$outfileEnding;  #Infile dependent QC outfile                                                                      
	}
    }
}


sub SplitTargetFile {

##SplitTargetFile
    
##Function : Splits a target file into new contig specific target file
##Returns  : ""
##Arguments: $FILEHANDLE, $inDirectoryRef, $outDirectoryRef, $infileRef, $contigRef, $fileEnding
##         : $FILEHANDLE      => FILEHANDLE to write to
##         : $inDirectoryRef  => Indirectory {REF}
##         : $outDirectoryRef => Analysis outdirectory {REF}
##         : $infileRef       => Target file {REF}
##         : $contigRef       => The contig to extract {REF}
##         : $fileEnding      => File ending to add

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $inDirectoryRef = ${$argHashRef}{inDirectoryRef};
    my $outDirectoryRef = ${$argHashRef}{outDirectoryRef};
    my $infileRef = ${$argHashRef}{infileRef};
    my $contigRef = ${$argHashRef}{contigRef};
    my $fileEnding = ${$argHashRef}{fileEnding};
    
    if (defined($$contigRef)) {  #The contig to split
	
	print $FILEHANDLE q?perl -nae 'if($_=~/^\@/) {print $_;} elsif($_=~/^?.$$contigRef.q?\s+/) {print $_;}' ?;  #Select header and contig
	print $FILEHANDLE catfile($$inDirectoryRef, $$infileRef)." ";  #Infile
	
	if (defined($fileEnding)) {

	    say $FILEHANDLE "> ".catfile($$outDirectoryRef, $$contigRef."_".$$infileRef.$fileEnding). " &"; #Outfile with supplied file ending
	}
	else {

	    say $FILEHANDLE "> ".catfile($$outDirectoryRef, $$contigRef."_".$$infileRef). " &";  #Outfile
	}
    }
}


sub GATKPedigreeFlag {

##GATKPedigreeFlag
    
##Function : Check if "--pedigree" and "--pedigreeValidationType" should be included in analysis
##Returns  : ""
##Arguments: $scriptParameterHashRef, $FILEHANDLE, $outFamilyFileDirectory, $pedigreeValidationType, $programName
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $FILEHANDLE             => FILEHANDLE to write to
##         : $outFamilyFileDirectory => The family data analysis directory 
##         : $pedigreeValidationType => The pedigree validation strictness level
##         : $programName            => The program to use the pedigree file

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $outFamilyFileDirectory = ${$argHashRef}{outFamilyFileDirectory};
    my $pedigreeValidationType = ${$argHashRef}{pedigreeValidationType};
    my $programName = ${$argHashRef}{programName};
    
    ## Mandatory arguments
    my %mandatoryArgument = (scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     FILEHANDLE => $FILEHANDLE,
			     outFamilyFileDirectory => $outFamilyFileDirectory,
			     pedigreeValidationType => $pedigreeValidationType,
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "GATKPedigreeFlag");

    my $famFile = catfile($outFamilyFileDirectory, ${$scriptParameterHashRef}{familyID}.".fam");
    my $parentCounter;
    my $pqParentCounter = q?perl -ne 'my $parentCounter=0; while (<>) { my @line = split(/\t/, $_); unless ($_=~/^#/) { if ( ($line[2] eq 0) || ($line[3] eq 0) ) { $parentCounter++} } } print $parentCounter; last;'?;
    my $childCounter;
    my $pqChildCounter = q?perl -ne 'my $childCounter=0; while (<>) { my @line = split(/\t/, $_); unless ($_=~/^#/) { if ( ($line[2] ne 0) || ($line[3] ne 0) ) { $childCounter++} } } print $childCounter; last;'?;
    
    $parentCounter = `$pqParentCounter $famFile`;  #Count the number of parents
    $childCounter = `$pqChildCounter $famFile`;  #Count the number of children
    
    if ($programName ne "GATKPhaseByTransmission") {
	
	if ($parentCounter > 0) {  #Parents present
	    
	    print $FILEHANDLE "--pedigreeValidationType ".$pedigreeValidationType." --pedigree ".catfile($outFamilyFileDirectory, ${$scriptParameterHashRef}{familyID}.".fam")." ";  #Pedigree files for samples		
	}
    }
    else {
	
	&CheckPedigreeMembers({scriptParameterHashRef => $scriptParameterHashRef,
			       FILEHANDLE => $FILEHANDLE,
			       outFamilyFileDirectoryRef => \$outFamilyFileDirectory,
			       pedigreeValidationTypeRef => \$pedigreeValidationType,
			       parentCounterRef => \$parentCounter,
			       childCounterRef => \$childCounter
			      });  #Special case - GATK PhaseByTransmission needs parent/child or trio 
    }
}


sub CheckPedigreeMembers {

##CheckPedigreeMembers
    
##Function : Detect if the pedigree file contains a valid parent/child or trio
##Returns  : ""
##Arguments: $scriptParameterHashRef, $FILEHANDLE, $outFamilyFileDirectoryRef, $pedigreeValidationTypeRef, $parentCounterRef, $childCounterRef
##         : $scriptParameterHashRef    => The active parameters for this analysis hash {REF}
##         : $FILEHANDLE                => FILEHANDLE to write to
##         : $outFamilyFileDirectoryRef => The family data analysis directory {REF}
##         : $pedigreeValidationTypeRef => The pedigree validation strictness level {REF}
##         : $parentCounterRef          => The number of parent(s) {REF}
##         : $childCounterRef           => The number of children(s) {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $outFamilyFileDirectoryRef = ${$argHashRef}{outFamilyFileDirectoryRef};
    my $pedigreeValidationTypeRef = ${$argHashRef}{pedigreeValidationTypeRef};
    my $parentCounterRef = ${$argHashRef}{parentCounterRef};
    my $childCounterRef = ${$argHashRef}{childCounterRef};
    
    ## Mandatory arguments
    my %mandatoryArgument = (scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     FILEHANDLE => $FILEHANDLE,
			     outFamilyFileDirectoryRef => $outFamilyFileDirectoryRef,
			     pedigreeValidationType => $$pedigreeValidationTypeRef,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "CheckPedigreeMembers");
	    
    if (scalar(@{${$scriptParameterHashRef}{sampleIDs}}) < 4) {  #i.e.1-3 individuals in pedigree		    
		
	if ( ($$childCounterRef == 1) && ($$parentCounterRef > 0) ) {  #Parent/child or trio

	    print $FILEHANDLE "--pedigreeValidationType ".$$pedigreeValidationTypeRef." --pedigree ".catfile($$outFamilyFileDirectoryRef, ${$scriptParameterHashRef}{familyID}.".fam")." ";  #Pedigree files for samples
	}
	else {

	    ${$scriptParameterHashRef}{pGATKPhaseByTransmission} = 0;  #Override input since pedigree is not valid for analysis
	    $logger->info("Switched GATK PhaseByTransmission to 'no run' mode since MIP did not detect a valid pedigree for this type of analysis.");
	    
	    if (${$scriptParameterHashRef}{pGATKReadBackedPhasing} > 0) {  #Broadcast
		
		$logger->info("MIP will still try to run GATK ReadBackedPhasing, but with the '-respectPhaseInInput' flag set to false\n");
	    }
	}
    }
    else {
	
	${$scriptParameterHashRef}{pGATKPhaseByTransmission} = 0;  #Override input since pedigree is not valid for analysis
	$logger->info("Switched GATK PhaseByTransmission to 'no run' mode since MIP did not detect a valid pedigree for this type of analysis.");
	
	if (${$scriptParameterHashRef}{pGATKReadBackedPhasing} > 0) {  #Broadcast
	    
	    $logger->info("MIP will still try to run GATK ReadBackedPhasing, but with the '-respectPhaseInInput' flag set to false\n");
	}
    }
}


sub WriteCMDMipLog {

##WriteCMDMipLog
    
##Function : Write CMD to MIP log file
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $orderParametersArrayRef, $scriptRef, $logFileRef
##         : $parameterHashRef        => The parameter hash {REF}
##         : $scriptParameterHashRef  => The active parameters for this analysis hash {REF}
##         : $orderParametersArrayRef => Order of addition to parameter array {REF}
##         : $scriptRef               => The script that is being executed {REF}
##         : $logFileRef              => The log file {REF}
##         : $mipVersionRef           => The MIP version

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;
    my $orderParametersArrayRef;
    my $scriptRef;
    my $logFileRef;
    my $mipVersionRef;

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	orderParametersArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$orderParametersArrayRef},
	scriptRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$scriptRef},
	logFileRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$logFileRef},
	mipVersionRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$mipVersionRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $cmdLine = $$scriptRef." ";

    my @noWrite = ("MIP", "bwaBuildReference", "pBAMCalibrationBlock", "pVariantAnnotationBlock");

    foreach my $orderParameterElement (@{$orderParametersArrayRef}) {
	
	if (defined(${$scriptParameterHashRef}{$orderParameterElement}) ) {

	    if ( ($orderParameterElement eq "configFile") && (${$scriptParameterHashRef}{configFile} eq 0) ) {  #Do not print
	    }
	    else {

		if ( ( any {$_ eq $orderParameterElement} @noWrite ) ) {  #If element is part of array - do nothing
		}
		elsif ( (exists(${$parameterHashRef}{$orderParameterElement}{dataType})) && (${$parameterHashRef}{$orderParameterElement}{dataType} eq "ARRAY")) {  #Array reference

			my $separator = ${$parameterHashRef}{$orderParameterElement}{elementSeparator};
			$cmdLine .= "-".$orderParameterElement." ".join($separator, @{${$scriptParameterHashRef}{$orderParameterElement}})." ";
		}
		elsif ( (exists(${$parameterHashRef}{$orderParameterElement}{dataType})) && (${$parameterHashRef}{$orderParameterElement}{dataType} eq "HASH")) {  #HASH reference

		    $cmdLine .="-".$orderParameterElement." ";  #First key
		    $cmdLine .= join("-".$orderParameterElement." ", map { "$_=${$scriptParameterHashRef}{$orderParameterElement}{$_} " } (keys %{${$scriptParameterHashRef}{$orderParameterElement}}));
		}
		else {
		    $cmdLine .="-".$orderParameterElement." ".${$scriptParameterHashRef}{$orderParameterElement}." ";
		}
	    }
	}
    }
    $logger->info($cmdLine,"\n");
    $logger->info("MIP Version: ".$$mipVersionRef, "\n");
    $logger->info("Script parameters and info from ".$$scriptRef." are saved in file: ".$$logFileRef, "\n");
}


sub WriteYAML {
 
##WriteYAML
    
##Function : Writes a YAML hash to file
##Returns  : ""
##Arguments: $yamlHashRef, $yamlFilePathRef
##         : $yamlHashRef     => The hash to dump {REF}
##         : $yamlFilePathRef => The yaml file to write to {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $yamlHashRef;
    my $yamlFilePathRef;

    my $tmpl = { 
	yamlHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$yamlHashRef},
	yamlFilePathRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$yamlFilePathRef},
    };

    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];
    
    open (my $YAML, ">", $$yamlFilePathRef) or $logger->logdie("Can't open '".$$yamlFilePathRef."':".$!."\n");
    local $YAML::QuoteNumericStrings=1;  #Force numeric values to strings in YAML representation
    say $YAML Dump( $yamlHashRef );
    close($YAML);

    $logger->info("Wrote: ".$$yamlFilePathRef, "\n");
}

sub LoadYAML {
 
##LoadYAML
    
##Function : Loads a YAML file into an arbitrary hash and returns it. Note: Currently only supports hashreferences and hashes and no mixed entries.
##Returns  : %yamlHash
##Arguments: $yamlFile
##         : $yamlFile => The yaml file to load

    my ($argHashRef) = @_;

    ##Flatten argument(s)
    my $yamlFile;

    my $tmpl = { 
	yamlFile => { required => 1, defined => 1, strict_type => 1, store => \$yamlFile},
    };

    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my %yamlHash;

    open (my $YAML, "<", $yamlFile) or die "can't open ".$yamlFile.":".$!, "\n";  #Log4perl not initialised yet, hence no logdie
    local $YAML::QuoteNumericStrings = 1;  #Force numeric values to strings in YAML representation
    %yamlHash = %{ YAML::LoadFile($yamlFile) };  #Load hashreference as hash
        
    close($YAML);

    return %yamlHash;
}


sub CheckUniqueArrayElement {

##CheckUniqueArrayElement
    
##Function : Detects if there are items in queryRef that are not present in arrayToCheckRef. If unique adds the unique element to arrayToCheckRef.
##Returns  : ""
##Arguments: $arrayToCheckRef, $arrayQueryRef
##         : $arrayToCheckRef => The arrayref to be queried {REF}
##         : $queryRef        => The query reference can be either array or scalar {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $arrayToCheckRef;
    my $queryRef;

    my $tmpl = { 
	arrayToCheckRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$arrayToCheckRef},
	queryRef => { required => 1, defined => 1, store => \$queryRef},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $arrayQueryRef;

    if (ref($queryRef) eq "ARRAY") {  #Array reference

	$arrayQueryRef = $queryRef;
    }
    if (ref($queryRef) eq "SCALAR") {  #Scalar reference

	push($arrayQueryRef, $$$queryRef);  #Standardize to array
    }

    ##For each arrayQueryRef element, loop through corresponding arrayToCheckRef element(s), add if there are none or an updated/unique entry.
    foreach my $query (@{$arrayQueryRef}) {
	
	if (! ( any {$_ eq $query} @{$arrayToCheckRef} ) ) { #If element is not part of array
	    
	    push( @{$arrayToCheckRef}, $query);  #Go ahead and add	
	}
    }
}

sub DetermineNrofRapidNodes {

##DetermineNrofRapidNodes
    
##Function : Determines the number of nodes to allocate depending on the sequence read length, which affects the infile size.
##Returns  : $numberNodes, $ReadNrofLines
##Arguments: $seqLength, $infileSize
##         : $seqLength     => Length of sequence reads
##         : $infileSize    => Size of the infile

    my $seqLength = $_[0]; 
    my $infileSize = $_[1];
    
    my $numberNodes = 0;  #Nodes to allocate
    my $readPositionWeight = 1;  #Scales the readStart and readStop position
    my $ReadNrofLines;    

    if ($seqLength > 75 && $seqLength <= 101) {

	$ReadNrofLines = 190000000;  #Read batch size
	$numberNodes = floor($infileSize / (12 * $ReadNrofLines) );  #Determines the number of nodes to use, 150000000 ~ 37,5 million reads, 13 = 2 sdtdev from sample population - currently poor estimate with compression confunding calculation.	
	$logger->info("Number of Nodes: ".$numberNodes, "\n");
    }
    if ($seqLength > 50 && $seqLength <= 75) {

	$ReadNrofLines = 190000000;  #Read batch size
	$numberNodes = floor($infileSize / (9.75 * $ReadNrofLines) );  #Determines the number of nodes to use, 150000000 ~ 37,5 million reads, 13 = 2 sdtdev from sample population - currently poor estimate with compression confunding calculation.	
	$logger->info("Number of Nodes: ".$numberNodes, "\n");
    }
    if ($seqLength >= 50 && $seqLength < 75) {

	$ReadNrofLines = 130000000;  #Read batch size
	$numberNodes = floor($infileSize / (7 * $ReadNrofLines) );  #Determines the number of nodes to use, 150000000 ~ 37,5 million reads, 13 = 2 sdtdev from sample population - currently poor estimate with compression confunding calculation.
	$logger->info("Number of Nodes: ".$numberNodes, "\n");
    }
    if ($seqLength >= 35 && $seqLength < 50) {

	$ReadNrofLines = 95000000;  #Read batch size
	$numberNodes = floor($infileSize / (6 * $ReadNrofLines) );  #Determines the number of nodes to use, 150000000 ~ 37,5 million reads, 13 = 2 sdtdev from sample population - currently poor estimate with compression confunding calculation.
	$logger->info("Number of Nodes: ".$numberNodes, "\n");
    }
    if ($numberNodes <= 1) {
	
	$numberNodes = 2;  #Ensure that at least 1 readbatch is processed
    }
    return $numberNodes, $ReadNrofLines;
}


sub CheckUniqueIDNs {

##CheckUniqueIDNs
    
##Function : Test that the familyID and the sampleID(s) exists and are unique. Check if id sampleID contains "_".
##Returns  : "" 
##Arguments: $scriptParameterHashRef, $sampleIdArrayRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $sampleIDArrayRef       => Array to loop in for parameter {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $sampleIdArrayRef;

    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	sampleIdArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$sampleIdArrayRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my %seen;  #Hash to test duplicate sampleIDs later

    if (!@{$sampleIdArrayRef}) {

	$logger->fatal("Please provide sampleID(s)\n");
	exit 1;
    }

    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{$sampleIdArrayRef});$sampleIDCounter++) {

	$seen{ ${$sampleIdArrayRef}[$sampleIDCounter] }++;  #Increment instance to check duplicates later
	
	if (${$scriptParameterHashRef}{familyID} eq ${$sampleIdArrayRef}[$sampleIDCounter]) {  #FamilyID cannot be the same as sampleID
	    
	    $logger->fatal("FamilyID: ".${$scriptParameterHashRef}{familyID}." equals sampleID: ".${$sampleIdArrayRef}[$sampleIDCounter].". Please make sure that the familyID and sampleID(s) are unique.\n");
	    exit 1;
	}
	if ($seen{ ${$sampleIdArrayRef}[$sampleIDCounter] } > 1) {  #Check sampleID are unique
	
	    $logger->fatal("SampleID: ".${$sampleIdArrayRef}[$sampleIDCounter]." is not uniqe.\n");
	    exit 1;
	}
	if (${$sampleIdArrayRef}[$sampleIDCounter] =~/_/) {  #SampleID contains "_", which is not allowed according to filename conventions

	    $logger->fatal("SampleID: ".${$sampleIdArrayRef}[$sampleIDCounter]." contains '_'. Please rename sampleID according to MIP's filename convention, removing the '_'.\n");
	    exit 1;
	}
    }
}


sub UpdateConfigFile {

##UpdateConfigFile
    
##Function : Updates the config file to particular user/cluster for entries following specifications. Leaves other entries untouched.
##Returns  : "" 
##Arguments: $scriptParameterHashRef, $parameterNameRef, $familyIDRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $parameterNameRef       => MIP Parameter to update {REF}
##         : $familyIDRef            => Sets the familyID {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $parameterNameRef;
    my $familyIDRef;

    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	parameterNameRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$parameterNameRef},
	familyIDRef => { default => \$$, strict_type => 1, store => \$familyIDRef},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];
    
    if (${$scriptParameterHashRef}{$$parameterNameRef}) {  #Active parameter
	
	if (defined(${$scriptParameterHashRef}{clusterConstantPath})) {  #Set the project specific path for this cluster
	 
	    ${$scriptParameterHashRef}{$$parameterNameRef} =~ s/CLUSTERCONSTANTPATH!/${$scriptParameterHashRef}{clusterConstantPath}/gi;  #Exchange CLUSTERCONSTANTPATH! for current cluster path
	}
	if (defined(${$scriptParameterHashRef}{analysisConstantPath})) { #Set the project specific path for this cluster
	 
	    ${$scriptParameterHashRef}{$$parameterNameRef} =~ s/ANALYSISCONSTANTPATH!/${$scriptParameterHashRef}{analysisConstantPath}/gi;  #Exchange ANALYSISCONSTANTPATH! for the current analysis path
	}
	if (defined(${$scriptParameterHashRef}{analysisType})) {  #Set the analysis run type e.g., "exomes", "genomes", "rapid"

	    ${$scriptParameterHashRef}{$$parameterNameRef} =~ s/ANALYSISTYPE!/${$scriptParameterHashRef}{analysisType}/gi;  #Exchange ANALYSISTYPE! for the current analysis type
	}
	if (defined($$familyIDRef)) {  #Set the familyID

	    ${$scriptParameterHashRef}{$$parameterNameRef} =~ s/FDN!/$$familyIDRef/gi;  #Exchange FND! for the current familyID
	}
	if (defined(${$scriptParameterHashRef}{alignerOutDir})) {  #Set the alignerOutDir used

	    ${$scriptParameterHashRef}{$$parameterNameRef} =~ s/ALIGNEROUTDIR!/${$scriptParameterHashRef}{alignerOutDir}/gi;  #Exchange ALIGNEROUTDIR! for the current alignerOutDir
	}
    }
}


sub CheckAutoBuild {

##CheckAutoBuild
    
##Function : Checks if autobuild is on and returns "1" if enabled or "0" if not
##Returns  : "0|1" 
##Arguments: $parameterHashRef, $scriptParameterHashRef, $parameterNameRef, $sampleIDRef
##         : $parameterHashRef       => The parameter hash {REF}
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $parameterNameRef       => MIP parameter name {REF}
##         : $sampleIDRef            => SampleId {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;
    my $parameterNameRef;
    my $sampleIDRef;

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	parameterNameRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$parameterNameRef},
	sampleIDRef => { default => \$$, strict_type => 1, store => \$sampleIDRef},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    if (defined($sampleIDRef)) {
	
	if ( (${$parameterHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{$$parameterNameRef}{buildFile} eq "yesAutoBuild") || (${$parameterHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{$$parameterNameRef}{buildFile} eq "yesAutoDownLoad") || (${$parameterHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{$$parameterNameRef}{buildFile} eq 1) ) {
	    
	    return "1";  #Flag that autobuild is needed
	}
	else {

	    return "0";  #No autobuild is needed   
	}
    }
    else {
	
	if ( (${$parameterHashRef}{$$parameterNameRef}{buildFile} eq "yesAutoBuild") || (${$parameterHashRef}{$$parameterNameRef}{buildFile} eq 1) ) {  #1 for arrays

	    return "1";  #Flag that autobuild is needed
	}
	elsif ( (${$parameterHashRef}{$$parameterNameRef}{buildFile} eq "yesAutoDownLoad") || (${$parameterHashRef}{$$parameterNameRef}{buildFile} eq 1) ) {
	    
	    if (${$parameterHashRef}{$$parameterNameRef}{default} eq ${$scriptParameterHashRef}{$$parameterNameRef}) {
		
		return "1";  #Flag that autobuild is needed
	    }
	    else {
		
		$logger->fatal("Could not find file ".catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{$$parameterNameRef}), "\n");
		$logger->fatal("Make sure that file exists or use the default for this parameter to enable automatic download via Cosmid", "\n");
		exit 1;
	    }
	}
	else {

	    return "0";  #No autobuild is needed   
	}
    }
}


sub ParseHumanGenomeReference {

##ParseHumanGenomeReference
    
##Function : Detect version and source of the humanGenomeReference: Source (hg19 or GRCh).
##Returns  : ""
##Arguments: $fileInfoHashRef, $humanGenomeReferenceRef
##         : $fileInfoHashRef         => The fileInfo hash {REF}
##         : $humanGenomeReferenceRef => The human genome {REF}
    
    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $fileInfoHashRef;# = $_[0];
    my $humanGenomeReferenceRef;# = $_[1];
    
    my $tmpl = { 
	fileInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$fileInfoHashRef},
	humanGenomeReferenceRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$humanGenomeReferenceRef},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    if ($$humanGenomeReferenceRef =~/^Homo_sapiens.GRCh(\d+\.\d+|\d+)/) {  #Used to change capture kit genome reference version later

	${$fileInfoHashRef}{humanGenomeReferenceVersion} = $1;
	${$fileInfoHashRef}{humanGenomeReferenceSource} = "GRCh";  #Ensembl
    }
    elsif ($$humanGenomeReferenceRef =~/^Homo_sapiens.hg(\d+)/) {  #Used to change capture kit genome reference version later

	${$fileInfoHashRef}{humanGenomeReferenceVersion} = $1;
	${$fileInfoHashRef}{humanGenomeReferenceSource} = "hg";  #Refseq
    }
    else {

	$logger->warn("MIP cannot detect what kind of humanGenomeReference you have supplied. If you want to automatically set the capture kits used please supply the refrence on this format: [Species].[Source][Version].", "\n");
    }
    ## Removes ".fileEnding" in filename.FILENDING(.gz)
    ${$fileInfoHashRef}{humanGenomeReferenceNameNoEnding} = &RemoveFileEnding({fileNameRef => $humanGenomeReferenceRef,
									       fileEnding => ".fasta",
									      });

    ${$fileInfoHashRef}{humanGenomeCompressed} = &CheckGzipped({fileNameRef => $humanGenomeReferenceRef,
							       });
}


sub CheckFileEndingsToBeBuilt {

##CheckFileEndingsToBeBuilt
    
##Function : Checks files to be built by combining filename stub with fileendings.
##Returns  : "" 
##Arguments: $parameterHashRef, $scriptParameterHashRef, fileEndingsArrayRef, $parameterName, $referencesDirRef
##         : $parameterHashRef       => The parameter hash {REF}
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $fileEndingsArrayRef    => Reference to the fileEndings to be added to the filename stub {REF}
##         : $parameterName          => MIP parameter name
##         : $referencesDirRef       => MIP reference directory
    
    my ($argHashRef) = @_;

    ## Default(s)
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};

    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;
    my $fileEndingsArrayRef;
    my $parameterName;
    my $fileName;

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	fileEndingsArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$fileEndingsArrayRef},
	parameterName => { required => 1, defined => 1, strict_type => 1, store => \$parameterName},
	fileName => { required => 1, defined => 1, strict_type => 1, store => \$fileName},
	referencesDirRef => { default => \$$, strict_type => 1},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];
    
    foreach my $fileEnding (@{$fileEndingsArrayRef}) {

	my $path = catfile($$referencesDirRef, $fileName.$fileEnding);

	&CheckExistance({parameterHashRef => $parameterHashRef,
			 scriptParameterHashRef => $scriptParameterHashRef,
			 itemNameRef => \$path,
			 parameterNameRef => \$parameterName,
			 itemTypeToCheck => "file",
			});
    }
}


sub CheckExistance {

##CheckExistance
    
##Function : Checks if a file/directory exists and if autoBuild is on or not. If file/directory does not extis and there is no autobuild, croaks and exists.
##Returns  : "" 
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleIDRef, $itemNameRef, $parameterNameRef, $itemTypeToCheck, $tempDirectoryRef
##         : $parameterHashRef       => The parameters hash
##         : $scriptParameterHashRef => The active parameter for this analysis hash
##         : $sampleIDRef            => Name of sample {REF}
##         : $itemNameRef            => Item to check for existance {REF}
##         : $parameterNameRef       => MIP parameter name {REF}
##         : $itemTypeToCheck        => The type of item to check
##         : $tempDirectoryRef       => The temporary directory

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};

    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;
    my $itemNameRef;
    my $parameterNameRef;
    my $itemTypeToCheck;
    my $sampleIDRef;

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	itemNameRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$itemNameRef},
	parameterNameRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$parameterNameRef},
	itemTypeToCheck => { required => 1, defined => 1, strict_type => 1, store => \$itemTypeToCheck},
	sampleIDRef => { default => \$$, strict_type => 1, store => \$sampleIDRef},
	tempDirectoryRef => { default => \$$, strict_type => 1},
    };

    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    if ($itemTypeToCheck eq "directory") {

	unless (-d $$itemNameRef) {  #Check existence of supplied directory
	    
	    $logger->fatal($USAGE, "\n");
	    $logger->fatal("Could not find intended ".$$parameterNameRef." directory: ".$$itemNameRef, "\n");
	    exit 1;		
	}
    }
    elsif ($itemTypeToCheck eq "file") {
	
	unless (-f $$itemNameRef) {  #Check existence of supplied file in supplied reference dir

	    if (defined($sampleIDRef)) {  #Individual files per sampleID

		## Check autoBuild or not and return value
		${$parameterHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{$$parameterNameRef}{buildFile} = &CheckAutoBuild({parameterHashRef => $parameterHashRef,
																	      scriptParameterHashRef => $scriptParameterHashRef,
																	      parameterNameRef => $parameterNameRef,
																	      sampleIDRef => $sampleIDRef
																	     });

		if (${$parameterHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{$$parameterNameRef}{buildFile} == 0) {  #No autobuild
		    
		    $logger->fatal($USAGE, "\n");
		    $logger->fatal("Could not find intended ".$$parameterNameRef." file: ".$$itemNameRef, "\n");
		    exit 1;		
		}
	    }
	    else {

		## Check autoBuild or not and return value
		${$parameterHashRef}{$$parameterNameRef}{buildFile} = &CheckAutoBuild({parameterHashRef => $parameterHashRef,
										       scriptParameterHashRef => $scriptParameterHashRef,
										       parameterNameRef => $parameterNameRef,
										      });

		if (${$parameterHashRef}{$$parameterNameRef}{buildFile} == 0) {  #No autobuild
		    
		    $logger->fatal($USAGE, "\n");
		    $logger->fatal("Could not find intended ".$$parameterNameRef." file: ".$$itemNameRef, "\n");
		    exit 1;		
		}
	    }
	}
	else {

	    if (defined($sampleIDRef)) {

		${$parameterHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{$$parameterNameRef}{buildFile} = 0;  #File exist in this check
	    }
	    else {

		if ( (defined(${$parameterHashRef}{$$parameterNameRef}{buildFile})) && (${$parameterHashRef}{$$parameterNameRef}{buildFile} ne 1) ) { #If any of associated files do not exist make sure to build them
 
		    ${$parameterHashRef}{$$parameterNameRef}{buildFile} =  0;  #File exist in this check
		}
	    }
	}
    }
}


sub SetAutoBuildFeature {

##SetAutoBuildFeature
    
##Function : Sets parameters with autoBuild enabled to the new value dependent on $referenceFileNameRef
##Returns  : "" 
##Arguments: $parameterHasRef, $scriptParameterHashRef, $fileInfoHashRef, $broadcastsArrayRef, $parameterName, $referenceFileEndingRef, $referenceFileNameRef, $printSwitch, $sampleIDRef
##         : $parameterHashRef       => The parameter hash {REF}
##         : $scriptParameterHashRef => The activa parameters for this analysis hash {REF}
##         : $fileInfoHashRef        => The fileInfo hash {REF}
##         : $broadcastsArrayRef     => Holds the parameters info for broadcasting later {REF}
##         : $parameterName          => MIP parameter name 
##         : $referenceFileEndingRef => Reference file name ending {REF}
##         : $referenceFileNameRef   => Reference file name {REF}
##         : $printSwitch            => To print or not
##         : $sampleIDRef            => SampleID {REF}

    my ($argHashRef) = @_;

    ## Default(s)
    my $printSwitch = ${$argHashRef}{'printSwitch'} //= 0;

    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;
    my $fileInfoHashRef;
    my $broadcastsArrayRef;
    my $referenceFileEndingRef;
    my $referenceFileNameRef;
    my $sampleIDRef;
    my $parameterName;

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	fileInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$fileInfoHashRef},
	broadcastsArrayRef => { default => [], strict_type => 1, store => \$broadcastsArrayRef},
	referenceFileEndingRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$referenceFileEndingRef},
	referenceFileNameRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$referenceFileNameRef},
	sampleIDRef => { default => \$$, strict_type => 1, store => \$sampleIDRef},
	parameterName => { required => 1, defined => 1, strict_type => 1, store => \$parameterName},
	printSwitch => { strict_type => 1, store => \$printSwitch},

    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];
     
     if( defined(${$scriptParameterHashRef}{$parameterName}) && (${$scriptParameterHashRef}{$parameterName} eq "notSetYet") ) { 

	 ${$scriptParameterHashRef}{$parameterName} = $$referenceFileNameRef.$$referenceFileEndingRef;

	 if ($printSwitch) {

	     if (@{$broadcastsArrayRef}) {

		 my $info = "Set ".$parameterName." to: ".${$scriptParameterHashRef}{$parameterName};
		 push(@{$broadcastsArrayRef}, $info);  #Add info to broadcasts
	     }
	 }
	 if ($parameterName eq "bwaBuildReference") {
	     
	     ## Checks files to be built by combining filename stub with fileendings
	     &CheckFileEndingsToBeBuilt({parameterHashRef => $parameterHashRef,
					 scriptParameterHashRef => $scriptParameterHashRef,
					 fileEndingsArrayRef => \@{${$fileInfoHashRef}{bwaBuildReferenceFileEndings}},
					 parameterName => "bwaBuildReference",
					 fileName => ${$scriptParameterHashRef}{bwaBuildReference},
					});
	 }
	 elsif ($parameterName eq "mosaikJumpDbStub") {

	     ## Checks files to be built by combining filename stub with fileendings
	     &CheckFileEndingsToBeBuilt({parameterHashRef => $parameterHashRef,
					 scriptParameterHashRef => $scriptParameterHashRef,
					 fileEndingsArrayRef => \@{${$fileInfoHashRef}{mosaikJumpDbStubFileEndings}},
					 parameterName => "mosaikJumpDbStub",
					 fileName => ${$scriptParameterHashRef}{mosaikJumpDbStub},
					});
	 }
	 else {  #Complete fileName - No stubs

	     my $path = catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{$parameterName});
	     &CheckExistance({parameterHashRef => $parameterHashRef,
			      scriptParameterHashRef => $scriptParameterHashRef,
			      itemNameRef => \$path,
			      parameterNameRef => \$parameterName,
			      itemTypeToCheck => "file",
			      sampleIDRef =>  $sampleIDRef,
			     });
         }
    }
}


sub MoveMosaikNN {

##MoveMosaikNN

##Function : Locate MOSAIK path and move neural network files in place if lacking
##Returns  : "" 
##Arguments: $scriptParameterHashRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}

    my $scriptParameterHashRef = $_[0];

    my @paths = split(/:/,$ENV{PATH});  #Find Mosaik installation path

    for (my $pathsCounter=0;$pathsCounter<scalar(@paths);$pathsCounter++) {

	if ($paths[$pathsCounter] =~/MOSAIK/) {  #Select MOSAIK path
	    
	   $paths[$pathsCounter] =~ s/bin\//src\/networkFile/g;  #Location of NN files

	   $logger->warn("Could not find Mosaik Network Files in ".${$scriptParameterHashRef}{referencesDir},"\n");
	   $logger->info("Copying Mosaik Network Files ".${$scriptParameterHashRef}{mosaikAlignNeuralNetworkSeFile}." and ".${$scriptParameterHashRef}{mosaikAlignNeuralNetworkPeFile}." to ".${$scriptParameterHashRef}{referencesDir}." from ".$paths[$pathsCounter], "\n");
	   copy(catfile($paths[$pathsCounter], ${$scriptParameterHashRef}{mosaikAlignNeuralNetworkSeFile}), ${$scriptParameterHashRef}{referencesDir});
	   copy(catfile($paths[$pathsCounter], ${$scriptParameterHashRef}{mosaikAlignNeuralNetworkPeFile}), ${$scriptParameterHashRef}{referencesDir});
	   last;
	}
    }
}


sub CheckUserSuppliedInfo {

##CheckUserSuppliedInfo
    
##Function : Determine if the user supplied info on parameter either via cmd or config
##Returns  : "0|1" 
##Arguments: $scriptParameterHashRef, $dataRef, $parameterName
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $dataRef                => Data to check for existence {REF}
##         : $parameterName          => MIP parameter to evaluate
    
    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $dataRef;
    my $parameterName;

    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	dataRef => { required => 1, defined => 1, store => \$dataRef},
	parameterName => { strict_type => 1, store => \$parameterName},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $userSuppliedInfoSwitch;

    if (ref($dataRef) eq "ARRAY") {  #Array reference
	
	if (!@{$dataRef}) {  #No user supplied sample info
	    
   	    if (defined(${$scriptParameterHashRef}{$parameterName})) {  #User supplied info in config file
		
		$userSuppliedInfoSwitch = 1;  #No user supplied cmd info, but present in config file do NOT overwrite using info from pedigree file
	    }
	    else {  #No sampleIDs info in config file
		
		$userSuppliedInfoSwitch = 0;  #No user supplied cmd info, not defined in config file, ADD it from pedigree file
	    }
	}
	else {

	    $userSuppliedInfoSwitch = 1;  #User supplied cmd info, do NOT overwrite using info from pedigree file	
	}
    }
    elsif (ref($dataRef) eq "HASH") {

	if (!%{$dataRef}) {

	    if (defined(${$scriptParameterHashRef}{$parameterName})) {  #User supplied info in config file

		$userSuppliedInfoSwitch = 1;  #No user supplied cmd info, but present in config file do NOT overwrite using info from pedigree file
	    }
	    else {  #No sampleIDs info in config file
		
		$userSuppliedInfoSwitch = 0;  #No user supplied cmd info, not defined in config file, ADD it from pedigree file
	    }
	}
	else {

	    $userSuppliedInfoSwitch = 1;  #User supplied cmd info, do NOT overwrite using info from pedigree file	
	}
    }
    return $userSuppliedInfoSwitch;
}


sub CheckGzipped {

##CheckGzipped
    
##Function : Check if a file is gzipped.
##Returns  : "0 (=unCompressed)| 1 (=compressed)" 
##Arguments: $fileNameRef
##         : $fileNameRef => File name {REF}
    
    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $fileNameRef;# = $_[0];
     
    my $tmpl = { 
	fileNameRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$fileNameRef},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $fileCompressionStatus = 0;

    if ($$fileNameRef =~/.gz$/) {
	
	$fileCompressionStatus = 1; 
    }
    return $fileCompressionStatus;
}


sub RemoveFileEnding {

##RemoveFileEnding
    
##Function : Removes ".fileEnding" in filename.FILENDING(.gz)
##Returns  : File name with supplied $fileEnding or $fileEnding(.gz) removed
##Arguments: $fileNameRef, $fileEnding
##         : $fileNameRef => File name {REF}
##         : $fileEnding  => File ending to be removed

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $fileNameRef;# = ${$argHashRef}{fileNameRef};
    my $fileEnding;# = ${$argHashRef}{fileEnding};

    my $tmpl = { 
	fileNameRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$fileNameRef},
	fileEnding => { required => 1, defined => 1, strict_type => 1, store => \$fileEnding},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $fileNameNoEnding;
    
    if ( (defined($$fileNameRef)) && ($$fileNameRef =~/(\S+)($fileEnding$|$fileEnding.gz$)/) ) {

	$fileNameNoEnding = $1;
    }
    return $fileNameNoEnding;
}


sub ScriptParameterPerSampleID {

##ScriptParameterPerSampleID
    
##Function : Enables target files handled per SampleID to be processed by AddToScriptParameters
##Returns  : ""
##Arguments: $scriptParameterHashRef, $familyIDRef, $sampleIDRef, $parameterName
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $familyIDRef            => Family ID {REF}
##         : $sampleIDRef            => Sample ID  {REF}
##         : $parameterName          => MIP parameter name

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $familyIDRef = ${$argHashRef}{familyIDRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $parameterName = ${$argHashRef}{parameterName};

    if (defined(${$scriptParameterHashRef}{$$familyIDRef}{$$sampleIDRef}{$parameterName})) {
	
	${$scriptParameterHashRef}{$parameterName} = 1;  #Define in scriptParameter so that we know that parameter is present per SampleID
    }
}


sub CheckTargetExistFileBed {

##CheckTargetExistFileBed
    
##Function : Check that supplied target file ends with ".bed" and otherwise exists.
##Returns  : ""
##Arguments: $scriptParameterHashRef, $file, $parameterName
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $file                   => File to check for existance and file ending
##         : $parameterName          => MIP parameter name

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $file;
    my $parameterName;

    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	file => { required => 1, defined => 1, strict_type => 1, store => \$file},
	parameterName => { required => 1, defined => 1, strict_type => 1, store => \$parameterName},
	
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    if ($file !~/.bed$/) {
	
	$logger->fatal("Could not find intendended '.bed file ending' for target file: ".$file." in parameter '-".$parameterName."'", "\n");
	exit 1;
    }
}


sub CompareArrayElements {

##CompareArrayElements
    
##Function : Compares the number of elements in two arrays and exits if the elements are not equal.
##Returns  : ""
##Arguments: $arrayRef, $arrayQueryRef, $parameterName, $parameterNameQuery
##         : $arrayRef           => Array to match {REF}
##         : $arrayQueryRef      => Array to be compared {REF}
##         : $parameterName      => MIP reference parameter
##         : $parameterNameQuery => MIP query parameter

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $arrayRef;
    my $arrayQueryRef;
    my $parameterName;
    my $parameterNameQuery;
    
    my $tmpl = { 
	arrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$arrayRef},
	arrayQueryRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$arrayQueryRef},
	parameterName => { required => 1, defined => 1, strict_type => 1, store => \$parameterName},
	parameterNameQuery => { required => 1, defined => 1, strict_type => 1, store => \$parameterNameQuery},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    if (scalar(@{$arrayRef}) != scalar(@{$arrayQueryRef})) {
	
	$logger->fatal("The number of supplied '-".$parameterNameQuery."' (=".scalar(@{$arrayQueryRef}).") do not equal the number of '-".$parameterName."' (=".scalar(@{$arrayRef})."). Please specify a equal number of elements for both parameters", "\n");
	exit 1;
    }
}


sub PrintCheckExistandMoveFile {

##PrintCheckExistandMoveFile
    
##Function : Checks if a file exists and moves the file in place if file is lacking or has a size of 0 bytes.
##Returns  : ""
##Arguments: $FILEHANDLE, $intendedFilePathRef, $temporaryFilePathRef
##         : $FILEHANDLE           => FILEHANDLE to write to
##         : $intendedFilePathRef  => Path to file to check for existence {REF}
##         : $temporaryFilePathRef => File that has been created {REF}
    
    my $FILEHANDLE = $_[0]; 
    my $intendedFilePathRef = $_[1]; 
    my $temporaryFilePathRef = $_[2];
    
    print $FILEHANDLE "[ -s ".$$intendedFilePathRef." ] ";  #Check file exists and is larger than 0
    print $FILEHANDLE "&& rm ".$$temporaryFilePathRef." ";  #If other processes already has created file, remove temp file
    print $FILEHANDLE "|| ";  #File has not been created by other processes
    say $FILEHANDLE "mv ".$$temporaryFilePathRef." ".$$intendedFilePathRef,"\n";  #Move file in place
    
}


sub DefineSnpEffFiles {

##DefineSnpEffFiles

##Function : Defines and adds snpEff/snpSift files and features to hash
##Returns  : ""
##Arguments: $parameterHashRef
##         : $parameterHashRef        => The parameter hash {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $parameterHashRef;
    
    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my %snpEffFile;
    my @snpSiftDownloadableFiles = ("dbsnp_138.b37.excluding_sites_after_129.vcf", "dbsnp_138.b37.vcf", "1000G_phase1.indels.b37.vcf", "1000G_phase1.snps.high_confidence.b37.vcf");

    foreach my $file (@snpSiftDownloadableFiles) {
	
	$snpEffFile{snpSift}{$file} = ({downloadable => "yes",  #Files that are downloadable via Cosmid
				       });
	push(@{${$parameterHashRef}{$file}{associatedProgram}}, "pSnpEff");
	${$parameterHashRef}{$file}{dataType} = "SCALAR";
	${$parameterHashRef}{$file}{buildFile} = "yesAutoBuild";  #Allow autoDownLoad, but yesAutoBuild is set since the file is its own default, so no extra check is required (compared with yesAutoDownLoad)
    }
    return %snpEffFile;
}

sub DefineAnnovarTables {
    
##DefineAnnovarTables
    
##Function : Defines and adds annovar tables parameters to hash
##Returns  : ""
##Arguments: $parameterHashRef, $annovarSupportedTableNamesArrayRef, $annovarGenomeBuildVersionRef
##         : $parameterHashRef                   => The parameter hash {REF}
##         : $annovarSupportedTableNamesArrayRef => The supported annovar reference names array {REF}
##         : $annovarGenomeBuildVersionRef       => The current annovar genome build

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $parameterHashRef;
    my $annovarSupportedTableNamesArrayRef;
    my $annovarGenomeBuildVersionRef;

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	annovarSupportedTableNamesArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$annovarSupportedTableNamesArrayRef},
	annovarGenomeBuildVersionRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$annovarGenomeBuildVersionRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my %annovarTable;  #Holds all annovar tables parameters and features

    ##Define annovar tables
    my @annovarTablesGeneAnno = ("refGene", "knownGene", "ensGene");  #Tables using annotation option "geneanno"
    my @annovarTablesRegionAnno = ("mce46way", "gerp++elem", "segdup", "tfbs", "mirna");  #Tables using annotation option "regionanno"
    my @annovarTablesFilter = ("snp137", "snp135", "snp132", "snp131", "snp130", "snp129", "snp137NonFlagged", "snp135NonFlagged", "snp132NonFlagged", "snp131NonFlagged", "snp130NonFlagged", "1000g2012apr_all", "1000g2012apr_amr", "1000g2012apr_eur", "1000g2012apr_asn", "1000g2012apr_afr", "1000g2012feb_all", "esp6500si_all", "esp6500_all", "esp6500_aa", "esp6500_ea", "esp5400_all", "esp5400_aa", "esp5400_ea","clinvar_20131105", "ljb2_sift", "ljb2_pp2hdiv", "ljb2_pp2hvar", "ljb2_mt", "ljb2_ma", "ljb2_fathmm", "ljb2_siphy", "ljb2_lrt", "ljb_all", "ljb2_gerp++", "ljb2_phylop", "caddgt20", "caddgt10");  #Tables using annotation option "filter"
    my @annovarTablesUrlUcsc = ("mce46way", "segdup", "tfbs", "mirna");  #Tables using urlAlias "ucsc"
    my @annovarGenericFiltering = ("esp6500si_all", "esp6500_all", "esp6500_aa", "esp6500_ea", "esp5400_all", "esp5400_aa", "esp5400_ea","clinvar_20131105");  #Tables using generic option
    my @annovarGenericFiles = ($$annovarGenomeBuildVersionRef."_esp6500si_all.txt", $$annovarGenomeBuildVersionRef."_esp6500_all.txt", $$annovarGenomeBuildVersionRef."_esp6500_aa.txt", $$annovarGenomeBuildVersionRef."_esp6500_ea.txt", $$annovarGenomeBuildVersionRef."_esp5400_all.txt", $$annovarGenomeBuildVersionRef."_esp5400_aa.txt", $$annovarGenomeBuildVersionRef."_esp5400_ea.txt", $$annovarGenomeBuildVersionRef."_clinvar_20131105.txt");  #Generic table files
    my @annovarRefgeneFiles = ($$annovarGenomeBuildVersionRef."_refGene.txt", $$annovarGenomeBuildVersionRef."_refGeneMrna.fa", $$annovarGenomeBuildVersionRef."_refLink.txt", "GRCh37_MT_ensGene.txt", "GRCh37_MT_ensGeneMrna.fa");  #Cater for multiple download
    my @annovarKnownGeneFiles = ($$annovarGenomeBuildVersionRef."_knownGene.txt", $$annovarGenomeBuildVersionRef."_kgXref.txt", $$annovarGenomeBuildVersionRef."_knownGeneMrna.fa");  #Cater for multiple download
    my @annovarEnsGeneFiles = ($$annovarGenomeBuildVersionRef."_ensGene.txt", $$annovarGenomeBuildVersionRef."_ensGeneMrna.fa", "GRCh37_MT_ensGene.txt", "GRCh37_MT_ensGeneMrna.fa");  #Cater for multiple download

    #Set UCSC alias for download from UCSC
    $annovarTable{mce46way}{ucscAlias} = "phastConsElements46way";
    $annovarTable{segdup}{ucscAlias} = "genomicSuperDups";
    $annovarTable{tfbs}{ucscAlias} = "tfbsConsSites";
    $annovarTable{mirna}{ucscAlias} = "wgRna";

    #Set GeneAnno files
    push(@{$annovarTable{refGene}{File}}, @annovarRefgeneFiles);
    push(@{$annovarTable{knownGene}{File}}, @annovarKnownGeneFiles);
    push(@{$annovarTable{ensGene}{File}}, @annovarEnsGeneFiles); 

    for (my $tablesCounter=0;$tablesCounter<scalar(@{$annovarSupportedTableNamesArrayRef});$tablesCounter++) {
	
	&AnnovarTableParameters({annovarTableHashRef => \%annovarTable,
				 tableNameRef => \$annovarSupportedTableNames[$tablesCounter],
				 arrayRef => $annovarSupportedTableNamesArrayRef,
				 parameterType => "dbtype",
				 parameterValue => $annovarSupportedTableNames[$tablesCounter],
				});
	&AnnovarTableParameters({annovarTableHashRef => \%annovarTable,
				 tableNameRef => \$annovarSupportedTableNames[$tablesCounter],
				 arrayRef => $annovarSupportedTableNamesArrayRef,
				 parameterType => "download",
				 parameterValue => $annovarSupportedTableNames[$tablesCounter],
				});
	${$parameterHashRef}{$annovarSupportedTableNames[$tablesCounter]}{buildFile} = "yesAutoBuild";  #Allow autobuild
    }


    #Tables using different download call from dbtype call
    $annovarTable{'1000g2012apr_all'}{download} = "ALL.sites.2012_04";
    $annovarTable{'1000g2012feb_all'}{download} = "ALL.sites.2012_02";
    $annovarTable{'1000g2012apr_afr'}{download} = "AFR.sites.2012_04";
    $annovarTable{'1000g2012apr_amr'}{download} = "AMR.sites.2012_04";
    $annovarTable{'1000g2012apr_eur'}{download} = "EUR.sites.2012_04";
    $annovarTable{'1000g2012apr_asn'}{download} = "ASN.sites.2012_04";

    #Set 1000G Table filename
    $annovarTable{'1000g2012apr_all'}{File}[0] = $$annovarGenomeBuildVersionRef."_ALL.sites.2012_04.txt";
    $annovarTable{'1000g2012feb_all'}{File}[0] = $$annovarGenomeBuildVersionRef."_ALL.sites.2012_02.txt";
    $annovarTable{'1000g2012apr_afr'}{File}[0] = $$annovarGenomeBuildVersionRef."_AFR.sites.2012_04.txt";
    $annovarTable{'1000g2012apr_amr'}{File}[0] = $$annovarGenomeBuildVersionRef."_AMR.sites.2012_04.txt";
    $annovarTable{'1000g2012apr_eur'}{File}[0] = $$annovarGenomeBuildVersionRef."_EUR.sites.2012_04.txt";
    $annovarTable{'1000g2012apr_asn'}{File}[0] = $$annovarGenomeBuildVersionRef."_ASN.sites.2012_04.txt";

    for (my $tablesCounter=0;$tablesCounter<scalar(@annovarTablesGeneAnno);$tablesCounter++) {

	&AnnovarTableParameters({annovarTableHashRef => \%annovarTable,
				 tableNameRef => \$annovarTablesGeneAnno[$tablesCounter],
				 arrayRef => \@annovarTablesGeneAnno,
				 parameterType => "annotation",
				 parameterValue => "geneanno",
				});
	&AnnovarTableParameters({annovarTableHashRef => \%annovarTable,
				 tableNameRef => \$annovarTablesGeneAnno[$tablesCounter],
				 arrayRef => \@annovarTablesGeneAnno,
				 parameterType => "urlAlias",
				 parameterValue => "annovar",
				});
    }
    for (my $tablesCounter=0;$tablesCounter<scalar(@annovarTablesRegionAnno);$tablesCounter++) {

	&AnnovarTableParameters({annovarTableHashRef => \%annovarTable,
				 tableNameRef => \$annovarTablesRegionAnno[$tablesCounter],
				 arrayRef => \@annovarTablesRegionAnno,
				 parameterType => "annotation",
				 parameterValue => "regionanno",
				});
	&AnnovarTableParameters({annovarTableHashRef => \%annovarTable,
				 tableNameRef => \$annovarTablesRegionAnno[$tablesCounter],
				 arrayRef => \@annovarTablesRegionAnno,
				 parameterType => "urlAlias",
				 parameterValue => "annovar",
				});
	&AnnovarTableParameters({annovarTableHashRef => \%annovarTable,
				 tableNameRef => \$annovarTablesRegionAnno[$tablesCounter],
				 arrayRef => \@annovarTablesUrlUcsc,
				 parameterType => "urlAlias",
				 parameterValue => "ucsc",
				});  #Replace for ucsc tables NOTE: not all in RegionAnno
    }
    for (my $tablesCounter=0;$tablesCounter<scalar(@annovarTablesFilter);$tablesCounter++) {

	&AnnovarTableParameters({annovarTableHashRef => \%annovarTable,
				 tableNameRef => \$annovarTablesFilter[$tablesCounter],
				 arrayRef => \@annovarTablesFilter,
				 parameterType => "annotation",
				 parameterValue => "filter",
				});
	&AnnovarTableParameters({annovarTableHashRef => \%annovarTable,
				 tableNameRef => \$annovarTablesFilter[$tablesCounter],
				 arrayRef => \@annovarTablesFilter,
				 parameterType => "urlAlias",
				 parameterValue => "annovar",
				});
	&AnnovarTableParameters({annovarTableHashRef => \%annovarTable,
				 tableNameRef => \$annovarTablesFilter[$tablesCounter],
				 arrayRef => \@annovarTablesFilter,
				 parameterType => "indexFile",
				 parameterValue => ".idx",
				}); 
    }	
    for (my $tablesCounter=0;$tablesCounter<scalar(@annovarGenericFiltering);$tablesCounter++) {
	
	&AnnovarTableParameters({annovarTableHashRef => \%annovarTable,
				 tableNameRef => \$annovarGenericFiltering[$tablesCounter],
				 arrayRef => \@annovarGenericFiltering,
				 parameterType => "dbtype",
				 parameterValue => "generic",
				});
	&AnnovarTableParameters({annovarTableHashRef => \%annovarTable,
				 tableNameRef => \$annovarGenericFiltering[$tablesCounter],
				 arrayRef => \@annovarGenericFiltering,
				 parameterType => "file",
				 parameterValue => $annovarGenericFiles[$tablesCounter],
				});
    }
    return %annovarTable;
}


sub AnnovarTableParameters {
   
##AnnovarTableParameters
    
##Function : Populates annovarTable hash by looping through array and adding table with identified membership and associated parameters into hash.
##           Parameters of type "file" are added as a hash of array since multiple files can be downloaded

##Returns  : ""
##Arguments: $annovarTableHashRef, $tableNameRef, $arrayRef, $parameterType, $parameterValue
##         : $annovarTableHashRef => annovarTableHashRef {REF}
##         : $tableNameRef        => Annovar table name {REF}
##         : $arrayRef            => Array to search for membership {REF}
##         : $parameterType       => Type of table parameter
##         : $parameterValue      => Parameter value
    
    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $annovarTableHashRef;
    my $tableNameRef;
    my $arrayRef;
    my $parameterType;
    my $parameterValue;

    my $tmpl = { 
	annovarTableHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$annovarTableHashRef},
	arrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$arrayRef},
	tableNameRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$tableNameRef},
	parameterType => { required => 1, defined => 1, strict_type => 1, store => \$parameterType},
	parameterValue => { required => 1, defined => 1, strict_type => 1, store => \$parameterValue},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];
    
    for (my $tablesCounter=0;$tablesCounter<scalar(@{$arrayRef});$tablesCounter++) {
    
	if (${$arrayRef}[$tablesCounter] eq $$tableNameRef) {  #Membership test
	    
	    if ($parameterType eq "file") {  #Add as array instead, since some annovar tables have multiple files downloaded for the same call
		
		push(@{${$annovarTableHashRef}{$$tableNameRef}{$parameterType}}, $parameterValue);  #Add as array to hashRef
	    }
	    else {
		
		${$annovarTableHashRef}{$$tableNameRef}{$parameterType} = $parameterValue;
	    }
	    last;  #No table should be represented twice within the same array
	}
    }
}


sub CollectSeqContigs {

##CollectSeqContigs
    
##Function : Collects sequences contigs used in analysis from human genome sequence dictionnary associated with $humanGenomeReference
##Returns  : ""
##Arguments: $contigsArrayRef, $referencesDirRef, $humanGenomeReferenceNameNoEndingRef
##         : $contigsArrayRef                     => Contig array {REF}
##         : $referencesDirRef                    => The MIP reference directory {REF}
##         : $humanGenomeReferenceNameNoEndingRef => The associated human genome file without file ending                        

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $contigsArrayRef = ${$argHashRef}{contigsArrayRef};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef};
    my $humanGenomeReferenceNameNoEndingRef = ${$argHashRef}{humanGenomeReferenceNameNoEndingRef};

    my $tmpl = { 
	contigsArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$contigsArrayRef},
	referencesDirRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$referencesDirRef},
	humanGenomeReferenceNameNoEndingRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$humanGenomeReferenceNameNoEndingRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $pqSeqDict = q?perl -nae 'if($F[0]=~/^\@SQ/) { if($F[1]=~/SN\:(\S+)/) {print $1, ",";} }' ?; 
    my $SeqDictLocation = catfile($$referencesDirRef, $$humanGenomeReferenceNameNoEndingRef.".dict");
    @{$contigsArrayRef} = `$pqSeqDict $SeqDictLocation `;  #Returns a comma seperated string of sequence contigs from dict file
    @{$contigsArrayRef} = split(/,/,join(',', @{$contigsArrayRef}));
}


sub CollectSelectFileContigs {

##CollectSelectFileContigs
    
##Function : Collects sequences contigs used in select file
##Returns  : ""
##Arguments: $contigsArrayRef, $selectFilePath
##         : $contigsArrayRef => Contig array {REF}
##         : $selectFilePath  => The select file path

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $contigsArrayRef;
    my $selectFilePath;

    my $tmpl = { 
	contigsArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$contigsArrayRef},
	selectFilePath => { required => 1, defined => 1, strict_type => 1, store => \$selectFilePath},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $pqSeqDict = q?perl -nae 'if ($_=~/contig\=\<ID\=(\w+)/) {print $1, ",";} if($_=~/#CHROM/) {last;}' ?; 
    @{$contigsArrayRef} = `$pqSeqDict $selectFilePath `;  #Returns a comma seperated string of sequence contigs from file
    @{$contigsArrayRef} = split(/,/,join(',', @{$contigsArrayRef}));

    if (!@{$contigsArrayRef}) {

	$logger->fatal("Could not detect any '##contig' in meta data header in select file: ".$selectFilePath."\n");
	exit 1;
    }
}


sub SizeSortSelectFileContigs {

##SizeSortSelectFileContigs
    
##Function : Sorts array depending on reference array. NOTE: Only entries present in reference array will survive in sorted array.
##Returns  : "@sortedArray"
##Arguments: $fileInfoHashRef, $hashKeyToSort, $hashKeySortReference, $analysisTypeRef
##         : $fileInfoHashRef      => The fileInfo hash {REF}
##         : $hashKeyToSort        => The keys to sort
##         : $hashKeySortReference => The hash keys sort reference
##         : $analysisTypeRef      => Type of analysis

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $fileInfoHashRef;
    my $hashKeyToSort;
    my $hashKeySortReference;
    my $analysisTypeRef;

    my $tmpl = { 
	fileInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$fileInfoHashRef},
	hashKeyToSort => { required => 1, defined => 1, strict_type => 1, store => \$hashKeyToSort},
	hashKeySortReference => { required => 1, defined => 1, strict_type => 1, store => \$hashKeySortReference},
	analysisTypeRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$analysisTypeRef}
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];
    
    my @sortedArray;
 
    ##Sort the contigs depending on reference array
    if (${$fileInfoHashRef}{$hashKeyToSort}) {
	
	foreach my $element (@{${$fileInfoHashRef}{$hashKeySortReference}}) {

	    if (! &CheckEntryHashofArray({hashRef => $fileInfoHashRef,
					  key => $hashKeyToSort,
					  element => $element,
					 })
		) {
	    
		push(@sortedArray, $element);
	    }
	}
    }

    ## Test if all contigs collected from select file was sorted by reference contig array
    if ( (@sortedArray) && (scalar(@{${$fileInfoHashRef}{$hashKeyToSort}}) != scalar(@sortedArray)) ) {
	
	foreach my $element (@{${$fileInfoHashRef}{$hashKeyToSort}}) {

	    if ( ! (any {$_ eq $element} @sortedArray) ) {  #If element is not part of array
		
		unless ( ($$analysisTypeRef eq "exomes") && ($element=~/MT$|M$/) ) {  #Special case when analysing exomes since Mitochondrial contigs have no baits in exome capture kits

		    $logger->fatal("Could not detect '##contig'= ".$element." from meta data header in '-vcfParserSelectFile' in reference contigs collected from '-humanGenomeReference'\n");
		exit 1;
		}
		
	    }
	    
	}
    }
    return @sortedArray;
}

sub ReplaceConfigParamWithCMDInfo {

##ReplaceConfigParamWithCMDInfo
    
##Function : Replace config parameter with cmd info for active parameter
##Returns  : 
##Arguments: $parameterHashRef, $scriptParameterHashRef, $parameterNameArrayRef
##         : $parameterHashRef       => The parameter hash {REF}
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $parameterNameArrayRef  => MIP activate parameter names {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;
    my $parameterNameArrayRef;

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	parameterNameArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$parameterNameArrayRef},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    foreach my $parameterName (@{$parameterNameArrayRef}) {

	if (defined(${$parameterHashRef}{$parameterName}{value})) {  #Replace config parameter with cmd info for parameter

	    ${$scriptParameterHashRef}{$parameterName} = ${$parameterHashRef}{$parameterName}{value};  #Transfer to active parameter
	}
	elsif ( (exists(${$parameterHashRef}{$parameterName}{default})) && (!defined(${$scriptParameterHashRef}{$parameterName})) ) {

	    ${$scriptParameterHashRef}{$parameterName} = ${$parameterHashRef}{$parameterName}{default};  #Transfer to active parameter
	}
    }
}


sub DefineSupportedCosmidReferences {

##DefineSupportedCosmidReferences
    
##Function : Defines the Cosmid manager hash keys and populates it from arguments 
##Returns  : ""
##Arguments: $supportedCosmidReferenceHashRef, $parameterName, $cosmidResourceName, $cosmidResourceVersion, 
##         : $supportedCosmidReferenceHashRef => The supported cosmid references hash {REF} 
##         : $parameterName                    => MIP parameter name
##         : $cosmidResourceName               => Cosmid Resource name
##         : $cosmidResourceVersion            => Version of the cosmid Resource to download
##         : $humanGenomeReferenceVersionRef   => The human genome build used in the analysis
##         : $compressedSwitch                 => If files after download are compressed or not

    my ($argHashRef) = @_;

    my $compressedSwitch = ${$argHashRef}{'compressedSwitch'} //= 0;
    
    ## Flatten argument(s)
    my $supportedCosmidReferenceHashRef = ${$argHashRef}{supportedCosmidReferenceHashRef};
    my $parameterName = ${$argHashRef}{parameterName};
    my $cosmidResourceName = ${$argHashRef}{cosmidResourceName};
    my $cosmidResourceVersion = ${$argHashRef}{cosmidResourceVersion};
    my $humanGenomeReferenceVersionRef = ${$argHashRef}{humanGenomeReferenceVersionRef};

    my $tmpl = { 
	supportedCosmidReferenceHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$supportedCosmidReferenceHashRef},
	parameterName => { required => 1, defined => 1, strict_type => 1, store => \$parameterName},
	cosmidResourceName => { required => 1, defined => 1, strict_type => 1, store => \$cosmidResourceName},
	cosmidResourceVersion => { required => 1, defined => 1, strict_type => 1, store => \$cosmidResourceVersion},
	humanGenomeReferenceVersionRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$humanGenomeReferenceVersionRef},
	compressedSwitch => { strict_type => 1, store => \$compressedSwitch},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    ${$supportedCosmidReferenceHashRef}{$parameterName} = {

	cosmidName => $cosmidResourceName,
	version => $cosmidResourceVersion,
	humanGenomeReferenceVersion => $$humanGenomeReferenceVersionRef,
	compressedSwitch => $compressedSwitch,
    };
}


sub CheckCosmidYAML {

##CheckCosmidYAML
    
##Function : Locates and sets the cosmid directory to download to
##Returns  : Path to Cosmid Resource directory for current analysis
##Arguments: $scriptParameterHashRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}

    my $scriptParameterHashRef = $_[0];

    my %cosmidResources;  #Hash to load cosmid info to

    if (-f ${$scriptParameterHashRef}{referencesDir}."/cosmid.yaml") {  #Cosmid.yaml file exists in reference directory
	
	## Loads a YAML file into an arbitrary hash and returns it.
	%cosmidResources = &LoadYAML({yamlFile => catfile(${$scriptParameterHashRef}{referencesDir}, "cosmid.yaml"),
				     });

	unless (defined($cosmidResources{directory})) {  #Set Directory entry if not defined
	    
	    $cosmidResources{directory} = catfile(${$scriptParameterHashRef}{referencesDir}, "resources");  #Set the Cosmid default directory
	}
    }
    else {  #No cosmid.yaml exist in reference directory
	
	$cosmidResources{directory} = catfile(${$scriptParameterHashRef}{referencesDir}, "resources");  #Set the Cosmid default directory
    }
    return $cosmidResources{directory};
}


sub AdjustNrCoresToSeqMode {

##AdjustNrCoresToSeqMode
    
##Function : Adjust the number of cores to be used in the analysis according to sequencing mode requirements.
##Returns  : ""
##Arguments: $nrCoresRef, $sequenceRunTypeRef
##         : $nrCoresRef         => The maximum number of cores to be use before printing "wait" statement {REF}
##         : $sequenceRunTypeRef => Type of sequencing [Paired-end|Single-end] {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $nrCoresRef = ${$argHashRef}{nrCoresRef};
    my $sequenceRunTypeRef = ${$argHashRef}{sequenceRunTypeRef};
    
    if ($$sequenceRunTypeRef eq "Paired-end") {  #Second read direction if present

	$$nrCoresRef =  $$nrCoresRef + 2;  #2 processes per file
    }
    else {  #Single-end

	$$nrCoresRef = $$nrCoresRef + 1;  #Only 1 file and one process
    }
}


sub PrintWait {

##PrintWait
    
##Function : Calculates when to prints "wait" statement and prints "wait" to supplied FILEHANDLE when adequate. 
##Returns  : Incremented $$coreCounterRef
##Arguments: $counterRef, $nrCoresRef, $coreCounterRef
##         : $counterRef     => The number of used cores {REF}
##         : $nrCoresRef     => The maximum number of cores to be use before printing "wait" statement {REF}
##         : $coreCounterRef => Scales the number of $nrCoresRef cores used after each print "wait" statement {REF}
##         : $FILEHANDLE     => FILEHANDLE to print "wait" statment to
    
    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $counterRef = ${$argHashRef}{counterRef};
    my $nrCoresRef = ${$argHashRef}{nrCoresRef};
    my $coreCounterRef = ${$argHashRef}{coreCounterRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    
    if ($$counterRef == $$coreCounterRef * $$nrCoresRef) {  #Using only nr of cores eq to lanes or maximumCores
	
	say $FILEHANDLE "wait", "\n";
	$$coreCounterRef=$$coreCounterRef+1;  #Increase the maximum number of cores allowed to be used since "wait" was just printed 
    }    
}


sub CheckBuildDownLoadPreRequisites {

##CheckBuildDownLoadPreRequisites
    
##Function : Checks if some of the active prerequisites needs to be downloaded and calls subroutine to download them if required
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $supportedCosmidReferenceHashRef, $programName
##         : $parameterHashRef                => The parameter hash {REF}
##         : $scriptParameterHashRef          => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef               => Info on samples and family hash {REF}
##         : $infilesLaneNoEndingHashRef      => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef                    => The jobID hash {REF}
##         : $supportedCosmidReferenceHashRef => The supported cosmid references hash {REF}
##         : $programName                     => Active program
##         : $familyIDRef                     => The familyIDRef {REF}

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $supportedCosmidReferenceHashRef = ${$argHashRef}{supportedCosmidReferenceHashRef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     programName => $programName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "CheckBuildDownLoadPreRequisites");

    for my $parameterName (keys %{$supportedCosmidReferenceHashRef}) {  #Supported cosmid references for MIP parameters
	
	if (defined(${$parameterHashRef}{$parameterName}{associatedProgram})) {  
	    
	    if (! &CheckEntryHashofArray({hashRef => ${$parameterHashRef}{$parameterName},
					  key => "associatedProgram",
					  element => "p".$programName,
					 })
		) {  #If the cosmid supported parameter is associated with the MIP program
		
		if ( (${$scriptParameterHashRef}{"p".$programName} == 1) && (${$scriptParameterHashRef}{dryRunAll} != 1) ) {  #Only enable autoDownload for active programs
		
		    if (${$parameterHashRef}{$parameterName}{buildFile} eq 1) {  #Enable autoBuild
			
			&BuildDownLoadablePreRequisites({parameterHashRef => $parameterHashRef,
							 scriptParameterHashRef => $scriptParameterHashRef,
							 sampleInfoHashRef => $sampleInfoHashRef,
							 infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
							 jobIDHashRef => $jobIDHashRef,
							 supportedCosmidReferenceHashRef => $supportedCosmidReferenceHashRef,
							 programName => $programName,
							});
			last;  #Perform once
		    }
		}
	    }
	}
    }
}


sub CheckSupportedFileEnding {

##CheckSupportedFileEnding    

##Function : Check that the supplied fileEnding is supported. Otherwise exits. 
##Returns  : ""
##Arguments: $fileNameRef, $fileEndingRef, $parameterNameRef
##         : $fileNameRef      => File name {REF}. 
##         : $fileEndingRef    => Supported file name ending {REF}
##         : $parameterNameRef => Parameter name {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $fileNameRef = ${$argHashRef}{fileNameRef};
    my $fileEndingRef = ${$argHashRef}{fileEndingRef};
    my $parameterNameRef = ${$argHashRef}{parameterNameRef};

    unless ( (defined($$fileNameRef)) && ($$fileNameRef =~/(\S+)$$fileEndingRef$/) ) {
	
	$logger->fatal("The supplied file: ".$$fileNameRef." for parameter '".$$parameterNameRef."' does not have the supported file ending '".$$fileEndingRef."'.", "\n");
	exit 1;
    }
}


sub PrintSupportedAnnovarTableNames {

##PrintSupportedAnnovarTableNames
    
##Function : Print the by MIP supported Annovar Table names to STDOUT and exists
##Returns  : ""
##Arguments: $scriptParameterHashRef, $annovarSupportedTableNames
##         : $scriptParameterHashRef     => The active parameters for this analysis
##         : $annovarSupportedTableNames => The supported Annovar tables
    
    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef;# = $_[0];
    my $annovarSupportedTableNamesArrayRef;# = $_[1];

    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	annovarSupportedTableNamesArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$annovarSupportedTableNamesArrayRef},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    if (${$scriptParameterHashRef}{logFile}) {

	$logger->info("These Annovar databases are supported by MIP:\n");

	foreach my $annovarSupportedTableName (@{$annovarSupportedTableNamesArrayRef}) {
	    
	    $logger->info($annovarSupportedTableName, "\n");
	}
    }
    else {

	say STDOUT "These Annovar databases are supported by MIP:";

	foreach my $annovarSupportedTableName (@{$annovarSupportedTableNamesArrayRef}) {
	    
	    say STDOUT $annovarSupportedTableName;
	}
    }
    exit;
}

sub CheckEntryHashofArray {

##CheckEntryHashofArray
    
##Function : Test element for being part of hash of array at supplied key. 
##Returns  : Return "1" if element is not part of array
##Arguments: $hashRef, $keyRef, $elementRef
##         : $hashRef => Hash {REF} 
##         : $key     => The key pointing to the array in the $hashRef
##         : $element => Element to look for in hash of array

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $hashRef = ${$argHashRef}{hashRef};
    my $key = ${$argHashRef}{key};
    my $element = ${$argHashRef}{element};

    my $tmpl = { 
	hashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$hashRef},
	key => { required => 1, defined => 1, strict_type => 1, store => \$key},
	element => { required => 1, defined => 1, strict_type => 1, store => \$element},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    if (defined($$hashRef{$key})) {  #Information on entry present

	if ( ! ( any {$_ eq $element} @{${$hashRef}{$key}} ) ) {  #If element is not part of array

	    return 1;
	}
    }
}


sub CheckMostCompleteAndRemoveFile {
    
##CheckMostCompleteAndRemoveFile
	
##Function  : Checks if the file is recorded as the "MostCompleteBAM|VCF". If false writes removal of file(s) to supplied filehandle
##Returns   : ""
##Arguments : $FILEHANDLE, $mostCompleteRef, $filePathRef, $fileEnding
##          : $FILEHANDLE      => SBATCH script FILEHANDLE to print to 
##          : $mostCompleteRef => The mostComplete file (BAM|VCF) {REF}
##          : $filePathRef         => Current file {REF}
##          : $fileEnding      => File ending of $filePathRef

    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $mostCompleteRef = ${$argHashRef}{mostCompleteRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $filePathRef = ${$argHashRef}{filePathRef};
    my $fileEnding = ${$argHashRef}{fileEnding};

    ## Mandatory arguments
    my %mandatoryArgument = (FILEHANDLE => $FILEHANDLE,
			     filePathRef => $$filePathRef,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "CheckMostCompleteAndRemoveFile");
    
    if ( (defined($$mostCompleteRef)) && (defined($$filePathRef)) ) {  #Not to disturb first dry_run of analysis
	
	unless ($$mostCompleteRef eq $$filePathRef) {  #Do not remove mostCompleteBAM|VCF
	    
	    ## Modify fileending of file to include e.g. .bai for bams
	    my $fileName = &ModifyFileEnding($filePathRef, $fileEnding);
	    
	    ##Print removal of file to sbatch script 
	    print $FILEHANDLE "rm ";
	    say $FILEHANDLE $fileName, "\n";  #Remove file(s)
	}
    }
    else {
	
	## Modify fileending of file to include e.g. .bai for bams
	my $fileName = &ModifyFileEnding($filePathRef, $fileEnding);
	
	##Print removal of file to sbatch script 
	print $FILEHANDLE "rm ";
	say $FILEHANDLE $fileName, "\n";  #Remove file(s)
    }
}


sub ModifyFileEnding {

##ModifyFileEnding
	
##Function  : Modify fileending of file to include e.g. .bai for bams
##Returns   : ""
##Arguments : $filePathRef, $fileEnding
##          : $filePathRef => Current file {REF}
##          : $fileEnding  => File ending of $filePathRef

    my $filePathRef = $_[0];
    my $fileEnding = $_[1];

    ## Removes ".fileEnding" in filename.FILENDING(.gz)
    my $fileName = &RemoveFileEnding({fileNameRef => $filePathRef,
				      fileEnding => $fileEnding,
				     });

    if (defined($fileName)) {  #Successfully removed file ending using &RemoveFileEnding
	
	my $end = ".*";  #Remove all files with ending with ".*"
	
	if ($fileEnding eq ".bam") {  #For BAM files 
	    
	    $end = ".ba*";  #Removes both .bam and .bai
	}
	if ($fileEnding eq ".vcf") {  #For VCF files
	    
	    $end = ".vcf*";  #Removes both .vcf and .vcf.idx
	}
	return $fileName.$end;
    }
    else {

	return $$filePathRef;
    }
}


sub ConcatenateVCFs {

##ConcatenateVCFs
    
##Function : Concatenate VCFs
##Returns  : ""
##Arguments: $scriptParameterHashRef, $FILEHANDLE, $arrayRef, $infilePrefix, $infilePostfix, $outfile, $reorderSwith
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $FILEHANDLE             => SBATCH script FILEHANDLE to print to
##         : $arrayRef               => Holding the number and part of file names to be combined
##         : $infilePrefix           => Will be combined with the each array element
##         : $infilePostfix          => Will be combined with the each array element
##         : $outfile                => The combined outfile
##         : $reorderSwith           => Reorder header
    
    my $scriptParameterHashRef = $_[0];
    my $FILEHANDLE = $_[1];
    my $arrayRef = $_[2];
    my $infilePrefix = $_[3];
    my $infilePostfix = $_[4];
    my $outfile = $_[5];
    my $reorderSwith = $_[6];
    
    unless (defined($infilePostfix)) {
	
	$infilePostfix = "";  #No postfix
    }
    unless (defined($outfile)) {
	
	$outfile = $infilePrefix.".vcf";  
    }

    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx4g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
	       javaJar => catfile(${$scriptParameterHashRef}{snpEffPath}, "SnpSift.jar"),
	      });
    
    print $FILEHANDLE "split -j ";  #Joinf VCFs together
    
    for (my $elementCounter=0;$elementCounter<scalar(@{$arrayRef});$elementCounter++) {
	
	print $FILEHANDLE $infilePrefix.${$arrayRef}[$elementCounter].$infilePostfix." ";  #files to combined
    }
    if ( (defined($_[6])) && $reorderSwith eq "reOrderHeader") {

	print $FILEHANDLE "| ";  #Pipe
	print $FILEHANDLE "perl ".catfile(${$scriptParameterHashRef}{inScriptDir}, "vcfParser.pl")." ";  #Parses the vcf output	
    }
    
    print $FILEHANDLE "> ".$outfile;  #OutFile
}


sub CombineVariants {

##CombineVariants
    
##Function : Writes sbatch code to supplied filehandle to combine variants in vcf format. Each array element is combined with the infilePre and Postfix.
##Returns  : ""
##Arguments: $scriptParameterHashRef, $FILEHANDLE, $arrayRef, $infilePrefix, $infilePostfix, $outfile
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $FILEHANDLE             => SBATCH script FILEHANDLE to print to
##         : $arrayRef               => Holding the number and part of file names to be combined
##         : $infilePrefix           => Will be combined with the each array element
##         : $infilePostfix          => Will be combined with the each array element
##         : $outfile                => The combined outfile

    my $scriptParameterHashRef = $_[0];
    my $FILEHANDLE = $_[1];
    my $arrayRef = $_[2];
    my $infilePrefix = $_[3];
    my $infilePostfix = $_[4];
    my $outfile = $_[5];
    
    unless (defined($infilePostfix)) {
	
	$infilePostfix = "";  #No postfix
    }
    unless (defined($outfile)) {
	
	$outfile = $infilePrefix.".vcf";  
    }
    say $FILEHANDLE "## GATK CombineVariants";

    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx4g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
	       javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
	      });

    print $FILEHANDLE "-T CombineVariants ";  #Type of analysis to run
    print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
    print $FILEHANDLE "-R ".catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
    
    for (my $elementCounter=0;$elementCounter<scalar(@{$arrayRef});$elementCounter++) {
	
	print $FILEHANDLE "-V: ".$infilePrefix.${$arrayRef}[$elementCounter].$infilePostfix." ";  #files to combined
    }
    print $FILEHANDLE "-genotypeMergeOptions UNSORTED ";  #Take the genotypes in any order. Should be fine since the same order and number of samples exists in all files

    say $FILEHANDLE "-o ".$outfile, "\n";  #OutFile
}


sub CombineGVCFs {

##CombineGVCFs
    
##Function : Writes sbatch code to supplied filehandle to combine variants in gvcf format. Each array element is combined with the infilePre and Postfix.
##Returns  : ""
##Arguments: $scriptParameterHashRef, $FILEHANDLE, $arrayRef, $infilePrefix, $infilePostfix, $outfile
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $FILEHANDLE             => SBATCH script FILEHANDLE to print to
##         : $arrayRef               => Holding the number and part of file names to be combined
##         : $infilePrefix           => Will be combined with the each array element
##         : $infilePostfix          => Will be combined with the each array element
##         : $outfile                => The combined outfile

    my $scriptParameterHashRef = $_[0];
    my $FILEHANDLE = $_[1];
    my $arrayRef = $_[2];
    my $infilePrefix = $_[3];
    my $infilePostfix = $_[4];
    my $outfile = $_[5];
    
    unless (defined($infilePostfix)) {
	
	$infilePostfix = "";  #No postfix
    }
    unless (defined($outfile)) {
	
	$outfile = $infilePrefix.".vcf";  
    }
    say $FILEHANDLE "## GATK CombineGVCFs";

    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx4g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
	       javaJar => catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar"),
	      });

    print $FILEHANDLE "-T CombineGVCFs ";  #Type of analysis to run
    print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
    print $FILEHANDLE "-R ".catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{humanGenomeReference})." ";  #Reference file
    
    for (my $elementCounter=0;$elementCounter<scalar(@{$arrayRef});$elementCounter++) {
	
	print $FILEHANDLE "-V: ".$infilePrefix.${$arrayRef}[$elementCounter].$infilePostfix." ";  #files to combined
    }
    say $FILEHANDLE "-o ".$outfile, "\n";  #OutFile
}


sub ConcatenateVariants {

##ConcatenateVariants
    
##Function : Writes sbatch code to supplied filehandle to concatenate variants in vcf format. Each array element is combined with the infilePre and Postfix.
##Returns  : ""
##Arguments: $scriptParameterHashRef, $FILEHANDLE, $arrayRef, $infilePrefix, $infilePostfix, $outfile
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $FILEHANDLE             => SBATCH script FILEHANDLE to print to
##         : $arrayRef               => Holding the number and part of file names to be combined
##         : $infilePrefix           => Will be combined with the each array element
##         : $infilePostfix          => Will be combined with the each array element
##         : $outfile                => The combined outfile

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $humanGenomeReferenceRef = ${$argHashRef}{humanGenomeReferenceRef} //= \${$argHashRef}{scriptParameterHashRef}{humanGenomeReference};

    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $arrayRef = ${$argHashRef}{arrayRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $infilePrefix = ${$argHashRef}{infilePrefix};
    my $infilePostfix = ${$argHashRef}{infilePostfix};
    my $outfile = ${$argHashRef}{outfile};
    
    ## Mandatory arguments
    my %mandatoryArgument = (scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     FILEHANDLE => $FILEHANDLE,
			     infilePrefix => $infilePrefix,
			     infilePostfix => $infilePostfix,
	);
    
    &CheckMandatoryArguments(\%mandatoryArgument, "ConcatenateVariants");
    
    unless (defined($infilePostfix)) {
	
	$infilePostfix = "";  #No postfix
    }
    unless (defined($outfile)) {
	
	$outfile = $infilePrefix.".vcf";  
    }
    
    say $FILEHANDLE "## GATK CatVariants";

    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx4g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory}
	      });

    print $FILEHANDLE "-cp ".catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar")." org.broadinstitute.gatk.tools.CatVariants ";  #Type of analysis to run
    print $FILEHANDLE "-l INFO ";  #Set the minimum level of logging
    print $FILEHANDLE "-R ".catfile($$referencesDirRef, $$humanGenomeReferenceRef)." ";  #Reference file
    print $FILEHANDLE "-assumeSorted ";  #assumeSorted should be true if the input files are already sorted

    for (my $elementCounter=0;$elementCounter<scalar(@{$arrayRef});$elementCounter++) {
	
	print $FILEHANDLE "-V: ".$infilePrefix.${$arrayRef}[$elementCounter].$infilePostfix." ";  #files to combined
    }
    say $FILEHANDLE "-out ".$outfile, "\n";  #OutFile
}


sub SortVcf {

##SortVcf
    
##Function : Writes sbatch code to supplied filehandle to sort variants in vcf format.
##Returns  : ""
##Arguments: $scriptParameterHashRef, $FILEHANDLE, $sequenceDictFile, $infile, $outfile
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $FILEHANDLE             => SBATCH script FILEHANDLE to print to
##         : $sequenceDictFile       => Human reference sequence dict file
##         : $infile                 => File to sort
##         : $outfile                => The sorted outfile

    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $arrayRef = ${$argHashRef}{arrayRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $sequenceDictFile = ${$argHashRef}{sequenceDictFile};
    my $infile = ${$argHashRef}{infile};
    my $outfile = ${$argHashRef}{outfile};
    
    ## Mandatory arguments
    my %mandatoryArgument = (scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     FILEHANDLE => $FILEHANDLE,
			     sequenceDictFile => $sequenceDictFile,
			     infile => $infile,
			     outfile => $outfile,
	);
    
    &CheckMandatoryArguments(\%mandatoryArgument, "SortVcf");
    
    say $FILEHANDLE "## Picard SortVcf";

    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx2g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
	       javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
	      });

    print $FILEHANDLE "SortVcf ";
    
    print $FILEHANDLE "INPUT=".$infile." ";  #File to sort
    print $FILEHANDLE "OUTPUT=".$outfile." ";  #OutFile
    say $FILEHANDLE "SEQUENCE_DICTIONARY=".$sequenceDictFile;
}


sub DetectSampleIdGender {

##DetectSampleIdGender
    
##Function : Detect gender of the current analysis
##Returns  : "$maleFound $femaleFound $otherFound"
##Arguments: $scriptParameterHashRef, $sampleInfoHashRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef      => Info on samples and family hash {REF}

    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $sampleInfoHashRef;

    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	sampleInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$sampleInfoHashRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $maleFound = 0;
    my $femaleFound = 0;
    my $otherFound = 0;

    foreach my $sampleID (@{${$scriptParameterHashRef}{sampleIDs}}) {

	if (${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{Sex} == 1) {  #Female
	    
	    $maleFound = 1;  #Male
	}
	if (${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$sampleID}{Sex} == 2) {  #Female

	    $femaleFound = 1;
	}
	else {  #Other

	    $maleFound = 1;  #Include since it might be male to enable analysis of Y.
	    $otherFound = 1;
	}
    }
    return $maleFound, $femaleFound, $otherFound;
}


sub RemovePedigreeElements {

##RemovePedigreeElements
    
##Function : Removes ALL keys at third level except keys in allowedEntries hash. 
##Returns  : ""
##Arguments: $hashRef
##         : $hashRef => Hash {REF}
    
    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $hashRef;
    
    my $tmpl = { 
	hashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$hashRef},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my %allowedEntries = (Capture_kit => "Capture_kit",
			  Sex => "Sex",
			  Mother => "Mother",
			  Father => "Father",
			  Phenotype => "Phenotype",
			  Clinical_db_gene_annotation => "Clinical_db_gene_annotation",
			  Sequence_type => "Sequence_type",
	);
    
    for my $familyID (keys %{$hashRef}) {

	for my $sampleID (keys %{ ${$hashRef}{$familyID} })  {

	    for my $pedigreeElements (keys %{ ${$hashRef}{$familyID}{$sampleID} })  {
		
		unless (exists($allowedEntries{$pedigreeElements})) {

		    delete(${$hashRef}{$familyID}{$sampleID}{$pedigreeElements});
		}
	    }
	}
    }
}


sub WriteUseLargePages {

##WriteUseLargePages
    
##Function : Write useLargePages java flag to sbatch script if enabled
##Returns  : ""
##Arguments: $FILEHANDLE, $arrayRef, $infilePrefix, $infilePostfix, $outfile
##         : $FILEHANDLE       => SBATCH script FILEHANDLE to print to
##         : $useLargePagesRef => UseLargePages for requiring large memory pages (cross-platform flag) {REF}
	
    my $FILEHANDLE = $_[0];
    my $useLargePagesRef = $_[1];
    
    if ($$useLargePagesRef) {
	
	print $FILEHANDLE "-XX:-UseLargePages ";  #UseLargePages for requiring large memory pages (cross-platform flag)
    }
}


sub CreateLog4perlCongfig {

##CreateLog4perlCongfig
    
##Function : Create log4perl config file. 
##Returns  : "$config"
##Arguments: $filePathRef
##         : $filePathRef => log4perl config file path {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $filePathRef;

    my $tmpl = { 
	filePathRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$filePathRef},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $config = q?
        log4perl.category.MIPLogger = TRACE, LogFile, ScreenApp
        log4perl.appender.LogFile = Log::Log4perl::Appender::File
        log4perl.appender.LogFile.filename = ?.$$filePathRef.q?
        log4perl.appender.LogFile.layout=PatternLayout
        log4perl.appender.LogFile.layout.ConversionPattern = [%p] %d %c - %m%n

        log4perl.appender.ScreenApp = Log::Log4perl::Appender::Screen
        log4perl.appender.ScreenApp.layout = PatternLayout
        log4perl.appender.ScreenApp.layout.ConversionPattern = [%p] %d %c - %m%n
        ?;
    return $config;
}


sub DeafultLog4perlFile {

##DeafultLog4perlFile
    
##Function : Set the default Log4perl file using supplied dynamic parameters.
##Returns  : "$LogFile"
##Arguments: $scriptParameterHashRef, $cmdInputRef, $scriptRef, $dateRef, $dateTimeStampRef, $familyIDRef, $outDataDirRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $cmdInputRef            => User supplied info on cmd for logFile option {REF}
##         : $scriptRef              => The script that is executed {REF}
##         : $dateRef                => The date {REF}
##         : $dateTimeStampRef       => The date and time {REF}
##         : $familyIDRef            => The familyID {REF}
##         : $outDataDirRef          => OutData directory {REF}
   
    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $outDataDirRef = ${$argHashRef}{outDataDirRef} //= \${$argHashRef}{scriptParameterHashRef}{outDataDir};

    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $cmdInputRef;
    my $scriptRef;
    my $dateRef;
    my $dateTimeStampRef;
    
    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	cmdInputRef => { default => \$$, strict_type => 1, store => \$cmdInputRef},
	scriptRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$scriptRef},
	dateRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$dateRef},
	dateTimeStampRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$dateTimeStampRef},
	familyIDRef => { default => \$$, strict_type => 1},
	outDataDirRef => { default => \$$, strict_type => 1, store => \$outDataDirRef},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    unless (defined($$cmdInputRef)) {  #No input from cmd i.e. do not create default logging directory or set default

	make_path(catfile($$outDataDirRef, $$familyIDRef, "mip_log", $$dateRef));
	my $LogFile = catfile($$outDataDirRef, $$familyIDRef, "mip_log", $$dateRef, $$scriptRef."_".$$dateTimeStampRef.".log");  #concatenates log filename	
	return $LogFile;
    }
}


sub CheckHumanGenomeFileEndings {

##CheckHumanGenomeFileEndings
    
##Function : Check the existance of associated Human genome files.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $fileInfoHashRef, $parameterNameRef, $humanGenomeReferenceNameNoEndingRef, $referencesDirRef,
##         : $parameterHashRef                    => The parameter hash {REF}
##         : $scriptParameterHashRef              => Holds all set parameter for analysis {REF}
##         : $fileInfoHashRef                     => The fileInfo hash {REF}
##         : $parameterNameRef                    => The parameter under evaluation {REF}                   
##         : $humanGenomeReferenceNameNoEndingRef => The associated human genome file without file ending {REF}
##         : $referencesDirRef                    => MIP reference directory {REF}

    my ($argHashRef) = @_;

    ## Default(s)
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $humanGenomeReferenceNameNoEndingRef = ${$argHashRef}{humanGenomeReferenceNameNoEndingRef} //= \${$argHashRef}{fileInfoHashRef}{humanGenomeReferenceNameNoEnding};

    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;
    my $fileInfoHashRef;
    my $parameterNameRef;

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	fileInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$fileInfoHashRef},
	parameterNameRef => { default => \$$, strict_type => 1, store => \$parameterNameRef},
	referencesDirRef => { default => \$$, strict_type => 1},
	humanGenomeReferenceNameNoEndingRef => { default => \$$, strict_type => 1},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];
    	       
    for (my $fileEndingsCounter=0;$fileEndingsCounter<scalar(@{${$fileInfoHashRef}{humanGenomeReferenceFileEndings}});$fileEndingsCounter++) {

	my $humanGenomeReferenceFileEnding = ${$fileInfoHashRef}{humanGenomeReferenceFileEndings}[$fileEndingsCounter];  #Alias
	
	## Enable autoBuild of metafiles 
	${$parameterHashRef}{$$parameterNameRef.$humanGenomeReferenceFileEnding}{buildFile} = "yesAutoBuild";
	
	my $path = catfile($$referencesDirRef, $$humanGenomeReferenceNameNoEndingRef.$humanGenomeReferenceFileEnding);
	my $completeParameterName = $$parameterNameRef.$humanGenomeReferenceFileEnding;

	&CheckExistance({parameterHashRef => $parameterHashRef,
			 scriptParameterHashRef => $scriptParameterHashRef,
			 itemNameRef => \$path,
			 parameterNameRef => \$completeParameterName,
			 itemTypeToCheck => "file",
			});
    }
    if (${$parameterHashRef}{$$parameterNameRef.".dict"}{buildFile} eq 0) {
	
	##Collect sequence contigs from human reference ".dict" file since it exists
	&CollectSeqContigs({contigsArrayRef => \@{${$fileInfoHashRef}{contigs}},
			    referencesDirRef => $referencesDirRef,
			    humanGenomeReferenceNameNoEndingRef => $humanGenomeReferenceNameNoEndingRef,
			   });
    }
}


sub CheckMergePicardToolsMergeSamFilesPrevious {
    
##CheckMergePicardToolsMergeSamFilesPrevious
    
##Function : Checks if previous alignments have been supplied for each sampleID. Saves merge info in fileInfo hash.
##Returns  : "" 
##Arguments: $scriptParameterHashRef, $fileInfoHashRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $fileInfoHashRef        => The fileInfo hash {REF}
    
    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $fileInfoHashRef;
    
    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	fileInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$fileInfoHashRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {  #Check all samples to check, which are to be merged with previous files later
	
	if (@{${$scriptParameterHashRef}{picardToolsMergeSamFilesPrevious}}) {  #Supplied info - check for which sampleID(s)  	
	    
	    for (my $mergeFileCounter=0;$mergeFileCounter<scalar(@{${$scriptParameterHashRef}{picardToolsMergeSamFilesPrevious}});$mergeFileCounter++) {
		
		if (${$scriptParameterHashRef}{picardToolsMergeSamFilesPrevious}[$mergeFileCounter] =~ /${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter]/) {  #Look for sampleID in previously generated file to be merged with current run to be able to merge correct files
		    
		    ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{ ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter] }{picardToolsMergeSamFilesPrevious} = 1;
		}
		else {
		    
		    ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{ ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter] }{picardToolsMergeSamFilesPrevious} = 0;
		}
	    }
	}
	else {  #Not supplied - Set to 0 
	    
	    ${$fileInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{ ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter] }{picardToolsMergeSamFilesPrevious} = 0;
	}
    }
}


sub CreateFamFile {

##CreateFamFile

##Function : Create .fam file to be used in variant calling analyses. Also checks if file already exists when using executionMode=sbatch.
##Returns  : "" 
##Arguments: $scriptParameterHashRef, $pedigreeFile, $executionMode, $famFilePath, $includeHeader, $FILEHANDLE
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $pedigreeFile           => The supplied pedigree file to create the reduced ".fam" file from
##         : $executionMode          => Either system (direct) or via sbatch
##         : $famFilePath            => The family file path
##         : $includeHeader          => Wether to include header ("1") or not ("0")
##         : $FILEHANDLE             => Filehandle to write to {Optional unless executionMode=sbatch}

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $pedigreeFile = ${$argHashRef}{pedigreeFile} //= ${$argHashRef}{scriptParameterHashRef}{pedigreeFile};
    my $executionMode;
    my $includeHeader;
    
    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $famFilePath;
    my $FILEHANDLE;

    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	famFilePath => { required => 1, defined => 1, strict_type => 1, store => \$famFilePath},
	FILEHANDLE => { store => \$FILEHANDLE},
	pedigreeFile => { strict_type => 1, store => \$pedigreeFile},
	executionMode => { default => "sbatch", allow => ["sbatch", "system"], strict_type => 1, store => \$executionMode},
	includeHeader => { default => 1, allow => [0, 1], strict_type => 1, store => \$includeHeader},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $pqFamFile;

    if ($includeHeader == 1) {
	
	$pqFamFile = q?perl -nae 'print $F[0], "\t", $F[1], "\t", $F[2], "\t", $F[3], "\t", $F[4], "\t", $F[5], "\n";' ?;
    }
    else {
	
	$pqFamFile = q?perl -nae 'unless ($_=~/^#/) { print $F[0], "\t", $F[1], "\t", $F[2], "\t", $F[3], "\t", $F[4], "\t", $F[5], "\n"; }' ?;
    }

    if ($executionMode eq "system") {  #Execute directly 

	`$pqFamFile $pedigreeFile > $famFilePath;`;
	$logger->info("Wrote: ".$famFilePath, "\n");
    }
    if ($executionMode eq "sbatch") {

	unless (-f $famFilePath) {  #Check to see if file already exists

	    if ($FILEHANDLE) {
	    
		my $FILEHANDLE = $FILEHANDLE;
		
		say $FILEHANDLE "#Generating '.fam' file for use with GATK ","\n";
		say $FILEHANDLE $pqFamFile.$pedigreeFile." > ".$famFilePath." ";
	    }
	    else {
		
		$logger->fatal("CreateFamFile[SubRoutine]:Using 'executionMode=sbatch' requires a filehandle to write to. Please supply filehandle to subroutine call.", "\n");
		exit 1;
	    }
	}
    }
}


sub CheckAnnovarTables {

##CheckAnnovarTables
    
##Function : Checks supported Annovar Tables and that the supplied supported ones exists 
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $annovarTableHashRef, $annovarSupportedTableNamesArrayRef
##         : $parameterHashRef                   => Holds all parameters
##         : $scriptParameterHashRef             => Holds all set parameter for analysis
##         : $annovarTableHashRef                => annovarTableHashRef {REF}
##         : $annovarSupportedTableNamesArrayRef => The supported annovar reference names array {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;
    my $annovarTableHashRef;
    my $annovarSupportedTableNamesArrayRef;
    
    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	annovarTableHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$annovarTableHashRef},
	annovarSupportedTableNamesArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$annovarSupportedTableNamesArrayRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $path;
    
    for (my $tableNamesCounter=0;$tableNamesCounter<scalar(@{${$scriptParameterHashRef}{annovarTableNames}});$tableNamesCounter++) {  #All AnnovarTables    
	
	if (defined(${$annovarTableHashRef}{${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter]})) {  #Supported Annovar database
	    
	    if (defined(${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{File})) {
		
		for (my $filesCounter=0;$filesCounter<scalar(@{${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{File}});$filesCounter++) {  #All annovarTable file(s), some tables have multiple files downloaded from the same call
		    
		    $path = catfile(${$scriptParameterHashRef}{annovarPath}, "humandb", ${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{File}[$filesCounter]);
		    &CheckExistance({parameterHashRef => $parameterHashRef,
				     scriptParameterHashRef => $scriptParameterHashRef,
				     itemNameRef => \$path,
				     parameterNameRef => \${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter],
				     itemTypeToCheck => "file",
				    });
		}
	    }
	    elsif (defined(${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{ucscAlias})){
		
		$path = catfile(${$scriptParameterHashRef}{annovarPath}, "humandb", ${$scriptParameterHashRef}{annovarGenomeBuildVersion}."_".${$annovarTableHashRef}{ ${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter] }{ucscAlias}.".txt");
		&CheckExistance({parameterHashRef => $parameterHashRef,
				 scriptParameterHashRef => $scriptParameterHashRef,
				 itemNameRef => \$path,
				 parameterNameRef => \${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter],
				 itemTypeToCheck => "file",
				});
	    }
	    else {
		
		$path = catfile(${$scriptParameterHashRef}{annovarPath}, "humandb", ${$scriptParameterHashRef}{annovarGenomeBuildVersion}."_".${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter].".txt");
		&CheckExistance({parameterHashRef => $parameterHashRef,
				 scriptParameterHashRef => $scriptParameterHashRef,
				 itemNameRef => \$path,
				 parameterNameRef => \${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter],
				 itemTypeToCheck => "file",
				});
	    }
	}
	else {  #Annovar Table not supported by MIP
	    
	    $logger->error("You supplied Annovar database: ".${$scriptParameterHashRef}{annovarTableNames}[$tableNamesCounter]." which is not supported by MIP. MIP can only process supported annovar databases\n");
	    &PrintSupportedAnnovarTableNames({scriptParameterHashRef => $scriptParameterHashRef,
					      annovarSupportedTableNamesArrayRef => $annovarSupportedTableNamesArrayRef,
					     });
	}
    }
}


sub CollectOutDataPathsEntries {
    
##CollectOutDataPathsEntries
    
##Function : Collects all programs outfile path(s) created by MIP as OutDirectory->value and outfile->value located in %sampleInfo.  
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $pathsArrayRef
##         : $parameterHashRef       => The parameter hash {REF}
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef      => Info on samples and family hash {REF}
##         : $pathsArrayRef          => Holds the collected paths {REF}
    
    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $pathsArrayRef = ${$argHashRef}{pathsArrayRef};
    
    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "CollectOutDataPathsEntries");

    for my $familyID ( keys %{$sampleInfoHashRef} ) {  #For every family id 
	
	for my $member ( keys %{ ${$sampleInfoHashRef}{$familyID} }) {  #For every familyID and sampleID
	    
	    if (${$sampleInfoHashRef}{$familyID}{$member}{Program}) {  #Only examine programs

		for my $program ( keys %{ ${$sampleInfoHashRef}{$familyID}{$member}{Program} } ) {  #For every programs           
		    
		    if ( (!defined(${$parameterHashRef}{"p".$program}{reduceIO})) || (${$parameterHashRef}{"p".$program}{reduceIO} ==  ${$scriptParameterHashRef}{reduceIO}) ) {  #Only include program that have the correct ReduceIO flag or no does not belog to a reduceIO block

			my @outDirectoryArray;  #Temporary array for collecting outDirectories within the same program
			my @outfileArray;  #Temporary array for collecting outfile within the same program
			
			for my $key ( keys %{ ${$sampleInfoHashRef}{$familyID}{$member}{Program}{$program} } ) { #For every key within program
			    
			    ## Check if KeyName is "OutDirectory" or "OutFile"  and adds to @pathsArrayRef if true.
			    &CollectOutFile({pathsArrayRef => $pathsArrayRef,
					     outDirectoryArrayRef => \@outDirectoryArray,
					     outfileArrayRef => \@outfileArray,
					     key => ${$sampleInfoHashRef}{$familyID}{$member}{Program}{$program}{$key},
					     keyName => $key,
					    });
			    
			    if (ref(${$sampleInfoHashRef}{$familyID}{$member}{Program}{$program}{$key}) eq "HASH" ) { #HASH reference indicating more levels
				
				for my $secondKey ( keys %{ ${$sampleInfoHashRef}{$familyID}{$member}{Program}{$program}{$key} } ) { #For every programs
				    
				    ## Check if KeyName is "OutDirectory" or "OutFile"  and adds to @pathsArrayRef if true.
				    &CollectOutFile({pathsArrayRef => $pathsArrayRef,
						     outDirectoryArrayRef => \@outDirectoryArray,
						     outfileArrayRef => \@outfileArray,
						     key => ${$sampleInfoHashRef}{$familyID}{$member}{Program}{$program}{$key}{$secondKey},
						     keyName => $secondKey,
						    });
				}
			    }
			}
		    }
		}
	    }
	}
    }
}


sub CollectOutFile {
    
##CollectOutFile
    
##Function  : Check if KeyName is "OutDirectory" or "OutFile"  and adds to @pathsArrayRef if true.
##Returns   : ""
##Arguments: $pathsArrayRef, $outDirectoryArrayRef, $outfileArrayRef
##         : $pathsArrayRef        => Holds the collected paths {REF}
##         : $outDirectoryArrayRef => Holds temporary outDirectory path(s) {REF}
##         : $outfileArrayRef      => Holds temporary outDirectory path(s) {REF}
##         : $key                  => The hash key
##         : $keyName              => The actual key  
    
    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $pathsArrayRef = ${$argHashRef}{pathsArrayRef};
    my $outDirectoryArrayRef = ${$argHashRef}{outDirectoryArrayRef};
    my $outfileArrayRef = ${$argHashRef}{outfileArrayRef};
    my $key = ${$argHashRef}{key};
    my $keyName = ${$argHashRef}{keyName};

    ## Mandatory arguments
    my %mandatoryArgument = (key => $key,
			     keyName => $keyName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "CollectOutFile");	
    
    if ($keyName eq "OutDirectory") {
	
	push(@{$outDirectoryArrayRef}, $key);
    }
    if ($keyName eq "OutFile") {
	
	push(@{$outfileArrayRef}, $key);
    }
    if (scalar(@{$outDirectoryArrayRef}) == 1 && (scalar(@{$outfileArrayRef}) == 1) ) {  #Both outDirectory and outfile have been collected, time to join
	
	push(@{$pathsArrayRef}, catfile(${$outDirectoryArrayRef}[0], ${$outfileArrayRef}[0]));
	@{$outDirectoryArrayRef} = ();  #Restart
	@{$outfileArrayRef} = ();  #Restart
    }
}


sub CollectPathEntries {
    
##CollectPathEntries
    
##Function  : Collects all programs outfile path(s) created by MIP as Path->value located in %sampleInfo.
##Returns   : ""
##Arguments: $sampleInfoHashRef, $pathsArrayRef
##         : $sampleInfoHashRef => Info on samples and family hash {REF}
##         : $pathsArrayRef     => Holds the collected paths {REF}
    
    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $pathsArrayRef = ${$argHashRef}{pathsArrayRef};
    
    for my $familyID ( keys %{$sampleInfoHashRef} ) {  #For every familyID 
	
	for my $member ( keys %{ ${$sampleInfoHashRef}{$familyID} }) {  #For every familyID and sampleID     
	    
	    for my $key ( keys %{ ${$sampleInfoHashRef}{$familyID}{$member} } ) {  #For every key within member
		
		## Check if KeyName is "Path" and adds to @pathsArrayRef if true.
		&CheckAndAddToArray({pathsArrayRef => $pathsArrayRef,
				     key => ${$sampleInfoHashRef}{$familyID}{$member}{$key},
				     keyName => $key,
				    });
		if (ref(${$sampleInfoHashRef}{$familyID}{$member}{$key}) eq "HASH" ) {   #HASH reference indicating more levels
		    
		    for my $secondKey ( keys %{ ${$sampleInfoHashRef}{$familyID}{$member}{$key} } ) { #For every secondkey with program
			
			## Check if KeyName is "Path" and adds to @pathsArrayRef if true.
			&CheckAndAddToArray({pathsArrayRef => $pathsArrayRef,
					     key => ${$sampleInfoHashRef}{$familyID}{$member}{$key}{$secondKey},
					     keyName => $secondKey,
					    });
		    
			if (ref(${$sampleInfoHashRef}{$familyID}{$member}{$key}{$secondKey}) eq "HASH" ) {   #HASH reference indicating more levels
		    
			    for my $thirdKey ( keys %{ ${$sampleInfoHashRef}{$familyID}{$member}{$key}{$secondKey} } ) { #For every thirdkey with program
				
				## Check if KeyName is "Path" and adds to @pathsArrayRef if true.
				&CheckAndAddToArray({pathsArrayRef => $pathsArrayRef,
						     key => ${$sampleInfoHashRef}{$familyID}{$member}{$key}{$secondKey}{$thirdKey},
						     keyName => $thirdKey,
						    });

				if (ref(${$sampleInfoHashRef}{$familyID}{$member}{$key}{$secondKey}{$thirdKey}) eq "HASH" ) {   #HASH reference indicating more levels
				    
				    for my $fourthKey ( keys %{ ${$sampleInfoHashRef}{$familyID}{$member}{$key}{$secondKey}{$thirdKey} } ) { #For every forthkey with program
					
					## Check if KeyName is "Path" and adds to @pathsArrayRef if true.
					&CheckAndAddToArray({pathsArrayRef => $pathsArrayRef,
							     key => ${$sampleInfoHashRef}{$familyID}{$member}{$key}{$secondKey}{$thirdKey}{$fourthKey},
							     keyName => $fourthKey,
							    });
				    }
				}
			    }
			}
		    }
		}
	    }
	}
    } 
}


sub CheckAndAddToArray {
    
##CheckAndAddToArray
    
##Function  : Check if KeyName is "Path" and adds to @pathsArrayRef if true.
##Returns   : ""
##Arguments: $pathsArrayRef, $key, $keyName
##         : $pathsArrayRef => Holds the collected paths {REF}
##         : $key           => The hash key
##         : $keyName       => The actual key
    
    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $pathsArrayRef = ${$argHashRef}{pathsArrayRef};
    my $key = ${$argHashRef}{key};
    my $keyName = ${$argHashRef}{keyName};

    ## Mandatory arguments
    my %mandatoryArgument = (keyName => $keyName,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "CheckAndAddToArray");
    
    if ($keyName eq "Path") {
	
	push(@{$pathsArrayRef}, $key);
    }
}



sub MigrateFilesToTemp {

##MigrateFilesToTemp
##Function : Copies files from source to temporary folder. Loop over files specified by $arrayRef and collects files from $extractArrayRef.
##Returns  : ""
##Arguments: $scriptParameterHashRef, $sampleInfoHashRef, $arrayRef, $extractArrayRef, $FILEHANDLE, $inSampleDirectory, $nrCores, $fileEnding, $sampleID, $familyIDRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF},my $scriptParameterHashRef = shift;
##         : $sampleInfoHashRef      => Info on samples and family hash {REF}
##         : $arrayRef               => The array of files to copy
##         : $extractArrayRef        => The array to extract files from
##         : $FILEHANDLE             => Filehandle to write to
##         : $inSampleDirectory      => The directory for the file to be copied
##         : $nrCores                => The number of cores that can be used
##         : $fileEnding             => File ending. Set to "" to not add any file ending or omit from call {Optional}
##         : $sampleID               => the sampleID {Optional}
##         : $familyIDRef            => The familyIDRef {REF}

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};

    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $arrayRef = ${$argHashRef}{arrayRef};
    my $extractArrayRef = ${$argHashRef}{extractArrayRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $inSampleDirectory = ${$argHashRef}{inSampleDirectory};
    my $nrCores = ${$argHashRef}{nrCores};
    my $fileEnding = ${$argHashRef}{fileEnding};
    my $sampleID = ${$argHashRef}{sampleID};

    my $pairedEndTracker = 0;
    my $coreCounter=1;
    
    say $FILEHANDLE "## Copying file(s) to temporary directory";
    for (my $fileCounter=0;$fileCounter<scalar( @{$arrayRef});$fileCounter++) { #For all files

	my $sequenceRunMode;

	if ( (defined($sampleInfoHashRef)) && (defined($sampleID)) ) {

	    $sequenceRunMode = ${$sampleInfoHashRef}{ $$familyIDRef }{ $sampleID }{File}{ ${$arrayRef}[$fileCounter] }{SequenceRunType}; #Collect paired-end or single-end sequence run mode
	}
	&PrintWait({counterRef => \$fileCounter,
		    nrCoresRef => \$nrCores,
		    coreCounterRef => \$coreCounter,
		    FILEHANDLE => $FILEHANDLE,
		   });

	## Copies file to temporary directory.
	&MigrateFileToTemp({FILEHANDLE => $FILEHANDLE,
			    path => catfile($inSampleDirectory, ${$extractArrayRef}[$pairedEndTracker]),
			    tempDirectory => $$tempDirectoryRef,
			    fileEnding => $fileEnding,
			   });
	if ( (defined($sequenceRunMode)) && ($sequenceRunMode eq "Paired-end") ) {

	    $pairedEndTracker = $pairedEndTracker+1; #Increment to collect correct read 2 from %infile
	    &MigrateFileToTemp({FILEHANDLE => $FILEHANDLE,
				path => catfile($inSampleDirectory, ${$extractArrayRef}[$pairedEndTracker]),
				tempDirectory => $$tempDirectoryRef,
				fileEnding => $fileEnding,
			       });
	}
	$pairedEndTracker++; #Increment to correctly track both single-end runs and paired-end runs
    }
    say $FILEHANDLE "wait", "\n";
}

sub RemoveFilesAtTemp {

##RemoveFilesAtTemp
    
##Function : Removes files from at temporary folder. Loop over files specified by $arrayRef and collects files from $extractArrayRef.
##Returns  : ""
##Arguments: $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $arrayRef, $extractArrayRef, $FILEHANDLE, $inSampleDirectory, $nrCores, $infileTag, $fileEnding, $sampleID, $familyIDRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF},my $scriptParameterHashRef = shift;
##         : $sampleInfoHashRef      => Info on samples and family hash {REF}
##         : $fileInfoHashRef        => The fileInfo hash {Optional, REF}
##         : $arrayRef               => The array of files to copy
##         : $extractArrayRef        => The array to extract files from
##         : $FILEHANDLE             => Filehandle to write t
##         : $inSampleDirectory      => The directory for the file to be removed
##         : $nrCores                => The number of cores that can be used
##         : $infileTag              => The infile ending 
##         : $fileEnding             => File ending. Set to "" to not add any file ending or omit from call
##         : $sampleID               => the sampleID {Optional}
##         : $familyIDRef            => The familyID {REF}

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};

    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $arrayRef = ${$argHashRef}{arrayRef};
    my $extractArrayRef = ${$argHashRef}{extractArrayRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $inSampleDirectory = ${$argHashRef}{inSampleDirectory};
    my $nrCores = ${$argHashRef}{nrCores};
    my $infileTag = ${$argHashRef}{infileTag};
    my $fileEnding = ${$argHashRef}{fileEnding};
    my $sampleID = ${$argHashRef}{sampleID};

    my $pairedEndTracker = 0;
    my $coreCounter=1;

    say $FILEHANDLE "## Removing file(s) at temporary directory";

    for (my $fileCounter=0;$fileCounter<scalar( @{$arrayRef});$fileCounter++) {  #For all files
	
	my $sequenceRunMode;

	if ( (defined($sampleInfoHashRef)) && (defined($sampleID)) ) {
	
	    $sequenceRunMode = ${$sampleInfoHashRef}{ $$familyIDRef }{ $sampleID }{File}{ ${$arrayRef}[$fileCounter] }{SequenceRunType};  #Collect paired-end or single-end sequence run mode
	}
	
	## Remove file(s) at temporary directory.
	if ($fileInfoHashRef) {  #Contigs

	    my $coreCounter=1;
	    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {

		my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];

		&PrintWait({counterRef => \$contigsCounter,
			    nrCoresRef => \$nrCores,
			    coreCounterRef => \$coreCounter,
			    FILEHANDLE => $FILEHANDLE,
			   });
		
		print $FILEHANDLE "rm ";  #Delete
		print $FILEHANDLE catfile($$tempDirectoryRef, ${$extractArrayRef}[$pairedEndTracker].$infileTag."_".$$contigRef.$fileEnding)." ";  #File
		say $FILEHANDLE "& ";
	    }
	}
	else {

	    &PrintWait({counterRef => \$fileCounter,
			nrCoresRef => \$nrCores,
			coreCounterRef => \$coreCounter,
			FILEHANDLE => $FILEHANDLE,
		       });

	    ## Remove file(s) at temporary directory.
	    print $FILEHANDLE "rm ";  #Delete
	    print $FILEHANDLE catfile($$tempDirectoryRef, ${$extractArrayRef}[$pairedEndTracker].$infileTag.$fileEnding)." ";  #File
	    say $FILEHANDLE "& ";
	    
	    if ( (defined($sequenceRunMode)) && ($sequenceRunMode eq "Paired-end") ) {
		
		$pairedEndTracker = $pairedEndTracker+1;  #Increment to collect correct read 2
		## Remove file(s) at temporary directory.
		print $FILEHANDLE "rm ";  #Delete
		print $FILEHANDLE catfile($$tempDirectoryRef, ${$extractArrayRef}[$pairedEndTracker].$infileTag.$fileEnding)." ";  #File
		say $FILEHANDLE "& ";
	    }
	    $pairedEndTracker++;  #Increment to correctly track both single-end runs and paired-end runs
	}
    }
    say $FILEHANDLE "wait", "\n";
}


sub MigrateFilesFromTemp {

##MigrateFilesFromTemp

##Function : Copies files from temporary folder to source. Loop over files specified by $arrayRef and collects files from $extractArrayRef.
##Returns  : ""
##Arguments: $arrayRef, $extractArrayRef, $outSampleDirectory, $tempDirectory, $nrCores, $scriptParameterHashRef, $sampleInfoHashRef, $sampleID, $FILEHANDLE
##         : $arrayRef           => The array of files to copy
##         : $extractArrayRef    => The array to extract files from
##         : $outSampleDirectory => The directory for the file to be copied
##         : $tempDirectory      => The node directory to copy to
##         : $fileEnding         => The fileending to use for the outfile
##         : $nrCores            => The number of cores that can be used
##         : $FILEHANDLE         => Filehandle to write to

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $arrayRef = ${$argHashRef}{arrayRef};
    my $extractArrayRef = ${$argHashRef}{extractArrayRef};
    my $outSampleDirectory = ${$argHashRef}{outSampleDirectory};
    my $tempDirectory = ${$argHashRef}{tempDirectory};
    my $nrCores = ${$argHashRef}{nrCores};
    my $fileEnding = ${$argHashRef}{fileEnding};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    my $coreCounter=1;

    say $FILEHANDLE "## Copying file(s) from temporary folder";
    for (my $fileCounter=0;$fileCounter<scalar( @{$arrayRef});$fileCounter++) { #For all files

	&PrintWait({counterRef => \$fileCounter,
		    nrCoresRef => \$nrCores,
		    coreCounterRef => \$coreCounter,
		    FILEHANDLE => $FILEHANDLE,
		   });
	
	## Copies file from temporary directory.
	&MigrateFileFromTemp({tempPath => catfile($tempDirectory, ${$extractArrayRef}[$fileCounter].$fileEnding),
			      filePath => $outSampleDirectory,
			      FILEHANDLE => $FILEHANDLE,
			     });
    }
    say $FILEHANDLE "wait", "\n";
}

sub MigrateFileToTemp {

##MigrateFileToTemp
    
##Function : Copies file to temporary directory.  
##Returns  : "$fileName"
##Arguments: $FILEHANDLE, $path, $tempDirectory, $fileEnding, $xargs, $xargsFileName, $elementCounter
##         : $FILEHANDLE     => Filehandle to write to
##         : $path           => The infile path
##         : $tempDirectory  => The node directory to copy to
##         : $fileEnding     => File ending {Optional}
##         : $xargs          => Use xargs if defined
##         : $xargsFileName  => xargs file name
##         : $elementCounter => The counts the elements that have been processed

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $path = ${$argHashRef}{path};
    my $tempDirectory = ${$argHashRef}{tempDirectory};
    my $fileEnding = ${$argHashRef}{fileEnding};
    my $xargs = ${$argHashRef}{xargs};
    my $xargsFileName = ${$argHashRef}{xargsFileName};
    my $elementCounter = ${$argHashRef}{elementCounter};

    ## Split relative path to file(s)
    my ($pathVolume, $pathDirectories, $pathFileName) = File::Spec->splitpath($path);

    if (defined($fileEnding)) {

	$path .= $fileEnding;  #Add fileEnding if supplied
    }

    unless (defined($xargs)) {

	print $FILEHANDLE "cp ";  #Copy
	print $FILEHANDLE "-p ";  #Preserve=mode,ownership,timestamps
    }

    print $FILEHANDLE $path." ";  #Infile
    print $FILEHANDLE $tempDirectory." ";  #Temp file

    if (defined($xargs)) {

	print $FILEHANDLE "2> ".$xargsFileName.".".$elementCounter.".stderr.txt ";
    }
    else {

	say $FILEHANDLE " & ";	
    }
    print $FILEHANDLE "\n";

    return $pathFileName; 
}


sub MigrateFileFromTemp {

##MigrateFileFromTemp
    
##Function : Copies file from temporary directory.  
##Returns  : ""
##Arguments: $tempPath, $filePath, $FILEHANDLE, $xargs, $xargsFileName, elementCounter
##         : $tempPath       => The node temp file path
##         : $filePath       => The node directory to copy to
##         : $FILEHANDLE     => Filehandle to write to
##         : $xargs          => Use xargs if defined
##         : $xargsFileName  => xargs file name
##         : $elementCounter => The counts the elements that have been processed

    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $tempPath = ${$argHashRef}{tempPath};
    my $filePath = ${$argHashRef}{filePath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $xargs = ${$argHashRef}{xargs};
    my $xargsFileName = ${$argHashRef}{xargsFileName};
    my $elementCounter = ${$argHashRef}{elementCounter};

    unless (defined($xargs)) {

	print $FILEHANDLE "cp ";  #Copy
	print $FILEHANDLE "-p ";  #Preserve=mode,ownership,timestamps
    }

    print $FILEHANDLE $tempPath." ";  #Infile
    print $FILEHANDLE $filePath." ";  #Local temp file

    if (defined($xargs)) {

	print $FILEHANDLE "2> ".$xargsFileName.".".$elementCounter.".stderr.txt ";
    }
    else {
	
	say $FILEHANDLE "& ";  
    }
    print $FILEHANDLE "\n";
}


sub RemoveDirectory {

##RemoveDirectory
    
##Function : Writes command to removes directory to filehandle.  
##Returns  : ""
##Arguments: $directoryRef, $FILEHANDLE
##         : $directoryRef => the directory to remove
##         : $FILEHANDLE   => Filehandle to write to

    my $tempDirectoryRef = $_[0];
    my $FILEHANDLE = $_[1];

    say $FILEHANDLE "## Remove directory";
    print $FILEHANDLE "rm ";  #Remove
    print $FILEHANDLE "-rf ";  #Directory
    say $FILEHANDLE $$tempDirectoryRef, "\n";  #Directory to remove
}


sub RemoveContigFileAtTempDirectory {

##RemoveContigFileAtTempDirectory
    
##Function : Removes files at temporary directory dictated by supplied array.
##Returns  : ""
##Arguments: $arrayRef, $FILEHANDLE, $nrCores, $fileName, $fileEnding, $tempDirectory
##         : $arrayRef       => Array to use for file iteration {REF}
##         : $FILEHANDLE     => Sbatch filehandle to write to
##         : $nrCores        => The number of cores to use
##         : $fileName       => File name without ending attached
##         : $fileEnding     => File ending
##         : $tempDirectory  => The temporary directory

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $arrayRef = ${$argHashRef}{arrayRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $nrCores = ${$argHashRef}{nrCores};
    my $fileName = ${$argHashRef}{fileName};
    my $fileEnding = ${$argHashRef}{fileEnding};
    my $tempDirectory = ${$argHashRef}{tempDirectory};
    
    my $coreCounter=1;
    
    ## Remove infile at temporary Directory
    say $FILEHANDLE "## Remove file at temporary Directory";
    
    for (my $elementCounter=0;$elementCounter<scalar(@{$arrayRef});$elementCounter++) {
    
	my $elementRef = \${$arrayRef}[$elementCounter];
	
	&PrintWait({counterRef => \$elementCounter,
		    nrCoresRef => \$nrCores,
		    coreCounterRef => \$coreCounter,
		    FILEHANDLE => $FILEHANDLE,
		   });
	
	print $FILEHANDLE "rm ";
	print $FILEHANDLE catfile($tempDirectory, $fileName."_".$$elementRef.$fileEnding)." ";  #File to be removed
	say $FILEHANDLE "& ";
    }
    say $FILEHANDLE "wait", "\n";
}


sub JavaCore {

##JavaCore
    
##Function : Writes java core commands to filehandle.  
##Returns  : ""
##Arguments: $FILEHANDLE, $memoryAllocation, $javaUseLargePagesRef, $javaTemporaryDirectory, $javaJar
##         : $FILEHANDLE             => Filehandle to write to
##         : $memoryAllocation       => Memory allocation for java 
##         : $javaUseLargePagesRef   => Use java large pages {REF}
##         : $javaTemporaryDirectory => Redirect tmp files to java temp {Optional}
##         : $javaJar                => The JAR

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $memoryAllocation = ${$argHashRef}{memoryAllocation};
    my $javaUseLargePagesRef = ${$argHashRef}{javaUseLargePagesRef};
    my $javaTemporaryDirectory = ${$argHashRef}{javaTemporaryDirectory};
    my $javaJar = ${$argHashRef}{javaJar};

    print $FILEHANDLE "java ";
    print $FILEHANDLE "-".$memoryAllocation." "; 
    
    &WriteUseLargePages($FILEHANDLE, $javaUseLargePagesRef);

    if (defined($javaTemporaryDirectory)) {

	print $FILEHANDLE "-Djava.io.tmpdir=".$javaTemporaryDirectory." ";  #Temporary Directory
    }
    if (defined($javaJar)) {
	
	print $FILEHANDLE "-jar ".$javaJar." ";
    }
}


sub CheckEmailAddress { 
    
##CheckEmailAddress
    
##Function : Check the syntax of the email adress is valid not that it is actually exists.  
##Returns  : ""
##Arguments: $emailRef
##         : $emailRef => The email adress
    
    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $emailRef;
    
    my $tmpl = { 
	emailRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$emailRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    $$emailRef =~ /[ |\t|\r|\n]*\"?([^\"]+\"?@[^ <>\t]+\.[^ <>\t][^ <>\t]+)[ |\t|\r|\n]*/;

    unless (defined($1)) {
	
	$logger->fatal("The supplied email: ".$$emailRef." seem to be malformed. ", "\n");
	exit 1;
    }
}


sub BreakString {

##BreakString
    
##Function : Breaks the string supplied on format key1:value1_value2,keyN:valueN_valueN,..n . Add key to %fileInfoHashRef and values as array. This enables association of values to key supplied in config or cmd.   
##Returns  : ""
##Arguments: $fileInfoHashRef, $parameterValueRef, $parameterName, $associatedProgram
##         : $fileInfoHashRef   => The fileInfo hash {REF}
##         : $parameterValueRef => MIP parameter value {REF}
##         : $parameterName     => MIP parameter name {REF}
##         : $associatedProgram => The parameters program {REF}

    my $fileInfoHashRef = $_[0];
    my $parameterValueRef = $_[1];
    my $parameterNameRef = $_[2];
    my $associatedProgramRef = $_[3];
    
    ## Break string into key value pairs
    my @fileKeys = split(',', join(',', $$parameterValueRef));

    foreach my $element (@fileKeys) {
	
	my @tempArray = split(/:/, $element);
	@{${$fileInfoHashRef}{$$associatedProgramRef}{$$parameterNameRef}{$tempArray[0]}} = split('_', $tempArray[1]);  #Save infoKey associated with fileName
    }
}


sub AddCaptureKit {

##AddCaptureKit
    
##Function : Return a capture kit depending on user info. If arg->{userSuppliedParameterswitchRef} is set, go a head and add capture kit no matter what the switch was.
##Returns  : "Set capture kit or ''"
##Arguments: $fileInfoHashRef, $supportedCaptureKitHashRef, $captureKit, $userSuppliedParameterswitch
##         : $fileInfoHashRef             => The file info hash {REF}
##         : $supportedCaptureKitHashRef  => The supported capture kits hash {REF}
##         : $captureKit                  => The capture kit to add
##         : $userSuppliedParameterswitch => Has user supplied parameter {OPTIONAL}
    
    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $fileInfoHashRef;# = ${$argHashRef}{fileInfoHashRef};
    my $supportedCaptureKitHashRef;# = ${$argHashRef}{supportedCaptureKitHashRef};
    my $captureKit;# = ${$argHashRef}{captureKit};
    my $userSuppliedParameterswitch;# = ${$argHashRef}{userSuppliedParameterswitch};

    my $tmpl = { 
	fileInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$fileInfoHashRef},
	supportedCaptureKitHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$supportedCaptureKitHashRef},
	captureKit => { strict_type => 1, store => \$captureKit},
	userSuppliedParameterswitch => { strict_type => 1, store => \$userSuppliedParameterswitch},	
    };

    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    unless (defined($userSuppliedParameterswitch)) {  #No detected supplied capture kit
	
	if ( defined(${$supportedCaptureKitHashRef}{ $captureKit }) ) {  #Supported capture kit alias
	    
	    return  ${$supportedCaptureKitHashRef}{ $captureKit };
	}
	else {  #Return unchanged capture_kit string
	    
	    return $captureKit;
	}
    }
    if ( (defined($userSuppliedParameterswitch)) && ($userSuppliedParameterswitch == 0) ) {  #Only add if user supplied no info on parameter
	
	if ( defined(${$supportedCaptureKitHashRef}{ $captureKit }) ) {  #Supported capture kit alias
	    
	    return  ${$supportedCaptureKitHashRef}{ $captureKit };
	} 
	else {  #Return unchanged capture_kit string
	    
	    return $captureKit;
	}                      
    }
}

sub GatherBamFiles {
    
##GatherBamFiles
    
##Function : Concatenates BAMs. Writes to sbatch FILEHANDLE
##Returns  : ""
##Arguments: $scriptParameterHashRef, $arrayRef, $FILEHANDLE, $infile, $createIndex
##         : $scriptParameterHashRef => Holds all set parameter for analysis
##         : $arrayRef               => The array of splits to gather
##         : $FILEHANDLE             => Filehandle to write to
##         : $infile                 => The infile
##         : $createIndex            => Create index

    my ($argHashRef) = @_;

    ## Default(s)
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $createIndex = ${$argHashRef}{createIndex} //= "TRUE";

    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $arrayRef = ${$argHashRef}{arrayRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $infile = ${$argHashRef}{infile};

    say $FILEHANDLE "## GatherBamFiles";
    
    ## Writes java core commands to filehandle.
    &JavaCore({FILEHANDLE => $FILEHANDLE,
	       memoryAllocation => "Xmx4g",
	       javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
	       javaTemporaryDirectory => $$tempDirectoryRef,
	       javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
	      });	
    
    print $FILEHANDLE "GatherBamFiles ";
    print $FILEHANDLE "CREATE_INDEX=".$createIndex." ";  #Create a BAM index when writing a coordinate-sorted BAM file.
    for (my $elementsCounter=0;$elementsCounter<scalar(@{$arrayRef});$elementsCounter++) {
	
	print $FILEHANDLE "INPUT=".catfile($$tempDirectoryRef, $infile."_".${$arrayRef}[$elementsCounter].".bam")." ";
    }
    say $FILEHANDLE "OUTPUT=".catfile($$tempDirectoryRef, $infile.".bam")." ";
}


sub XargsMigrateContigFiles {

##XargsMigrateContigFiles
    
##Function : Migrates file(s) to temporary directory using xargs.
##Returns  : "xargsFileCounter"
##Arguments: $arrayRef, $FILEHANDLE, $XARGSFILEHANDLE, $fileName, $programInfoPath, $nrCores, $firstCommand, $xargsFileCounter, $infile, $inDirectory, $tempDirectory, $fileEnding, $outfile, $outDirectory
##         : $arrayRef         => The fileInfo hash {REF}
##         : $FILEHANDLE       => Sbatch filehandle to write to
##         : $XARGSFILEHANDLE  => XARGS filehandle to write to 
##         : $fileName         => File name
##         : $programInfoPath  => The program info path
##         : $nrCores          => The number of cores to use
##         : $firstCommand     => The inital command 
##         : $xargsFileCounter => The xargs file counter
##         : $infile           => Infile name without ending attached
##         : $inDirectory      => In directory
##         : $tempDirectory    => The temporary directory
##         : $fileEnding       => File ending
##         : $outfile          => OutFile name without ending attached
##         : $outDirectory     => Out directory

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;
    my $nrCores = ${$argHashRef}{nrCores} //= 1;
    my $firstCommand = ${$argHashRef}{firstCommand} //= "cp -p";
    my $fileEnding = ${$argHashRef}{fileEnding} //= ".vcf*";

    ## Flatten argument(s)
    my $arrayRef = ${$argHashRef}{arrayRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $XARGSFILEHANDLE = ${$argHashRef}{XARGSFILEHANDLE};
    my $fileName = ${$argHashRef}{fileName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $infile = ${$argHashRef}{infile};
    my $inDirectory = ${$argHashRef}{inDirectory};
    my $tempDirectory = ${$argHashRef}{tempDirectory};
    my $outfile = ${$argHashRef}{outfile};
    my $outDirectory = ${$argHashRef}{outDirectory};

    my $xargsFileName;

    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 xargsFileCounter => $xargsFileCounter,
							 firstCommand => $firstCommand,
							});
    
    for (my $elementCounter=0;$elementCounter<scalar(@{$arrayRef});$elementCounter++) {
	
	my $elementRef = \${$arrayRef}[$elementCounter];  #Alias
	
	if (defined($infile)) {

	    ## Copy file(s) to temporary directory.
	    &MigrateFileToTemp({FILEHANDLE => $XARGSFILEHANDLE, 
				path => catfile($inDirectory, $infile."_".$$elementRef.$fileEnding),
				tempDirectory => $tempDirectory,
				xargs => "xargs",
				xargsFileName => $xargsFileName,
				elementCounter => $$elementRef,
			       });
	}
	if ( (defined($outfile)) && (defined($outDirectory)) ) {
	    
	    ## Copy file(s) from temporary directory.
	    &MigrateFileFromTemp({tempPath => catfile($tempDirectory, $outfile."_".$$elementRef.$fileEnding),
				  filePath => $outDirectory,
				  FILEHANDLE => $XARGSFILEHANDLE,
				  xargs => "xargs",
				  xargsFileName => $xargsFileName,
				  elementCounter => $$elementRef,
				 });
	}
    }
    return $xargsFileCounter;
}


sub XargsCommand {

##XargsCommand
    
##Function : Creates the command line for xargs. Writes to sbatch FILEHANDLE and opens xargs FILEHANDLE
##Returns  : "xargsFileCounter + 1, $xargsFileName"
##Arguments: $FILEHANDLE, $XARGSFILEHANDLE, $fileName, $programInfoPath, $nrCores, $firstCommand, $xargsFileCounter, $memoryAllocation, $javaUseLargePagesRef, $javaTemporaryDirectory, $javaJar
##         : $FILEHANDLE             => Sbatch filehandle to write to
##         : $XARGSFILEHANDLE        => XARGS filehandle to write to 
##         : $fileName               => File name
##         : $programInfoPath        => The program info path
##         : $nrCores                => The number of cores to use
##         : $firstCommand           => The inital command 
##         : $xargsFileCounter       => The xargs file counter
##         : $memoryAllocation       => Memory allocation for java
##         : $javaUseLargePagesRef   => Use java large pages {REF}
##         : $javaTemporaryDirectory => Redirect tmp files to java temp {Optional}
##         : $javaJar                => The JAR

    my ($argHashRef) = @_;

    ## Default(s)
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;

    ## Flatten argument(s)
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $XARGSFILEHANDLE = ${$argHashRef}{XARGSFILEHANDLE};
    my $fileName = ${$argHashRef}{fileName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $nrCores = ${$argHashRef}{nrCores};
    my $firstCommand = ${$argHashRef}{firstCommand};
    my $memoryAllocation = ${$argHashRef}{memoryAllocation};
    my $javaUseLargePagesRef = ${$argHashRef}{javaUseLargePagesRef};
    my $javaTemporaryDirectory = ${$argHashRef}{javaTemporaryDirectory};
    my $javaJar = ${$argHashRef}{javaJar};

    my $xargsFileName;

    ##Check if there is a xargsFileName to concatenate
    if (defined($programInfoPath)) {

	$xargsFileName = $programInfoPath.".".$xargsFileCounter;
    }

    print $FILEHANDLE "cat ".$fileName.".".$xargsFileCounter.".xargs ";  #Read xargs command file
    print $FILEHANDLE "| ";  #Pipe
    print $FILEHANDLE "xargs ";
    print $FILEHANDLE "-i ";  #replace-str; Enables us to tell xargs where to put the command file lines
    print $FILEHANDLE "--verbose ";  #Print the command line on the standard error output before executing it
    print $FILEHANDLE "-n1 ";  #Use at most max-args arguments per command line
    print $FILEHANDLE q?-P?.$nrCores.q? ?;  #Run up to max-procs processes at a time
    print $FILEHANDLE q?sh -c "?;  #The string following this command will be interpreted as a shell command

    if ( $firstCommand eq "java") {

	print $FILEHANDLE "java ";
	print $FILEHANDLE "-".$memoryAllocation." ";

	&WriteUseLargePages($FILEHANDLE, $javaUseLargePagesRef);

	if (defined($javaTemporaryDirectory)) {

	    print $FILEHANDLE "-Djava.io.tmpdir=".$javaTemporaryDirectory." "; #Temporary Directory
	}
	if (defined($javaJar)) {

	    print $FILEHANDLE "-jar ".$javaJar." ";
	}
    }
    else {

	print $FILEHANDLE $firstCommand." ";
    }
    say $FILEHANDLE q? {} "?, "\n";  #Set placeholder
    open ($XARGSFILEHANDLE, ">",$fileName.".".$xargsFileCounter.".xargs") or $logger->logdie("Can't write to '".$fileName.".".$xargsFileCounter.".xargs"."' :".$!."\n\n");  #Open XARGSFILEHANDLE 
    return ( ($xargsFileCounter + 1), $xargsFileName);  #Increment to not overwrite xargs file with next call (if used) and xargsFileName stub
}


sub SplitBAM {

##SplitBAM
    
##Function : Split BAM file per contig and index new BAM. Creates the command line for xargs. Writes to sbatch FILEHANDLE and opens xargs FILEHANDLE
##Returns  : ""
##Arguments: $FILEHANDLE, $XARGSFILEHANDLE, $contigs, $xargsFileCounter, $fileName, $programInfoPath, $nrCores, $firstCommand, $infile, $tempDirectoryRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $FILEHANDLE             => Sbatch filehandle to write to
##         : $XARGSFILEHANDLE        => XARGS filehandle to write to
##         : $xargsFileCounter       => The xargs file counter
##         : $memoryAllocation       => Memory allocation for ja
##         : $contigs                => The contigs to process
##         : $fileName               => File name - ususally sbatch
##         : $programInfoPath        => The program info path
##         : $nrCores                => The number of cores to use
##         : $firstCommand           => The inital command
##         : $infile                 => The infile
##         : $tempDirectoryRef       => The temporary directory

    my ($argHashRef) = @_;

    ## Default(s)
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;
    my $firstCommand = ${$argHashRef}{firstCommand} //= "samtools";

    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $XARGSFILEHANDLE = ${$argHashRef}{XARGSFILEHANDLE};
    my $contigs = ${$argHashRef}{contigs};
    my $fileName = ${$argHashRef}{fileName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $nrCores = ${$argHashRef}{nrCores};    
    my $infile = ${$argHashRef}{infile};
    
    my $xargsFileName;

    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 firstCommand => $firstCommand,
							 xargsFileCounter => $xargsFileCounter,
							});
    
    ## Split by contig
    for (my $contigsCounter=0;$contigsCounter<scalar(@{$contigs});$contigsCounter++) {
	
	my $contigRef = \${$contigs}[$contigsCounter];

	print $XARGSFILEHANDLE "view ";
	print $XARGSFILEHANDLE "-h "; #Include header
	print $XARGSFILEHANDLE "-b ";  #BAM output
	print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $infile.".bam")." ";  #InFile
	print $XARGSFILEHANDLE $$contigRef." ";
	print $XARGSFILEHANDLE "> ".catfile($$tempDirectoryRef, $infile."_".$$contigRef.".bam")." ";  #Write to file
	print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	print $XARGSFILEHANDLE "; ";  #Wait

	## Writes java core commands to filehandle.
	&JavaCore({FILEHANDLE => $XARGSFILEHANDLE,
		   memoryAllocation => "Xmx4g",
		   javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		   javaTemporaryDirectory => $$tempDirectoryRef,
		   javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
		  }); 

	print $XARGSFILEHANDLE "BuildBamIndex ";
	print $XARGSFILEHANDLE "INPUT=".catfile($$tempDirectoryRef, $infile."_".$$contigRef.".bam")." ";  #InFile
	say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
    }
    return $xargsFileCounter; 
}


sub SplitBAMSambamba {

##SplitBAMSambamba
    
##Function : Split BAM file per contig and index new BAM. Creates the command line for xargs. Writes to sbatch FILEHANDLE and opens xargs FILEHANDLE
##Returns  : ""
##Arguments: $FILEHANDLE, $XARGSFILEHANDLE, $contigs, $xargsFileCounter, $fileName, $programInfoPath, $nrCores, $firstCommand, $infile, $tempDirectoryRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $FILEHANDLE             => Sbatch filehandle to write to
##         : $XARGSFILEHANDLE        => XARGS filehandle to write to
##         : $xargsFileCounter       => The xargs file counter
##         : $memoryAllocation       => Memory allocation for ja
##         : $contigs                => The contigs to process
##         : $fileName               => File name - ususally sbatch
##         : $programInfoPath        => The program info path
##         : $nrCores                => The number of cores to use
##         : $firstCommand           => The inital command
##         : $infile                 => The infile
##         : $tempDirectoryRef     => The temporary directory

    my ($argHashRef) = @_;

    ## Default(s)
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $xargsFileCounter = ${$argHashRef}{xargsFileCounter} //= 0;
    my $firstCommand = ${$argHashRef}{firstCommand} //= "sambamba ";
    
    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $XARGSFILEHANDLE = ${$argHashRef}{XARGSFILEHANDLE};
    my $contigs = ${$argHashRef}{contigs};
    my $fileName = ${$argHashRef}{fileName};
    my $programInfoPath = ${$argHashRef}{programInfoPath};
    my $nrCores = ${$argHashRef}{nrCores};
    my $infile = ${$argHashRef}{infile};

    my $xargsFileName;

    ## Create file commands for xargs
    ($xargsFileCounter, $xargsFileName) = &XargsCommand({FILEHANDLE => $FILEHANDLE,
							 XARGSFILEHANDLE => $XARGSFILEHANDLE, 
							 fileName => $fileName,
							 programInfoPath => $programInfoPath,
							 nrCores => $nrCores,
							 firstCommand => $firstCommand,
							 xargsFileCounter => $xargsFileCounter,
							});
    
    ## Split by contig
    for (my $contigsCounter=0;$contigsCounter<scalar(@{$contigs});$contigsCounter++) {
	
	my $contigRef = \${$contigs}[$contigsCounter];

	print $XARGSFILEHANDLE "view ";  #Command
	print $XARGSFILEHANDLE "-h ";  #Include header
	print $XARGSFILEHANDLE "--format bam ";  #BAM output
	print $XARGSFILEHANDLE "--show-progress ";  #Show progress bar in STDERR
	print $XARGSFILEHANDLE "--output-filename=".catfile($$tempDirectoryRef, $infile."_".$$contigRef.".bam")." ";  #Write to file
	print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $infile.".bam")." ";  #InFile
	print $XARGSFILEHANDLE $$contigRef." ";
	print $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	print $XARGSFILEHANDLE "; ";  #Wait

	## Index
	print $XARGSFILEHANDLE $firstCommand." ";  #Program
	print $XARGSFILEHANDLE "index ";  #Command
	print $XARGSFILEHANDLE "--show-progress ";  #Show progress bar in STDERR
	print $XARGSFILEHANDLE catfile($$tempDirectoryRef, $infile."_".$$contigRef.".bam")." ";  #InFile
	say $XARGSFILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
    }
    return $xargsFileCounter; 
}


sub FindMaxSeqLengthForSampleID {

##FindMaxSeqLengthForSampleID
    
##Function : Finds the maximum sequence length of the reads for all sequencing file(s).   
##Returns  : $maxSequenceLength
##Arguments: $scriptParameterHashRef, $sampleInfoHashRef, $infilesLaneNoEndingHashRef, $sampleIDRef 
##         : $scriptParameterHashRef            => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef                 => Info on samples and family hash {REF}
##         : $infilesLaneNoEndingHashRef        => The infile(s) without the ".ending" {REF}
##         : $sampleIDRef                       => The sampleID {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};

    my $maxSequenceLength = 0;

    for (my $infileCounter=0;$infileCounter<scalar( @{ ${$infilesLaneNoEndingHashRef}{$$sampleIDRef} });$infileCounter++) {  #For all infiles per lane
	
	my $seqLength = ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} }{$$sampleIDRef}{File}{${$infilesLaneNoEndingHashRef}{$$sampleIDRef}[$infileCounter]}{SequenceLength};

	if ($seqLength > $maxSequenceLength) {

	    $maxSequenceLength = $seqLength;
	}
    }
    return $maxSequenceLength;
}

sub SetContigs {

##SetContigs

##Function : Set contig prefix and contig names depending on reference used. Exclude mitochondrial contig if analysisType is "exomes".  
##Returns  : ""
##Arguments: $scriptParameterHashRef, $fileInfoHashRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $fileInfoHashRef        => The file info hash {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $fileInfoHashRef;
    
    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	fileInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$fileInfoHashRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    if (${$scriptParameterHashRef}{humanGenomeReference}=~/hg\d+/) {  #Refseq - prefix and M
	
	@{${$fileInfoHashRef}{contigs}} = ("chr1", "chr2", "chr3", "chr4", "chr5", "chr6", "chr7", "chr8", "chr9", "chr10", "chr11", "chr12", "chr13", "chr14", "chr15", "chr16", "chr17", "chr18", "chr19", "chr20", "chr21", "chr22", "chrX", "chrY", "chrM");  #Chr for filtering of bam file

	@{${$fileInfoHashRef}{contigsSizeOrdered}} = ("chr1", "chr2", "chr3", "chr4", "chr5", "chr6", "chr7", "chrX", "chr8", "chr9", "chr10", "chr11", "chr12", "chr13", "chr14", "chr15", "chr16", "chr17", "chr18", "chr19", "chr20", "chr21", "chr22", "chrY", "chrM");  #Chr for filtering of bam file
    }
    elsif (${$scriptParameterHashRef}{humanGenomeReference}=~/GRCh\d+/) {  #Ensembl - no prefix and MT
	
	@{${$fileInfoHashRef}{contigs}} = ("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "X", "Y", "MT");  #Chr for filtering of bam file

	@{${$fileInfoHashRef}{contigsSizeOrdered}} = ("1", "2", "3", "4", "5", "6", "7", "X", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "Y", "MT");  #Chr for filtering of bam file
    }
    if (${$scriptParameterHashRef}{analysisType} eq "exomes") {

	pop(@{${$fileInfoHashRef}{contigs}});  #Remove Mitochondrial contig
	pop(@{${$fileInfoHashRef}{contigsSizeOrdered}});  #Remove Mitochondrial contig
    }
}


sub ClearTrap {

##ClearTrap

##Function : Clear trap for signal(s), e.g. in exome analysis since the might be no variants in MT or Y contigs. This will cause premature exit from sbatch
##Returns  : ""
##Arguments: $trapSignalsRef, $FILEHANDLE, $analysisType
##         : $trapSignalsRef => Array with signals to clear trap for {REF}
##         : $FILEHANDLE     => The FILEHANDLE to write to

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $trapSignalsRef = ${$argHashRef}{trapSignalsRef} //= ["ERR"];
    
    ## Flatten argument(s)
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
 
    ## Mandatory arguments
    my %mandatoryArgument = (FILEHANDLE => $FILEHANDLE,
	);
    
    &CheckMandatoryArguments(\%mandatoryArgument, "ClearTrap");

    ## Clear trap for signal ERR
    say $FILEHANDLE "## Clear trap for signal(s) ".join(" ", @{$trapSignalsRef});
    say $FILEHANDLE "trap - ".join(" ", @{$trapSignalsRef});
    say $FILEHANDLE "trap", "\n";
}


sub EnableTrap {

##EnableTrap

##Function : Enable trap for signal(s).  
##Returns  : ""
##Arguments: $trapSignalsRef, $trapFunction, $FILEHANDLE, $analysisType
##         : $trapSignalsRef => Array with signals to clear trap for {REF}
##         : $trapFunction   => The trap function argument
##         : $FILEHANDLE     => The FILEHANDLE to write to
    
    my ($argHashRef) = @_;
    
    ## Default(s)
    my $trapSignalsRef = ${$argHashRef}{trapSignalsRef} //= ["ERR"];
    my $trapFunction = ${$argHashRef}{trapFunction} //= "error",
    
    ## Flatten argument(s)
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
 
    ## Mandatory arguments
    my %mandatoryArgument = (FILEHANDLE => $FILEHANDLE,
	);
    
    &CheckMandatoryArguments(\%mandatoryArgument, "EnableTrap");

    say $FILEHANDLE "## Enable cleared trap for signal(s) ".join(" ", @{$trapSignalsRef})." again";
    say $FILEHANDLE "trap ".$trapFunction." ".join(" ", @{$trapSignalsRef}), "\n";
}


sub CollectSubDatabases {

##CollectSubDatabases

##Function : Collect databases(s) from a database file and adds them to sampleInfo 
##Returns  : ""
##Arguments: $sampleInfoHashRef, $familyIDRef, $programNameRef, $databaseFile, $databaseKey
##         : $sampleInfoHashRef => Info on samples and family hash {REF}
##         : $familyIDRef       => The family ID {REF}
##         : $programNameRef    => The program name {REF}
##         : $databaseFile      => The database file
##         : $databaseKey       => The database key i.e. select or range

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $familyIDRef = ${$argHashRef}{familyIDRef};
    my $programNameRef = ${$argHashRef}{programNameRef};
    my $databaseFile = ${$argHashRef}{databaseFile};
    my $databaseKey = ${$argHashRef}{databaseKey};
    
    my %memberDatabase;  #Collect each member database features
    my %header = ("Database=<ID" => "FileName",
		  Version => "Version",
		  Acronym => "Acronym",
		  Clinical_db_genome_build => "GenomeBuild",
		  Date => "Date",
		  'Complete_name' => "CompleteName",
	);

    my $subDatabaseRegExp = q?perl -nae 'if ($_=~/^##Database=<ID=/) {chomp($_);my @entries=split(/,/, $_); my $entry = join(",", $_); print $entry.":" } if($_=~/^#\w/) {last;}'?;
    my $ret = `$subDatabaseRegExp $databaseFile`;  #Collect databases(s) from selectFile header
    my @databases = split(/:/, $ret);  #Split each member database into array element

    foreach my $line (@databases) {

	my @features = split(/,/, $line);  #Split each memember database line into features

	foreach my $featureElement (@features) {

	    foreach my $databaseFileHeader (keys %header) {  #Parse the features using defined header keys

		if ($featureElement=~/^##$databaseFileHeader=(\S+)/) {  #Special case to resolve that "=" occurs to times within featureElement

		    $memberDatabase{ $header{$databaseFileHeader} } = $1;
		    last;
		}
		elsif ($featureElement=~/$databaseFileHeader=/) {
		    
		    my @tempArray = split("=", $featureElement);
		    $memberDatabase{ $header{$databaseFileHeader} } = $tempArray[1];  #Value
		    last;
		}
	    }
	}

	if ( (defined($memberDatabase{FileName})) && (defined($memberDatabase{Acronym})) ) {
	    
	    my $databaseName = $memberDatabase{FileName}."_".$memberDatabase{Acronym};  #Create unique member database ID
	
	    ## Add new entries
	    foreach my $feature (keys %memberDatabase) {

		if ($feature eq "Date") {

		    my $parsedDate = Time::Piece->strptime($memberDatabase{$feature}, "%Y%m%d");
		    $memberDatabase{$feature} = $parsedDate->ymd;
		}
		${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$$programNameRef}{$databaseKey}{Database}{$databaseName}{$feature} = $memberDatabase{$feature};
	    }
	}
	else {

	    $logger->warn("Unable to write ".$databaseKey." database to qc_sampleInfo. Lacking ##Database=<ID=[?] or Acronym=[?] in database header."."\n");
	}
	%memberDatabase = ();  #Reset hash for next line
    }
}


sub AddMostCompleteVCF {

##AddMostCompleteVCF

##Function : Adds the most complete vcf file to sampleInfo
##Returns  : ""
##Arguments: $scriptParameterHashRef, $sampleInfoHashRef, $familyIDRef, $path, $programName, $vcfParserOutputFileCounter
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $familyIDRef                => The family ID {REF}
##         : $path                       => Path to file
##         : $programName                => Program name
##         : $vcfParserOutputFileCounter => Number of outfile files from in vcfParser (select, range)

    my ($argHashRef) = @_;
    
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $vcfParserOutputFileCounter = ${$argHashRef}{vcfParserOutputFileCounter} //= 0;
    
    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $path = ${$argHashRef}{path};
    my $programName = ${$argHashRef}{programName};

    if ( (${$scriptParameterHashRef}{ "p".$programName } == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	
	if ($vcfParserOutputFileCounter == 1) {
	    
	    ${$sampleInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{VCFFile}{Clinical}{Path} = $path;
	}
	else {
	    
	    ${$sampleInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{VCFFile}{Research}{Path} = $path;
	}
    }
}


sub CheckCommandinPath {

##CheckCommandinPath

##Function : Checking commands in your path and executable
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef
##         : $parameterHashRef       => The parameter hash {REF}
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my %seen;  #Track program paths that have already been checked

    foreach my $parameterName (keys %{$scriptParameterHashRef}) {

	if ( (exists(${$parameterHashRef}{$parameterName}{type})) && (${$parameterHashRef}{$parameterName}{type} eq "program")) {

	    my $programNamePathsArrayRef = \@{ $parameter{$parameterName}{programNamePath} };  #Alias

	    if ( (@{$programNamePathsArrayRef}) && (${$scriptParameterHashRef}{$parameterName} > 0) ) {  #Only check path(s) for active programs

		foreach my $program (@{ $programNamePathsArrayRef }) {
		  
		    unless($seen{$program}) { 

			if(can_run($program)) {  #IPC::Cmd
			    
			    $logger->info("ProgramCheck: ".$program." installed\n");
			    $seen{$program} = 1;
			}
			else {
			    
			    $logger->fatal("Could not detect ".$program." in your Path\n");
			    exit 1;
			}
		    }
		}
	    }
	}
    }
}


sub UpdateSampleInfoHash {
    
##UpdateSampleInfoHash
    
##Function : Update sampleInfo with information from pedigree
##Returns  : ""
##Arguments: $sampleInfoHashRef, $tempHashRef, $familyIDRef
##         : $tempHashRef       => Allowed parameters from pedigre file hash {REF}
##         : $sampleInfoHashRef => Info on samples and family hash {REF}
##         : $familyIDRef       => The family ID {REF}
    
    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $sampleInfoHashRef;
    my $tempHashRef;
    my $familyIDRef;

    my $tmpl = { 
	sampleInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$sampleInfoHashRef},
	tempHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$tempHashRef},
	familyIDRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$familyIDRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    foreach my $sampleID (keys %{ ${$sampleInfoHashRef}{$$familyIDRef} }) {
	
	foreach my $key (keys %{ ${$sampleInfoHashRef}{$$familyIDRef}{$sampleID}}) {
	    
	    if (exists(${$tempHashRef}{$$familyIDRef}{$sampleID}{$key})) {  #Previous run information, which should be updated using pedigree from current analysis
	
		${$tempHashRef}{$$familyIDRef}{$sampleID}{$key} = delete(${$sampleInfoHashRef}{$$familyIDRef}{$sampleID}{$key});  #Required to update info
	    }
	    else {

		${$tempHashRef}{$$familyIDRef}{$sampleID}{$key} = ${$sampleInfoHashRef}{$$familyIDRef}{$sampleID}{$key};
	    }
	}
    }
    %{$sampleInfoHashRef} = %{$tempHashRef};  #Copy hash with updated keys from what was in sampleInfo (should be only pedigree %allowedEntries)
}


sub UpdateToAbsolutePath {

##UpdateToAbsolutePath

##Function : Change relative path to absolute path for certain parameterNames 
##Returns  : ""
##Arguments: $parameterHashRef
##         : $parameterHashRef => The parameter hash {REF}

    my ($argHashRef) = @_;

    ##Flatten argument(s)
    my $parameterHashRef;

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my @parameterNames = ("inFilesDirs", "inScriptDir", "referencesDir", "outDataDir", "outScriptDir", "pedigreeFile", "configFile", "writeConfigFile", "sampleInfoFile", "logFile", "picardToolsPath", "genomeAnalysisToolKitPath", "vepDirectoryPath", "vepDirectoryCache", "snpEffPath", "annovarPath", "QCCollectSampleInfoFile");

    foreach my $parameterName (@parameterNames) {
	
	if (ref(${$parameterHashRef}{$parameterName}{value}) eq "ARRAY") {  #Array reference

	    for (my $elementCounter=0;$elementCounter<scalar(@{${$parameterHashRef}{$parameterName}{value}});$elementCounter++) {

		if ( (defined(${$parameterHashRef}{$parameterName}{value})) && (${$parameterHashRef}{$parameterName}{value}[$elementCounter] ne "nocmdinput") ) {
		  
		    my $elementSeparatorRef = \${$parameterHashRef}{$parameterName}{elementSeparator};  #Find what seperates array
		    my @seperateElements = split($$elementSeparatorRef, ${$parameterHashRef}{$parameterName}{value}[$elementCounter]);  #Split into seperate elements if written in 1 string on cmd
		    my @absolutePathElements;

		    foreach my $element (@seperateElements) {

			## Find aboslute path for supplied path or croaks and exists if path does not exists
			push(@absolutePathElements, &FindAbsolutePath({path => $element,
								       parameterName => $parameterName,
								      }));
		    }
		    ${$parameterHashRef}{$parameterName}{value}[$elementCounter] = join(",", @absolutePathElements);  #Replace original input with abolute path entries
		}
	    }
	}
	elsif ( (defined(${$parameterHashRef}{$parameterName}{value})) && (${$parameterHashRef}{$parameterName}{value} ne "nocmdinput") ) {
	    
	    ## Find aboslute path for supplied path or croaks and exists if path does not exists
	    ${$parameterHashRef}{$parameterName}{value} = &FindAbsolutePath({path => ${$parameterHashRef}{$parameterName}{value},
									     parameterName => $parameterName,
									    });
	}
    }
}

sub FindAbsolutePath {

##FindAbsolutePath
    
##Function : Find aboslute path for supplied path or croaks and exists if path does not exists
##Returns  : "$path - absolute path"
##Arguments: $path, $parameterName
##         : $path          => The supplied path to be updated/evaluated
##         : $parameterName => The parameter to be evaluated

    my ($argHashRef) = @_;

    ##Flatten argument(s)
    my $path;
    my $parameterName;

    my $tmpl = { 
	path => { required => 1, defined => 1, store => \$path},
	parameterName => { required => 1, defined => 1, strict_type => 1, store => \$parameterName},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $temporaryPath = $path;
    
    $path = abs_path($path);
    
    unless(defined($path)) {
	
	warn("Could not find absolute path for ".$parameterName.": ".$temporaryPath.". Please check the supplied path!\n");
	exit 1;
    }
    return $path;
}

sub OrderParameterNames {

##OrderParameterNames

##Function : Adds the order of first level keys from yaml file to array
##Returns  : ""
##Arguments: $orderParametersArrayRef
##         : $orderParametersArrayRef => The parameter array {REF}
##         : $filePath                => File path

    my ($argHashRef) = @_;

    ##Flatten argument(s)
    my $orderParametersArrayRef;
    my $filePath;

    my $tmpl = { 
	orderParametersArrayRef => { required => 1, default => [], strict_type => 1, store => \$orderParametersArrayRef},
	filePath => { required => 1, defined => 1, strict_type => 1, store => \$filePath},
    };

    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];
    
    open(my $DFY, "<", $filePath) or die("Can't open '".$filePath."': ".$!."\n");
    
    while (<$DFY>) {
	
	chomp $_; #Remove newline
	
	if ( ($. == 1) && ($_=~/---/) ) { #Header
	    
	    next;
	}
	if ( ($_!~/^#/) && ($_=~/^(\w+):/) ) { # First level key
	    
	    my $parameterName = $1;
	    push(@{$orderParametersArrayRef}, $parameterName); #Add to enable later evaluation of parameters in proper order & write to MIP log file
	    next;
	}
    }
}

sub AddToSampleInfo {

##AddToSampleInfo

##Function : Adds parameter info to sampleInfo
##Returns  : ""
##Arguments: $scriptParameterHashRef, $sampleInfoHashRef, $fileInfoHashRef, $familyIDRef, $referencesDirRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef      => Info on samples and family hash {REF}
##         : $fileInfoHashRef        => The fileInfo hash {REF}
##         : $familyIDRef            => The familyIDRef {REF}
##         : $referencesDirRef       => MIP reference directory {REF}

    my ($argHashRef) = @_;

    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $humanGenomeReferenceRef = ${$argHashRef}{humanGenomeReferenceRef} //= \${$argHashRef}{scriptParameterHashRef}{humanGenomeReference};
    my $outDataDir = ${$argHashRef}{outDataDir} //= ${$argHashRef}{scriptParameterHashRef}{outDataDir};
    
    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $sampleInfoHashRef;
    my $fileInfoHashRef;

    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	sampleInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$sampleInfoHashRef},
	fileInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$fileInfoHashRef},
	familyIDRef => { default => \$$, strict_type => 1, store => \$familyIDRef},
	referencesDirRef => { default => \$$, strict_type => 1},
	humanGenomeReferenceRef => { default => \$$, strict_type => 1},
	outDataDir => { strict_type => 1},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];    

    if (defined(${$scriptParameterHashRef}{instanceTag})) {

	${$sampleInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{InstanceTag} = ${$scriptParameterHashRef}{instanceTag};
    }
    if (defined(${$scriptParameterHashRef}{researchEthicalApproval})) {

	${$sampleInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{ResearchEthicalApproval} = ${$scriptParameterHashRef}{researchEthicalApproval};
    }
    if (defined(${$scriptParameterHashRef}{analysisType})) {

	${$sampleInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{AnalysisType} = ${$scriptParameterHashRef}{analysisType};
    }
    if (defined(${$scriptParameterHashRef}{genomeAnalysisToolKitPath})) {

	if (${$scriptParameterHashRef}{genomeAnalysisToolKitPath}=~/GenomeAnalysisTK-([^,]+)/) {
	    
	    ${$sampleInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{Program}{GATK}{Version} = $1;
	}
	else {  #Fall back on actually calling program
	    
	    my $jarPath = catfile(${$scriptParameterHashRef}{genomeAnalysisToolKitPath}, "GenomeAnalysisTK.jar");
	    my $ret = (`java -jar $jarPath --version 2>&1`);
	    chomp($ret);
	    ${$sampleInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{Program}{GATK}{Version} = $ret;
	}
    }
    if (defined(${$scriptParameterHashRef}{picardToolsPath})) {  #To enable addition of version to sampleInfo
	
	if (${$scriptParameterHashRef}{picardToolsPath}=~/picard-tools-([^,]+)/) {
	    
	    ${$sampleInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{Program}{PicardTools}{Version} = $1;
	}
	else {  #Fall back on actually calling program

	    my $jarPath = catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar");
	    my $ret = (`java -jar $jarPath CreateSequenceDictionary --version 2>&1`);
	    chomp($ret);
	    ${$sampleInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{Program}{PicardTools}{Version} = $ret;
	}
    }
    if ( (${$scriptParameterHashRef}{pBwaMem} == 1) || (${$scriptParameterHashRef}{pSambambaDepth} == 1) || (${$scriptParameterHashRef}{pSambambaMarkduplicates} == 1)) {  #To enable addition of version to sampleInfo as Sambamba does nit generate version tag in output
	
	if (${$scriptParameterHashRef}{dryRunAll} == 0) {
	    
	    my $regExp = q?perl -nae 'if($_=~/sambamba\s(\S+)/) {print $1;last;}'?;
	    my $ret = (`sambamba 2>&1 | $regExp`);
	    chomp($ret);
	    ${$sampleInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{Program}{Sambamba}{Version} = $ret;
	}
    }
    if (defined(${$scriptParameterHashRef}{pCNVnator})) {  #To enable addition of version to sampleInfo
	
	if ( (${$scriptParameterHashRef}{pCNVnator} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {

	    my $regExp = q?perl -nae 'if($_=~/CNVnator\s+(\S+)/) {print $1;last;}'?;
	    my $ret = (`cnvnator 2>&1 | $regExp`);
	    chomp($ret);
	    ${$sampleInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{Program}{CNVnator}{Version} = $ret;
	}
    }
    if (defined($$humanGenomeReferenceRef)) {  #To enable addition of version to sampleInfo

	${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{HumanGenomeBuild}{Path} = catfile($$referencesDirRef, $$humanGenomeReferenceRef);
	${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{HumanGenomeBuild}{Source} = ${$fileInfoHashRef}{humanGenomeReferenceSource};
	${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{HumanGenomeBuild}{Version} = ${$fileInfoHashRef}{humanGenomeReferenceVersion};
    }
    if (defined(${$scriptParameterHashRef}{pedigreeFile}) ) {
	
	${$sampleInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{PedigreeFile}{Path} = ${$scriptParameterHashRef}{pedigreeFile};  #Add pedigreeFile to sampleInfo
	${$sampleInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{PedigreeFileAnalysis}{Path} = catfile($outDataDir, $$familyIDRef, "qc_pedigree.yaml");  #Add pedigreeFile info used in this analysis to SampleInfoFile
    }
    if (defined(${$scriptParameterHashRef}{logFile})) {

	my $path = dirname(dirname(${$scriptParameterHashRef}{logFile}));
	${$sampleInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{logFileDir} = $path;  #Add logFileDir to SampleInfoFile
	${$sampleInfoHashRef}{ $$familyIDRef }{ $$familyIDRef }{lastLogFilePath} = ${$scriptParameterHashRef}{logFile};
    }
}


sub EvalParameterHash {

##EvalParameterHash
    
##Function : Evaluate parameters in parameters hash
##Returns  : ""
##Arguments: $parameterHashRef, $filePath
##         : $parameterHashRef => Hash with paremters from yaml file {REF}
##         : $filePath         => Path to yaml file

    my ($argHashRef) = @_;
    
    ##Flatten argument(s)
    my $parameterHashRef;
    my $filePath;
    
    my $tmpl = { 
	parameterHashRef => { required => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	filePath => { required => 1, defined => 1, strict_type => 1, store => \$filePath},
    };

    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my %mandatoryKey;
    $mandatoryKey{associatedProgram}{keyDataType} = "ARRAY";
    $mandatoryKey{dataType}{keyDataType} = "SCALAR";
    $mandatoryKey{dataType}{values} = ["SCALAR", "ARRAY", "HASH"];
    $mandatoryKey{type}{keyDataType} = "SCALAR";
    $mandatoryKey{type}{values} = ["MIP", "path", "program", "programArgument"];
 
    my %nonMandatoryKey;
    $nonMandatoryKey{buildFile}{keyDataType} = "SCALAR";
    $nonMandatoryKey{buildFile}{values} = ["noAutoBuild", "yesAutoBuild", "yesAutoDownLoad"];
    $nonMandatoryKey{mandatory}{keyDataType} = "SCALAR";
    $nonMandatoryKey{mandatory}{values} = ["no"];
    $nonMandatoryKey{existsCheck}{keyDataType} = "SCALAR";
    $nonMandatoryKey{existsCheck}{values} = ["file", "directory"];
    $nonMandatoryKey{chain}{keyDataType} = "SCALAR";
    $nonMandatoryKey{fileTag}{keyDataType} = "SCALAR";
    $nonMandatoryKey{programNamePath}{keyDataType} = "ARRAY";
    $nonMandatoryKey{elementSeparator}{keyDataType} = "SCALAR";
    $nonMandatoryKey{reduceIO}{keyDataType} = "SCALAR";
    $nonMandatoryKey{reduceIO}{values} = [1];
    $nonMandatoryKey{programType}{keyDataType} = "SCALAR";
    $nonMandatoryKey{programType}{values} = ["aligner", "variantCaller", "structuralVariantCaller"];
    $nonMandatoryKey{outDirectoryName}{keyDataType} = "SCALAR";
    $nonMandatoryKey{fileEnding}{keyDataType} = "ARRAY";
    $nonMandatoryKey{removeRedundantFiles}{keyDataType} = "SCALAR";
    $nonMandatoryKey{removeRedundantFiles}{values} = ["yes"];
    $nonMandatoryKey{removalSetting}{keyDataType} = "SCALAR";
    $nonMandatoryKey{removalSetting}{values} = ["single", "merged", "family", "variantAnnotation"];
    $nonMandatoryKey{reference}{keyDataType} = "SCALAR";
    $nonMandatoryKey{reference}{values} = ["referencesDir"];

    &CheckKeys({parameterHashRef => $parameterHashRef,
		mandatoryKeyHashRef => \%mandatoryKey,
		nonMandatoryKeyHashRef => \%nonMandatoryKey,
		filePathRef => \$filePath,
	       });
}


sub CheckKeys {

##CheckKeys
    
##Function : Evaluate keys in hash
##Returns  : ""
##Arguments: $parameterHashRef, $mandatoryKeyHashRef, $nonMandatoryKeyHashRef, $filePath
##         : $parameterHashRef       => Hash with parameters from yaml file {REF}
##         : $mandatoryKeyHashRef    => Hash with mandatory key {REF}
##         : $nonMandatoryKeyHashRef => Hash with non mandatory key {REF}
##         : $filePathRef            => Path to yaml file {REF}

    my ($argHashRef) = @_;
    
    ##Flatten argument(s)
    my $parameterHashRef;
    my $mandatoryKeyHashRef;
    my $nonMandatoryKeyHashRef;
    my $filePathRef;
    
    my $tmpl = { 
	parameterHashRef => { required => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	mandatoryKeyHashRef => { required => 1, default => {}, strict_type => 1, store => \$mandatoryKeyHashRef},
	nonMandatoryKeyHashRef => { required => 1, default => {}, strict_type => 1, store => \$nonMandatoryKeyHashRef},
	filePathRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$filePathRef},
    };

    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    foreach my $parameter (keys %{$parameterHashRef}) {

	foreach my $mandatoryKey (keys %{$mandatoryKeyHashRef}) {
	    
	    ## Mandatory key exists
	    if (exists(${$parameterHashRef}{$parameter}{$mandatoryKey})) {

		## Check key data type
		&CheckDataType({parameterHashRef => $parameterHashRef,
				keyHashRef => $mandatoryKeyHashRef,
				parameter => $parameter,
				key => $mandatoryKey,
				filePathRef => $filePathRef,
			       });
		## Evaluate key values
		&CheckValues({parameterHashRef => $parameterHashRef,
			      keyHashRef => $mandatoryKeyHashRef,
			      parameter => $parameter,
			      key => $mandatoryKey,
			      filePathRef => $filePathRef,
			     });
	    }	    
	    else {
		
		warn("Missing mandatory key: '".$mandatoryKey."' for parameter: '".$parameter."' in file: '".$$filePathRef."'\n");
		exit 1;
	    }
	}
	foreach my $nonMandatoryKey (keys %{$nonMandatoryKeyHashRef}) {
	    
	    ## NonMandatory key exists
	    if (exists(${$parameterHashRef}{$parameter}{$nonMandatoryKey})) {

		## Check key data type
		&CheckDataType({parameterHashRef => $parameterHashRef,
				keyHashRef => $nonMandatoryKeyHashRef,
				parameter => $parameter,
				key => $nonMandatoryKey,
				filePathRef => $filePathRef,
			       });

		## Evaluate key values
		&CheckValues({parameterHashRef => $parameterHashRef,
			      keyHashRef => $nonMandatoryKeyHashRef,
			      parameter => $parameter,
			      key => $nonMandatoryKey,
			      filePathRef => $filePathRef,
			     });
	    }	    
	}
    }
}


sub CheckValues {

##CheckValues
    
##Function : Evaluate key values 
##Returns  : ""
##Arguments: $parameterHashRef, $keyHashRef, $key, $filePathRef
##         : $parameterHashRef => Hash with parameters from yaml file {REF}
##         : $keyHashRef       => Hash with  key {REF}
##         : $key              => Hash with non  key
##         : $filePathRef      => Path to yaml file {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $parameterHashRef;
    my $keyHashRef;
    my $parameter;
    my $key;
    my $filePathRef;
    
    my $tmpl = { 
	parameterHashRef => { required => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	keyHashRef => { required => 1, default => {}, strict_type => 1, store => \$keyHashRef},
	parameter => { required => 1, defined => 1, strict_type => 1, store => \$parameter},
	key => { required => 1, defined => 1, strict_type => 1, store => \$key},
	filePathRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$filePathRef},
    };

    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    ## Check value(s)
    if (${$keyHashRef}{$key}{values}) {
	
	my $valueRef = \${$parameterHashRef}{$parameter}{$key};

	if ( ! (any {$_ eq $$valueRef} @{${$keyHashRef}{$key}{values}}) ) {
	    
	    warn("Found illegal value '".$$valueRef."' for parameter: '".$parameter."' in key: '".$key."' in file: '".$$filePathRef."'\n");
	    warn("Allowed entries: '".join("', '", @{${$keyHashRef}{$key}{values}})."'\n");
	    exit 1;
	}
    }
}


sub CheckDataType {

##CheckDataType

##Function : Check key data type 
##Returns  : ""
##Arguments: $parameterHashRef, $keyHashRef, $key, $filePathRef
##         : $parameterHashRef => Hash with paremters from yaml file {REF}
##         : $keyHashRef       => Hash with  key {REF}
##         : $key              => Hash with non  key
##         : $filePathRef      => Path to yaml file {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $parameterHashRef;
    my $keyHashRef;
    my $parameter;
    my $key;
    my $filePathRef;

    my $tmpl = { 
	parameterHashRef => { required => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	keyHashRef => { required => 1, default => {}, strict_type => 1, store => \$keyHashRef},
	parameter => { required => 1, defined => 1, strict_type => 1, store => \$parameter},
	key => { required => 1, defined => 1, strict_type => 1, store => \$key},
	filePathRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$filePathRef},
    };

    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    ## Check dataType
    my $dataType = ref(${$parameterHashRef}{$parameter}{$key});
    
    if ($dataType) {  #Array or hash
	
	## Wrong dataType
	unless ($dataType eq ${$keyHashRef}{$key}{keyDataType}) {
	    
	    warn("Found '".$dataType."' but expected datatype '".${$keyHashRef}{$key}{keyDataType}."' for parameter: '".$parameter."' in key: '".$key."' in file: '".$$filePathRef."'\n");
	    exit 1;
	}
    }
    elsif (${$keyHashRef}{$key}{keyDataType} ne "SCALAR") {
	
	## Wrong dataType
	warn("Found 'SCALAR' but expected datatype '".${$keyHashRef}{$key}{keyDataType}."' for parameter: '".$parameter."' in key: '".$key."' in file: '".$$filePathRef."'\n");
	exit 1;
    }
}


sub CompareHashKeys {

##CompareHashKeys
    
##Function : Compare keys in two hashes
##Returns  : ""
##Arguments: $referenceHashRef, $comparisonHashRef
##         : $referenceHashRef  => Reference hash {REF}
##         : $comparisonHashRef => Hash to be compared to reference {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $referenceHashRef;
    my $comparisonHashRef;

    my $tmpl = { 
	referenceHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$referenceHashRef},
	comparisonHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$comparisonHashRef},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my @allowedUniqueKeys = ("VcfParserOutputFileCount", ${$referenceHashRef}{familyID});
    my @unique;

    foreach my $key (keys %{$referenceHashRef}) {
	 
	unless (exists(${$comparisonHashRef}{$key})) {
	    
	    push(@unique, $key);
	}
    }
    foreach my $element (@unique) {

	if ( ! (any {$_ eq $element} @allowedUniqueKeys) ) { #Do not print if allowedUniqueKeys that have been created dynamically from previous runs

	    warn("Found illegal key: ".$element." in config file that is not defined in definitions.yaml\n");
	    exit 1;
	}
    }
}

sub CheckVEPDirectories {
    
##CheckVEPDirectories
    
##Function : Compare VEP directory and VEP chache versions
##Returns  : ""
##Arguments: $vepDirectoryPathRef, $vepDirectoryCacheRef
##         : $vepDirectoryPathRef  => VEP directory path {REF}
##         : $vepDirectoryCacheRef => VEP cache directory path {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $vepDirectoryPathRef;
    my $vepDirectoryCacheRef;
    
    my $tmpl = { 
	vepDirectoryPathRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$vepDirectoryPathRef},
	vepDirectoryCacheRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$vepDirectoryCacheRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    if ($$vepDirectoryPathRef=~/ensembl-tools-release-(\d+)/) {
	
	my $vepDirectoryPathVersion = $1;

	unless ($$vepDirectoryCacheRef=~/ensembl-tools-release-$vepDirectoryPathVersion/) {
	    
	    print $logger->fatal("Differing versions between '-vepDirectoryPath': ".$$vepDirectoryPathRef." and '-vepDirectoryCache': ".$$vepDirectoryCacheRef, "\n");
	    exit 1;
	}
    }

}


sub VTCore {

##VTCore

##Function : Split multi allelic records into single records and normalize
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $infilePath, $outfilePath, $familyID, $FILEHANDLE, $nrCores, $decompose, $normalize, $maxAF, $calculateAF, $sed, $program, $programDirectory, $bgzip, $tabix, $InStream, $cmdBreak, $xargsFileName, $contigRef
##         : $parameterHashRef           => Hash with paremters from yaml file {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $infilePath                 => Infile path
##         : $outfilePath                => Outfile path
##         : $familyID                   => The family ID
##         : $FILEHANDLE                 => Filehandle to write to
##         : $nrCores                    => The number of cores to allocate
##         : $decompose                  => Vt program decomnpose for splitting multiallelic variants
##         : $normalize                  => Vt program normalize for normalizing to reference used in analysis
##         : $maxAF                      => MIP script for adding MAX_AF to frequency reference used in analysis
##         : $calculateAF                => MIP script for adding AF_ to frequency reference used in analysis
##         : $sed                        => Sed program for changing vcf #FORMAT field in variant vcfs
##         : $program                    => The program name
##         : $programDirectory           => Program directory to write to in sbatch script
##         : $bgzip                      => Compress output from vt using bgzip
##         : $tabix                      => Index compressed output using tabix
##         : $InStream                   => Data to vt is supplied as a unix pipe
##         : $cmdBreak                   => Command line separator ['"\n\n"'|";"]
##         : $xargsFileName              => The xargs sbatch script file name
##         : $contigRef                  => The contig to extract {REF}

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $humanGenomeReferenceRef = ${$argHashRef}{humanGenomeReferenceRef} //= \${$argHashRef}{scriptParameterHashRef}{humanGenomeReference};
    my $outfilePath = ${$argHashRef}{outfilePath} //= ${$argHashRef}{infilePath};
    my $nrCores;
    my $decompose;
    my $normalize;
    my $maxAF;
    my $calculateAF;
    my $sed;
    my $program;
    my $programDirectory;
    my $bgzip;
    my $tabix;
    my $inStream;
    my $cmdbreak;
    
    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;
    my $sampleInfoHashRef;
    my $infilesLaneNoEndingHashRef;
    my $jobIDHashRef;
    my $infilePath;
    my $FILEHANDLE;
    my $xargsFileName;
    my $contigRef;

    my $tmpl = { 
	parameterHashRef => { default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	sampleInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$sampleInfoHashRef},
	infilesLaneNoEndingHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$infilesLaneNoEndingHashRef},
	jobIDHashRef => { default => {}, strict_type => 1, store => \$jobIDHashRef},
	infilePath => { required => 1, defined => 1, strict_type => 1, store => \$infilePath},
	FILEHANDLE => { store => \$FILEHANDLE},
	xargsFileName => { required => 1, defined => 1, strict_type => 1, store => \$xargsFileName},
	contigRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$contigRef},
	familyIDRef => { default => \$$, strict_type => 1, store => \$familyIDRef},
	referencesDirRef => { default => \$$, strict_type => 1},
	humanGenomeReferenceRef => { default => \$$, strict_type => 1},
	outfilePath => { strict_type => 1},
	nrCores => { default => 1,
		     allow => qr/^\d+$/,
		     strict_type => 1, store => \$nrCores},
	decompose => { default => 0,
		       allow => [0, 1],
		       strict_type => 1, store => \$decompose},
	normalize => { default => 0,
		       allow => [0, 1],
		       strict_type => 1, store => \$normalize},
	maxAF => { default => 0,
		   allow => [0, 1],
		   strict_type => 1, store => \$maxAF},
	calculateAF => { default => 0,
			 allow => [0, 1],
			 strict_type => 1, store => \$calculateAF},
	sed  => { default => 0,
		  allow => [0, 1],
		  strict_type => 1, store => \$sed},
	program => { default => "VT", strict_type => 1, store => \$program},
	programDirectory => { default => "vt", strict_type => 1, store => \$programDirectory},
	bgzip => { default => 0,
		   allow => [0, 1],
		   strict_type => 1, store => \$bgzip},
	tabix => { default => 0,
		   allow => [0, 1],
		   strict_type => 1, store => \$tabix},
	inStream => { default => 0,
		      allow => [0, 1],
		      strict_type => 1, store => \$inStream},
	cmdbreak => { default => "\n\n", strict_type => 1, store => \$cmdbreak},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $fileName;
    my $programInfoPath;
    my $randomInteger = int(rand(10000));  #Generate a random integer between 0-10,000.	

    unless (defined($FILEHANDLE)){ #Run as individual sbatch script

	$FILEHANDLE = IO::Handle->new();  #Create anonymous filehandle
	
	## Creates program directories (info & programData & programScript), program script filenames and writes sbatch header
	($fileName, $programInfoPath) = &ProgramPreRequisites({scriptParameterHashRef => $scriptParameterHashRef,
							       jobIDHashRef => $jobIDHashRef,
							       FILEHANDLE => $FILEHANDLE,
							       directoryID => $$familyIDRef,
							       programName => $program,
							       programDirectory => lc($programDirectory),
							       nrofCores => $nrCores,
							       processTime => 20,
							      });
    }
    
    ## Split multi allelic records into single records and normalize
    if ( (${$scriptParameterHashRef}{VTDecompose} > 0) || (${$scriptParameterHashRef}{VTNormalize} > 0) || (defined(${$scriptParameterHashRef}{VTgenmodFilter1000G})) || (${$scriptParameterHashRef}{pSnpEff} > 0) ) { 
	
	if ( ! $inStream) {  #Use less to initate processing

	    say $FILEHANDLE "## VT - Decompose (split multi allelic records into single records) and/or normalize variants and/or add MAX_AF";
	    print $FILEHANDLE "less ";
	    print $FILEHANDLE $infilePath." ";  #Infile
	}
	if ($sed) {  #Replace #FORMAT field prior to smart decomposition (variant vcfs)

	    print $FILEHANDLE "| ";  #Pipe		
	    print $FILEHANDLE q?sed 's/ID=AD,Number=./ID=AD,Number=R/' ?;
	}
	if ( (${$scriptParameterHashRef}{VTDecompose} > 0) && ($decompose) ) {

	    print $FILEHANDLE "| ";  #Pipe
	    print $FILEHANDLE "vt decompose ";  #Decomposes multiallelic variants into biallelic in a VCF file
	    print $FILEHANDLE "-s ";  #Smart decomposition
	    print $FILEHANDLE "- ";  #InStream

	    if ( (defined($xargsFileName)) && (defined($$contigRef)) ) {  #Write stderr for xargs process

		print $FILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	    }
	}
	if ( (${$scriptParameterHashRef}{VTNormalize} > 0) && ($normalize) ) {  #Write stderr for xargs process

	    print $FILEHANDLE "| ";  #Pipe
	    print $FILEHANDLE "vt normalize ";  #Normalize variants in a VCF.The normalized variants are reordered and output in an ordered fashion
	    print $FILEHANDLE "-n ";  #Do not fail when REF is inconsistent with reference sequence for non SNPs
	    print $FILEHANDLE "-r ".catfile($$referencesDirRef, $$humanGenomeReferenceRef)." ";  #Reference file
	    print $FILEHANDLE "- ";  #InStream

	    if ( (defined($xargsFileName)) && (defined($$contigRef)) ) {  #Write stderr for xargs process

		print $FILEHANDLE "2>> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	    }
	}
	if ( (${$scriptParameterHashRef}{pSnpEff} > 0) && ($calculateAF) ) {  #$calculateAf should not be set to 1 if reference was not part of SnpEff parameter
	    
	    print $FILEHANDLE "| ";  #Pipe
	    print $FILEHANDLE "perl ".catfile($Bin, "calculateAF.pl")." ";  #Add AF_
	    print $FILEHANDLE "- ";  #InStream
	    
	    if ( (defined($xargsFileName)) && (defined($$contigRef)) ) {  #Write stderr for xargs process

		print $FILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	    }
	}
	if ( (exists(${$scriptParameterHashRef}{VTgenmodFilter1000G})) && ($maxAF) ) {

	    print $FILEHANDLE "| ";  #Pipe
	    print $FILEHANDLE "perl ".catfile($Bin, "maxAF.pl")." ";  #Add MAX_AF
	    print $FILEHANDLE "- ";  #InStream

	    if ( (defined($xargsFileName)) && (defined($$contigRef)) ) {  #Write stderr for xargs process

		print $FILEHANDLE "2> ".$xargsFileName.".".$$contigRef.".stderr.txt ";  #Redirect xargs output to program specific stderr file
	    }
	}
	if ( (-e $infilePath.".tbi") || ($bgzip) ) {  #Tabix has been/will be used on file, compress again
	
	    print $FILEHANDLE "| ";  #Pipe
	    print $FILEHANDLE "bgzip ";  #Compression algorithm
	    print $FILEHANDLE "-c ";  #Write on standard output, keep original files unchanged
	}
	print $FILEHANDLE "> ".$outfilePath."_splitted_".$randomInteger." ";  #Temporary outfile
	print $FILEHANDLE $cmdbreak;
	
	if ( (-e $infilePath.".tbi") || ($tabix) ) {  #Tabix index

	    print $FILEHANDLE "tabix ";
	    print $FILEHANDLE "-p vcf ";  #Preset
	    print $FILEHANDLE "-f ";  #Force to overwrite the index
	    print $FILEHANDLE $outfilePath."_splitted_".$randomInteger." ";  #Temporary outfile
	    print $FILEHANDLE $cmdbreak;

	    ## Move index in place
	    print $FILEHANDLE "mv ";
	    print $FILEHANDLE $outfilePath."_splitted_".$randomInteger.".tbi ";
	    print $FILEHANDLE $outfilePath.".tbi ";
	    print $FILEHANDLE $cmdbreak;
	}

	## Move processed reference to original place
	print $FILEHANDLE "mv ";
	print $FILEHANDLE $outfilePath."_splitted_".$randomInteger." ";
	print $FILEHANDLE $outfilePath." ";
	print $FILEHANDLE $cmdbreak;
    }
    
    unless(${$argHashRef}{FILEHANDLE}) {  #Unless FILEHANDLE was supplied close it and submit 
	
	close($FILEHANDLE);
	
	if ( (${$scriptParameterHashRef}{"p".$program} == 1) && (${$scriptParameterHashRef}{dryRunAll} == 0) ) {
	    
	    &FIDSubmitJob({scriptParameterHashRef => $scriptParameterHashRef,
			   sampleInfoHashRef => $sampleInfoHashRef,
			   infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			   jobIDHashRef => $jobIDHashRef,
			   dependencies => 6, 
			   path => ${$parameterHashRef}{"p".$program}{chain},
			   sbatchFileName => $fileName
			  });
	}
    }
}


sub CheckMandatoryArguments {

##CheckMandatoryArguments

##Function : Check that all mandatory arguments have been passed to subroutine
##Returns  : ""
##Arguments: $mandatoryArgumentHashRef, $functionName
##         : $mandatoryArgumentHashRef => Mandatory arguments hash {REF}
##         : $functionName             => Name of the calling function

    my $mandatoryArgumentHashRef = $_[0];
    my $functionName = $_[1];
    
    foreach my $key (keys (%{$mandatoryArgumentHashRef})) {
	
	unless (defined(${$mandatoryArgumentHashRef}{$key})) {
	    
	    warn("Mandatory argument: '".$key."' missing in function: '".$functionName."'\n");
	    exit 1;
	}
    }
}


sub CheckVTForReferences {
    
##CheckVTForReferences
    
##Function : Check if vt has processed references
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $vtReferencesArrayRef, $referencesDirRef
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $vtReferencesArrayRef       => The references to check with vt {REF}
##         : $referencesDirRef           => MIP reference directory {REF}

    my ($argHashRef) = @_;

    ## Default(s)
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    my $VTDecompose;
    my $VTNormalize;

    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;
    my $sampleInfoHashRef;
    my $infilesLaneNoEndingHashRef;
    my $jobIDHashRef;
    my $vtReferencesArrayRef;
    
    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	sampleInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$sampleInfoHashRef},
	infilesLaneNoEndingHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$infilesLaneNoEndingHashRef},
	jobIDHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$jobIDHashRef},
	vtReferencesArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$vtReferencesArrayRef},
	referencesDirRef => { default => \$$, strict_type => 1},
	VTDecompose => { default => 0,
			 allow => [0, 1],
			 strict_type => 1, store => \$VTDecompose},
	VTNormalize => { default => 0,
			 allow => [0, 1],
			 strict_type => 1, store => \$VTNormalize},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];
    
    my %seen;  #Avoid checking the same reference multiple times

    if ( ($VTDecompose) || ($VTNormalize) ) {
	
	foreach my $parameterName (@{$vtReferencesArrayRef}) {
	    
	    my $referenceFilePath;

	    if (${$parameterHashRef}{$parameterName}{dataType} eq "SCALAR") {
		
		$referenceFilePath = catfile($$referencesDirRef, $scriptParameter{$parameterName});

		unless (exists($seen{$referenceFilePath})) {

		    ## Check if vt has processed references using RegExp
		    &CheckVT({parameterHashRef => $parameterHashRef,
			      scriptParameterHashRef =>$scriptParameterHashRef,
			      sampleInfoHashRef => $sampleInfoHashRef,
			      infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			      jobIDHashRef => $jobIDHashRef,
			      referenceFilePath => $referenceFilePath,
			      parameterName => $parameterName,
			     });
		}
		$seen{$referenceFilePath} = 1;
	    }
	    elsif (${$parameterHashRef}{$parameterName}{dataType} eq "ARRAY") {  #ARRAY reference
		
		foreach my $annotationFile (@{${$scriptParameterHashRef}{$parameterName}}) {
		    
		    $referenceFilePath = catfile($$referencesDirRef, $annotationFile);
		    
		    unless (exists($seen{$referenceFilePath})) {
			
			## Check if vt has processed references using RegExp
			&CheckVT({parameterHashRef => $parameterHashRef,
				  scriptParameterHashRef =>$scriptParameterHashRef,
				  sampleInfoHashRef => $sampleInfoHashRef,
				  infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
				  jobIDHashRef => $jobIDHashRef,
				  referenceFilePath => $referenceFilePath,
				  parameterName => $parameterName,
				 });
		    }   
		    $seen{$referenceFilePath} = 1;
		}
	    }
	    elsif (${$parameterHashRef}{$parameterName}{dataType} eq "HASH") {  #Hash reference
		
		for my $annotationFile (keys %{${$scriptParameterHashRef}{$parameterName}}) {
		    
		    $referenceFilePath = catfile($$referencesDirRef, $annotationFile);

		    unless (exists($seen{$referenceFilePath})) {

			## Check if vt has processed references using RegExp
			&CheckVT({parameterHashRef => $parameterHashRef,
				  scriptParameterHashRef =>$scriptParameterHashRef,
				  sampleInfoHashRef => $sampleInfoHashRef,
				  infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
				  jobIDHashRef => $jobIDHashRef,
				  referenceFilePath => $referenceFilePath,
				  parameterName => $parameterName,
				 });
		    }   
		    $seen{$referenceFilePath} = 1;
		}
	    }
	}
    }
}


sub CheckVT {

##CheckVT

##Function : Check if vt has processed references using RegExp
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $infilesLaneNoEndingHashRef, $jobIDHashRef, $referenceFilePath, $parameterName 
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $jobIDHashRef               => The jobID hash {REF}
##         : $referenceFilePath          => The reference file path
##         : $parameterName              => The MIP parameterName

    my ($argHashRef) = @_;
        
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $referenceFilePath = ${$argHashRef}{referenceFilePath};
    my $parameterName = ${$argHashRef}{parameterName};

     my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	sampleInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$sampleInfoHashRef},
	infilesLaneNoEndingHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$infilesLaneNoEndingHashRef},
	jobIDHashRef => { default => {}, strict_type => 1, store => \$jobIDHashRef},
	referenceFilePath => { required => 1, defined => 1, strict_type => 1, store => \$referenceFilePath},
	parameterName => { required => 1, defined => 1, strict_type => 1, store => \$parameterName},
    };

    my %vtRegExp;

    $vtRegExp{decompose}{VTDecompose}{VCFKey} = "OLD_MULTIALLELIC";
    $vtRegExp{normalize}{VTNormalize}{VCFKey} = "OLD_VARIANT";
    $vtRegExp{maxAF}{VTgenmodFilter}{VCFKey} = "MAX_AF";
    $vtRegExp{calulateAF}{VTgenmodFilter}{VCFKey} = "calculateAF";

    $vtRegExp{decompose}{VTDecompose}{Switch} = 0;
    $vtRegExp{normalize}{VTNormalize}{Switch} = 0;
    $vtRegExp{maxAF}{VTgenmodFilter}{Switch} = 0;
    $vtRegExp{calulateAF}{VTgenmodFilter}{Switch} = 0;

    my @maxAFReferences = (q?ALL.wgs.phase\d+.\S+.vcf?, q?ExAC.r\d+.\d+.sites.vep.vcf?);
    my @calulateAFReferences = (q?ExAC.r\d+.\d+.sites.vep.vcf?);

    if (-e $referenceFilePath) {  #Downloaded and vt later (for downloadable references otherwise file existens error is thrown downstream)
	
	foreach my $vtProgram (keys %vtRegExp) {
	    
	    foreach my $associatedProgram (@{${$parameterHashRef}{$parameterName}{associatedProgram}}) {

		if (${$scriptParameterHashRef}{$associatedProgram} > 0) {  #Active or dry run for associated program

		    foreach my $vtParameterName (keys %{$vtRegExp{$vtProgram}}) {  #MIP flags
		
			my $regExp = q?perl -nae 'if($_=~/ID\=?.$vtRegExp{$vtProgram}{$vtParameterName}{VCFKey}.q?/) {print $_} if($_=~/#CHROM/) {last}'?;
			my $ret = `less $referenceFilePath | $regExp`; #Detect if vt program has processed reference

			unless ($ret) {  #No tracks of vt processing found
			    
			    if ( ($vtProgram eq "decompose") || ($vtProgram eq "normalize") ){

				$vtRegExp{$vtProgram}{$vtParameterName}{Switch} = 1;
				$logger->warn("Cannot detect that ".$vtProgram." has processed reference: ".$referenceFilePath."\n");
			    }
			    if ( ($vtProgram eq "maxAF") && (any {$referenceFilePath=~/$_/} @maxAFReferences) ) {

				$vtRegExp{$vtProgram}{$vtParameterName}{Switch} = 1;
				$logger->warn("Cannot detect that ".$vtProgram." has processed reference: ".$referenceFilePath."\n");
			    }
			    if ( ($vtProgram eq "calulateAF") && (any {$referenceFilePath=~/$_/} @calulateAFReferences) ) {
				
				$vtRegExp{$vtProgram}{$vtParameterName}{Switch} = 1;
				$logger->warn("Cannot detect that ".$vtProgram." has processed reference: ".$referenceFilePath."\n");
			    }
			}
			else {  #Found vt processing track
			    
			    $logger->info("ReferenceCheck: ".$referenceFilePath." vt:".$vtProgram." - PASS\n");
			}
		    }
		    last;  #No need to test the same reference over and over
		}
	    }
	}
	foreach my $vtProgram (keys %vtRegExp) {
	    
	    foreach my $vtParameterName (keys %{$vtRegExp{$vtProgram}}) {  #MIP flags
	
		if ($vtRegExp{$vtProgram}{$vtParameterName}{Switch}) {
		    
		    ## Split multi allelic records into single records and normalize
		    &VTCore({parameterHashRef => $parameterHashRef,
			     scriptParameterHashRef => $scriptParameterHashRef,
			     sampleInfoHashRef => $sampleInfoHashRef,		   
			     infilesLaneNoEndingHashRef => $infilesLaneNoEndingHashRef,
			     jobIDHashRef => $jobIDHashRef,
			     infilePath => $referenceFilePath,
			     programDirectory => "VT",
			     decompose => $vtRegExp{decompose}{VTDecompose}{Switch},
			     normalize => $vtRegExp{normalize}{VTNormalize}{Switch},
			     maxAF => $vtRegExp{maxAF}{VTgenmodFilter}{Switch},
			     calculateAF => $vtRegExp{calulateAF}{VTgenmodFilter}{Switch},
			    });
		}
	    }
	}
    }
}


sub Bgzip {

##Bgzip
    
##Function : Compress or decompress original file or stream to outfile (if supplied)
##Returns  : ""
##Arguments: $infilePath, $outfilePath, $compress
##         : $infilePath  => In file path
##         : $outfilePath => Out file path
##         : $compress    => Compress file
##         : $FILEHANDLE  => Filehandle to write to

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $compress = ${$argHashRef}{compress} //= "yes";
    
    ## Flatten argument(s)
    my $infilePath = ${$argHashRef}{infilePath};
    my $outfilePath = ${$argHashRef}{outfilePath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    ## Mandatory arguments
    my %mandatoryArgument = (infilePath => $infilePath,
			     FILEHANDLE => $FILEHANDLE,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "Bgzip");

    print $FILEHANDLE "bgzip ";

    if ( ($compress eq "yes") && defined($outfilePath) ) {  #Compress and stream

	print $FILEHANDLE "-c ";
	print $FILEHANDLE $infilePath." ";
	print $FILEHANDLE "> ".$outfilePath." ";
    }
    elsif ($compress eq "yes") {  #Compress original file

	print $FILEHANDLE $infilePath." ";
    }
    elsif ( ($compress ne "yes") && defined($outfilePath) ){  #Decompress and stream

	print $FILEHANDLE "-d ";
	print $FILEHANDLE "-c ";
	print $FILEHANDLE $infilePath." ";
	print $FILEHANDLE "> ".$outfilePath." ";
    }
    else {  #Decompress original file

	print $FILEHANDLE "-d ";
	print $FILEHANDLE $infilePath." ";
    }
    say $FILEHANDLE "\n";

}

sub Tabix {

##Tabix
    
##Function : Index file using tabix 
##Returns  : ""
##Arguments: $infilePath, $preset
##         : $infilePath  => In file path
##         : $preset      => preset, file format
##         : $FILEHANDLE  => Filehandle to write to

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $preset = ${$argHashRef}{preset} //= "vcf";
    
    ## Flatten argument(s)
    my $infilePath = ${$argHashRef}{infilePath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    ## Mandatory arguments
    my %mandatoryArgument = (infilePath => $infilePath,
			     FILEHANDLE => $FILEHANDLE,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "Tabix");

    print $FILEHANDLE "tabix ";
    print $FILEHANDLE "-p ".$preset." ";  #Preset
    print $FILEHANDLE "-f ";  #Force to overwrite the index
    print $FILEHANDLE $infilePath." ";  #Temporary outfile
    say $FILEHANDLE "\n";
} 


sub RemoveFiles {
    
##RemoveFiles
    
##Function : Removes intermediate files from the MIP analysis depending on set MIP parameters
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $sampleInfoHashRef, $laneHashRef, $infilesLaneNoEndingHashRef, $FILEHANDLE, $familyID, $sampleID, $alignerOutDir, $callType, $programName, $reduceIORef
##         : $parameterHashRef           => The parameter hash {REF}
##         : $scriptParameterHashRef     => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef          => Info on samples and family hash {REF}
##         : $fileInfoHashRef            => The fileInfo hash {REF}
##         : $laneHashRef                => The lane info hash {REF}
##         : $infilesLaneNoEndingHashRef => The infile(s) without the ".ending" {REF}
##         : $FILEHANDLE                 => Filehandle to write to
##         : $familyID                   => The familyID
##         : $sampleID                   => The sampleID
##         : $alignerOutDir              => The alignerOutDir used in the analysis
##         : $callType                   => The variant call type
##         : $programName                => The program name
##         : $reduceIORef                => Reduce IO - modulates processBlocks {REF}
    
    my ($argHashRef) = @_;
    
    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};
    
    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $laneHashRef = ${$argHashRef}{laneHashRef};
    my $infilesLaneNoEndingHashRef = ${$argHashRef}{infilesLaneNoEndingHashRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $sampleID = ${$argHashRef}{sampleID};
    my $inSampleDirectory = ${$argHashRef}{inSampleDirectory};
    my $reduceIORef = ${$argHashRef}{reduceIORef};
    my $programName = ${$argHashRef}{programName};

    ## Mandatory arguments
    my %mandatoryArgument = (parameterHashRef => ${$parameterHashRef}{MIP},  #Any MIP mandatory key will do
			     scriptParameterHashRef => ${$scriptParameterHashRef}{familyID},  #Any MIP mandatory key will do
			     sampleInfoHashRef => ${$sampleInfoHashRef}{ ${$scriptParameterHashRef}{familyID} },  #Any MIP mandatory key will do
			     fileInfoHashRef => ${$fileInfoHashRef}{contigs},  #Any MIP mandatory key will do
			     infilesLaneNoEndingHashRef => ${$infilesLaneNoEndingHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     laneHashRef => ${$laneHashRef}{ ${$scriptParameterHashRef}{sampleIDs}[0] },  #Any MIP mandatory key will do
			     FILEHANDLE => $FILEHANDLE,
			     reduceIORef => $$reduceIORef,
			     alignerOutDirRef => $$alignerOutDirRef,
			     programName => $programName,
	);
    
    &CheckMandatoryArguments(\%mandatoryArgument, $programName);
    
    my $vcfParserContigsArrayRef = \@{ ${$fileInfoHashRef}{contigsSizeOrdered} };  #Set default
    
    ## Last modules in each processing block that should have the output data deleted
    my $lastModuleBAMCalibrationBlock = "pGATKHaploTypeCaller";
    my $lastModuleVariantAnnotationBlock = "pSnpEff";
    
    foreach my $program (@{${$parameterHashRef}{dynamicParameters}{program}}) {

	if (${$scriptParameterHashRef}{$program} > 0) {

	    if ( (defined(${$parameterHashRef}{$program}{removeRedundantFiles})) && (${$parameterHashRef}{$program}{removeRedundantFiles} eq "yes")) {

		if (defined($sampleID)) {
		    
		    my $inDirectory =  ${$parameterHashRef}{$program}{$sampleID}{inDirectory};
		    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$sampleID}{$program}{fileTag};
		    
		    ## Single files
		    if (${$parameterHashRef}{$program}{removalSetting} eq "single") {  #Infiles for prior to potential merge
			
			for (my $infileCounter=0;$infileCounter < scalar( @{ ${$infilesLaneNoEndingHashRef}{$sampleID} });$infileCounter++) {
			    
			    my $infile = ${$infilesLaneNoEndingHashRef}{$sampleID}[$infileCounter]; 
			    
			    for (my $fileEndingCounter=0;$fileEndingCounter < scalar( @{ ${$parameterHashRef}{$program}{fileEnding} });$fileEndingCounter++) {

				my $filePath;
				
				if (defined($outfileTag)) {

				    $filePath = catfile($inDirectory, $infile.$outfileTag.${$parameterHashRef}{$program}{fileEnding}[$fileEndingCounter]);
				}
				else {

				    $filePath = catfile($inDirectory, $infile.${$parameterHashRef}{$program}{fileEnding}[$fileEndingCounter]);
				}

				my $mostCompleteRef;

				if (${$parameterHashRef}{$program}{fileEnding}[$fileEndingCounter]=~/vcf|bam/) {

				    ## Detect which mostCompletePath to use depending on fileEnding
				    $mostCompleteRef = &DetectMostCompleteFile({sampleInfoHashRef => $sampleInfoHashRef,
										fileEndingRef => \${$parameterHashRef}{$program}{fileEnding}[$fileEndingCounter],
										sampleIDRef => \$sampleID,
										familyIDRef => $familyIDRef,
									       });
				}
				## Checks if the file is recorded as the "MostCompleteBAM|VCF". If false writes removal of file(s) to supplied filehandle
				&CheckMostCompleteAndRemoveFile({FILEHANDLE => $FILEHANDLE, 
								 mostCompleteRef => $mostCompleteRef,
								 filePathRef => \$filePath,
								 fileEnding => ${$parameterHashRef}{$program}{fileEnding}[$fileEndingCounter],
								});		    
			    }
			}
		    }
		    ## Merged files
		    if (${$parameterHashRef}{$program}{removalSetting} eq "merged") {  #Merge infiles
			
			## Add merged infile name after merging all BAM files per sampleID
			my $infile = ${$fileInfoHashRef}{$$familyIDRef}{$sampleID}{MergeInfile};  #Alias
			
			if ( ( ! $$reduceIORef) || ($program eq $lastModuleBAMCalibrationBlock) ) {  #Delete intermediate files or last module in processBlock
			    
			    for (my $fileEndingCounter=0;$fileEndingCounter < scalar( @{ ${$parameterHashRef}{$program}{fileEnding} });$fileEndingCounter++) {
				
				## Process per contig
				for (my $contigsCounter=0;$contigsCounter<scalar(@{$vcfParserContigsArrayRef});$contigsCounter++) {
				    
				    my $contigRef = \${$vcfParserContigsArrayRef}[$contigsCounter];
				    
				    my $filePath = catfile($inDirectory, $infile.$outfileTag."_".$$contigRef.${$parameterHashRef}{$program}{fileEnding}[$fileEndingCounter]);
				    
				    ## Detect which mostCompletePath to use depending on fileEnding
				    my $mostCompleteRef = &DetectMostCompleteFile({sampleInfoHashRef => $sampleInfoHashRef,
										   fileEndingRef => \${$parameterHashRef}{$program}{fileEnding}[$fileEndingCounter],
										   sampleIDRef => \$sampleID,
										   familyIDRef => \${$scriptParameterHashRef}{familyID},
										  });
				    
				    ## Checks if the file is recorded as the "MostCompleteBAM|VCF". If false writes removal of file(s) to supplied filehandle
				    &CheckMostCompleteAndRemoveFile({FILEHANDLE => $FILEHANDLE, 
								     mostCompleteRef => $mostCompleteRef,
								     filePathRef => \$filePath,
								     fileEnding => ${$parameterHashRef}{$program}{fileEnding}[$fileEndingCounter],
								    });
				}
			    }
			}
		    }
		}
		else {  #Otherwise these files would be removed for every sampleID
		 
		    my $inDirectory =  ${$parameterHashRef}{$program}{inDirectory};
		    my $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$program}{fileTag};
		    
		    ## Family files
		    if (${$parameterHashRef}{$program}{removalSetting} eq "family") {
			
			for (my $fileEndingCounter=0;$fileEndingCounter < scalar( @{ ${$parameterHashRef}{$program}{fileEnding} });$fileEndingCounter++) {
			    
			    my $filePath = catfile($inDirectory, $$familyIDRef.$outfileTag.$callType."*".${$parameterHashRef}{$program}{fileEnding}[$fileEndingCounter]);
			    
			    ## Detect which mostCompletePath to use depending on fileEnding
			    my $mostCompleteRef = &DetectMostCompleteFile({sampleInfoHashRef => $sampleInfoHashRef,
									   fileEndingRef => \${$parameterHashRef}{$program}{fileEnding}[$fileEndingCounter],
									   familyIDRef => \${$scriptParameterHashRef}{familyID},
									  });
			    
			    ## Checks if the file is recorded as the "MostCompleteBAM|VCF". If false writes removal of file(s) to supplied filehandle
			    &CheckMostCompleteAndRemoveFile({FILEHANDLE => $FILEHANDLE, 
							     mostCompleteRef => $mostCompleteRef,
							     filePathRef => \$filePath,
							     fileEnding => ${$parameterHashRef}{$program}{fileEnding}[$fileEndingCounter],
							    });
			}
		    }
		    elsif (${$parameterHashRef}{$program}{removalSetting} eq "variantAnnotation") {
			
			if ( ( ! $$reduceIORef) || ($program eq $lastModuleVariantAnnotationBlock) ) {  #Delete intermediate files or last module in processBlock
			    
			    $outfileTag = ${$fileInfoHashRef}{$$familyIDRef}{$$familyIDRef}{$program}{fileTag};
			    
			    for (my $fileEndingCounter=0;$fileEndingCounter < scalar( @{ ${$parameterHashRef}{$program}{fileEnding} });$fileEndingCounter++) {
				
				my $filePath = catfile($inDirectory, $$familyIDRef.$outfileTag.$callType."*".${$parameterHashRef}{$program}{fileEnding}[$fileEndingCounter]);
				
				## Detect which mostCompletePath to use depending on fileEnding
				my $mostCompleteRef = &DetectMostCompleteFile({sampleInfoHashRef => $sampleInfoHashRef,
									       fileEndingRef => \${$parameterHashRef}{$program}{fileEnding}[$fileEndingCounter],
									       familyIDRef => \${$scriptParameterHashRef}{familyID},
									  });
				
				## Checks if the file is recorded as the "MostCompleteBAM|VCF". If false writes removal of file(s) to supplied filehandle
				&CheckMostCompleteAndRemoveFile({FILEHANDLE => $FILEHANDLE, 
								 mostCompleteRef => $mostCompleteRef,
								 filePathRef => \$filePath,
								 fileEnding => ${$parameterHashRef}{$program}{fileEnding}[$fileEndingCounter],
								});
			    }
			}
		    }
		}
	    }
	}
    }
}


sub DetectMostCompleteFile {

##DetectMostCompleteFile

##Function : Detect which mostCompletePath to use depending on fileEnding
##Returns  : ""
##Arguments: $scriptParameterHashRef,
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $fileEndingRef          => FileEnding (.fileEnding){REF}
##         : $familyIDRef            => Family ID {REF}
##         : $sampleIDRef            => Sample ID {REF}

    my ($argHashRef) = @_;
    
    ## Default(s)
    my $familyIDRef = ${$argHashRef}{familyIDRef} //= \${$argHashRef}{scriptParameterHashRef}{familyID};

    ## Flatten argument(s)
    my $sampleInfoHashRef = ${$argHashRef}{sampleInfoHashRef};
    my $fileEndingRef =  ${$argHashRef}{fileEndingRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    
    ## Mandatory arguments
    my %mandatoryArgument = (sampleInfoHashRef => ${$sampleInfoHashRef}{$$familyIDRef},  #Any MIP mandatory key will do
			     fileEnding => $$fileEndingRef,
			     familyIDRef=> $$familyIDRef,
	);
    
    &CheckMandatoryArguments(\%mandatoryArgument, "DetectMostCompleteFile");
    
    ## Set mostcompletePaths
    my $mostcompleteBamRef;
    my $mostcompleteVCFRef =  \${$sampleInfoHashRef}{$$familyIDRef}{$$familyIDRef}{VCFFile}{ReadyVcf}{Path};
    
    if (defined($$sampleIDRef)) {
	
	$mostcompleteBamRef = \${$sampleInfoHashRef}{$$familyIDRef}{$$sampleIDRef}{MostCompleteBAM}{Path};
    }
    ## Decide which mostcompletePaths to use
    if ($$fileEndingRef eq ".bam") {
	
	return $mostcompleteBamRef;
    }
    if ($$fileEndingRef eq ".vcf") {
	
	return $mostcompleteVCFRef;
    }
}


sub UpdateFileContigs {

##UpdateFileContigs
    
##Function : Removes contigY|chrY from SelectFileContigs if no males or 'other' found in analysis
##Returns  : ""
##Arguments: $selectFileContigsArrayRef, $hashKeyToSort, $hashKeySortReference
##         : $selectFileContigsArrayRef => The select file contigs {REF}
##         : $maleFoundRef              => If male or 'other' is included in current analysis {REF}

    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $selectFileContigsArrayRef;
    my $maleFoundRef;

    my $tmpl = { 
	selectFileContigsArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$selectFileContigsArrayRef},
	maleFoundRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$maleFoundRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    if ($$maleFoundRef != 1) {
	
	for (my $index=0;$index<scalar(@{$selectFileContigsArrayRef});$index++) {

	    if( (${$selectFileContigsArrayRef}[$index] eq "Y") || (${$selectFileContigsArrayRef}[$index] eq "chrY") ) {

		splice(@{$selectFileContigsArrayRef}, $index, 1);  #Remove $element from array
		last;  #Will not occur more than once
	    }
	}
    }
}


sub DetectFounders {

##DetectFounders
    
##Function : Detect number of founders (i.e. parents ) based on pedigree file
##Returns  : ""|1
##Arguments: $scriptParameterHashRef,
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef      => Info on samples and family hash {REF}

    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $sampleInfoHashRef;
    
    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	sampleInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$sampleInfoHashRef},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my @founders;
    my $founderCounter = 0;
    
    foreach my $sampleID (@{${$scriptParameterHashRef}{sampleIDs}}) {
	
	my $fatherInfo = ${$sampleInfoHashRef}{${$scriptParameterHashRef}{familyID} }{$sampleID}{Father};  #Alias
	my $motherInfo = ${$sampleInfoHashRef}{${$scriptParameterHashRef}{familyID} }{$sampleID}{Mother};  #Alias
	
	if ( (defined($fatherInfo)) && ($fatherInfo ne 0) ) {  #Child
	    
	    if (any {$_ eq $fatherInfo} @{${$scriptParameterHashRef}{sampleIDs}}) {  #If element is part of array
		
		push(@founders, $fatherInfo);
	    }
	}
	if ( (defined($motherInfo)) && ($motherInfo ne 0) ) {  #Child
	    
	    if (any {$_ eq $motherInfo} @{${$scriptParameterHashRef}{sampleIDs}} ) {  #If element is part of array
		
		push(@founders, $motherInfo);
	    }
	}
    }
    return scalar(@founders);
}


sub DetectTrio {

##DetectTrio
    
##Function : Detect family constellation based on pedigree file
##Returns  : ""|1
##Arguments: $scriptParameterHashRef, $sampleInfoHashRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $sampleInfoHashRef      => Info on samples and family hash {REF}

    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $sampleInfoHashRef;

    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	sampleInfoHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$sampleInfoHashRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my %trio;

    if (scalar(@{${$scriptParameterHashRef}{sampleIDs}}) eq 1) {

	$logger->info("Found single sample: ".${$scriptParameterHashRef}{sampleIDs}[0], "\n");
	return
    }
    elsif (scalar(@{${$scriptParameterHashRef}{sampleIDs}}) eq 3) {

	foreach my $sampleID (@{${$scriptParameterHashRef}{sampleIDs}}) {
    
	    my $fatherInfo = ${$sampleInfoHashRef}{${$scriptParameterHashRef}{familyID} }{$sampleID}{Father};  #Alias
	    my $motherInfo = ${$sampleInfoHashRef}{${$scriptParameterHashRef}{familyID} }{$sampleID}{Mother};  #Alias

	    if ( ($fatherInfo ne 0) && ($motherInfo ne 0) ) {  #Child
		
		$trio{child} = $sampleID;

		if (any {$_ eq $fatherInfo} @{${$scriptParameterHashRef}{sampleIDs}}) {  #If element is part of array
		    
		    $trio{father} = $fatherInfo;
		}
		if (any {$_ eq $motherInfo} @{${$scriptParameterHashRef}{sampleIDs}} ) {  #If element is part of array

		    $trio{mother} = $motherInfo;
		}
	    }
	}
	if (scalar(keys %trio) == 3) {

	    $logger->info("Found trio: Child = ".$trio{child}.", Father = ".$trio{father}.", Mother = ".$trio{mother}, "\n");
	    return 1
	}
    }
}


sub CheckString {

##CheckString
    
##Function : Detect "regExp" in string
##Returns  : ""|1
##Arguments: $string
##         : $string => String to be searched
##         : $regExp => RegExp to use on string

    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $string;
    my $regExp;
    
    my $tmpl = { 
	string => { required => 1, defined => 1, strict_type => 1, store => \$string},
	regExp => { required => 1, defined => 1, strict_type => 1, store => \$regExp},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    if ($string=~/$regExp/) {

	return 1
    }
}


sub AddToParameter {
    
##AddToParameter
    
##Function : Adds dynamic aggregate information from definitions to parameterHash
##Returns  : ""
##Arguments: $parameterHashRef, $aggregateArrayRef
##         : $parameterHashRef  => The parameter hash {REF}
##         : $aggregateArrayRef => The data to aggregate and add to parameter hash{REF}

    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $parameterHashRef;
    my $aggregateArrayRef;

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	aggregateArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$aggregateArrayRef},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    foreach my $key (keys %{$parameterHashRef}) {
	
	foreach my $aggregateElement (@{$aggregateArrayRef}) {

	    my @tmpArray = split(":", $aggregateElement);
	    my $secondkey = $tmpArray[0];
	    my $stringToMatch = $tmpArray[1];

	    if ( (defined(${$parameterHashRef}{$key}{$secondkey})) && (${$parameterHashRef}{$key}{$secondkey} eq $stringToMatch) ) {
		
		push(@{${$parameterHashRef}{dynamicParameters}{$stringToMatch}}, $key);
	    }
	}
    }
}


sub CheckPrioritizeVariantCallers {

##CheckPrioritizeVariantCallers
    
##Function : Check that all active variant callers have a prioritization order and that the prioritization elements match a supported variant caller.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef
##         : $parameterHashRef       => The parameter hash {REF}
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
    
    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;
    
    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
    };
     
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my @priorityCalls = split(",", ${$scriptParameterHashRef}{GATKCombineVariantsPrioritizeCaller});
    my @variantCallerAliases;  #No matching variant caller

    ## Check that all active variant callers have a priority order
    foreach my $variantCaller (@{${$parameterHashRef}{dynamicParameters}{variantCaller}}) {

	my $programOutDirectoryNameRef = \${$parameterHashRef}{$variantCaller}{outDirectoryName};
	push(@variantCallerAliases, $$programOutDirectoryNameRef);

	if (${$scriptParameterHashRef}{$variantCaller} > 0) { #Only active programs

	    if (! ( any {$_ eq $$programOutDirectoryNameRef} @priorityCalls ) ) {  #If element is not part of string

		$logger->fatal("GATKCombineVariantsPrioritizeCaller does not contain active variant caller: '".$$programOutDirectoryNameRef."'");
		exit 1;
	    }
	}
	if (${$scriptParameterHashRef}{$variantCaller} == 0) { #Only NOT active programs

	    if ( ( any {$_ eq $$programOutDirectoryNameRef} @priorityCalls ) ) {  #If element IS part of string

		$logger->fatal("GATKCombineVariantsPrioritizeCaller contains deactivated variant caller: '".$$programOutDirectoryNameRef."'");
		exit 1;
	    }
	}
    }
    ## Check that prioritize string contains valid variant call names
    foreach my $prioritizeCall (@priorityCalls) {
	
	if (! ( any {$_ eq $prioritizeCall} @variantCallerAliases ) ) {  #If element is not part of string
	    
	    $logger->fatal("GATKCombineVariantsPrioritizeCaller: '".$prioritizeCall."' does not match any supported variant caller: '".join(",", @variantCallerAliases)."'");
	    exit 1;
	}
    }
}

sub VcfToBcf {
    
##VcfToBcf
    
##Function : Compress vcf to bcf and index.
##Returns  : ""
##Arguments: $infile, $outfile, $FILEHANDLE
##         : $infile     => The file to compress and index (no fileEnding)
##         : $outfile    => Out file (no fileEnding)
##         : $FILEHANDLE => SBATCH script FILEHANDLE to print to
    
    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $infile = ${$argHashRef}{infile};
    my $outfile = ${$argHashRef}{outfile};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    
    ## Mandatory arguments
    my %mandatoryArgument = (infile => $infile,
			     FILEHANDLE => $FILEHANDLE,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "VcfToBcf");
    
    say $FILEHANDLE "## Compress vcf to bcf";
    print $FILEHANDLE "bcftools ";
    print $FILEHANDLE "view ";  #VCF/BCF conversion
    print $FILEHANDLE "-O b ";  #Output type - b: compressed BCF
    print $FILEHANDLE $infile.".vcf ";  #Infile

    if (defined($outfile)) {

	say $FILEHANDLE "> ".$outfile.".bcf", "\n";  #Outfile
    }
    else {

	say $FILEHANDLE "> ".$infile.".bcf", "\n";  #Outfile
    }
    
    say $FILEHANDLE "## Index bcf";
    print $FILEHANDLE "bcftools ";
    print $FILEHANDLE "index ";  #VCF/BCF conversion

    if (defined($outfile)) {
	
	say $FILEHANDLE $outfile.".bcf", "\n";  #Bcf file to index
    }
    else {
	
	say $FILEHANDLE $infile.".bcf", "\n";  #Bcf file to index
    }
}


sub PrepareGATKTargetIntervals {

##PrepareGATKTargetIntervals
    
##Function : Prepare target interval file. Copies file to temporary directory, and adds fileExtension to fit GATK 
##Returns  : "$targetIntervalsPath"
##Arguments: $analysisTypeRef, $targetIntervalFileListsRef, $referencesDirRef, $tempDirectoryRef, $FILEHANDLE
##         : $analysisTypeRef            => The analysis type {REF}
##         : $targetIntervalFileListsRef => Target interval list file {REF}
##         : $referencesDirRef           => Reference directory {REF}
##         : $tempDirectoryRef           => Temporary directory {REF}
##         : $FILEHANDLE                 => Filehandle to write to

    my ($argHashRef) = @_;

    ## Default(s)
    my $callType = ${$argHashRef}{callType} //= "BOTH";
    my $addEnding = ${$argHashRef}{addEnding} //= 1;
    
    ## Flatten argument(s)
    my $analysisTypeRef = ${$argHashRef}{analysisTypeRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef};
    my $targetIntervalFileListsRef = ${$argHashRef}{targetIntervalFileListsRef};
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef};
    ;

    if ( ($$analysisTypeRef eq "exomes") || ($$analysisTypeRef eq "rapid") ) { #Exome/rapid analysis
	
	## Mandatory arguments
	my %mandatoryArgument = (analysisTypeRef => $$analysisTypeRef,
				 referencesDirRef => $$referencesDirRef,
				 targetIntervalFileListsRef => $$targetIntervalFileListsRef,
				 tempDirectoryRef => $$tempDirectoryRef,
				 FILEHANDLE => $FILEHANDLE,
	    );
	
	&CheckMandatoryArguments(\%mandatoryArgument, "PrepareGATKTargetIntervals");

	my $targetIntervalsPath = catfile($$tempDirectoryRef, $$targetIntervalFileListsRef);
	
	## Copies file to temporary directory.
	&MigrateFileToTemp({FILEHANDLE => $FILEHANDLE,
			    path => catfile($$referencesDirRef, $$targetIntervalFileListsRef),
			    tempDirectory => $$tempDirectoryRef,
			   });
	say $FILEHANDLE "wait ";
	
	if ($addEnding == 1) {
	    
	    $targetIntervalsPath .= ".intervals";

	    ## Add the by GATK required ".interval" ending
	    print $FILEHANDLE "mv ";
	    print $FILEHANDLE catfile($$tempDirectoryRef, $$targetIntervalFileListsRef)." ";
	    say $FILEHANDLE catfile($$tempDirectoryRef, $$targetIntervalFileListsRef.".intervals")." ";
	}
	return $targetIntervalsPath;
    }
}


sub CheckAligner {
	
##CheckAligner

##Function : Check that the correct number of aligners is used in MIP and sets the alignerOutDir flag accordingly.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef, $broadcastsArrayRef, $alignerOutDirRef
##         : $parameterHashRef       => The parameter hash {REF}
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $broadcastsArrayRef     => Holds the parameters info for broadcasting later {REF}
##         : $alignerOutDirRef       => The alignerOutDir used in the analysis {REF}

    my ($argHashRef) = @_;

    ## Default(s)
    my $alignerOutDirRef = ${$argHashRef}{alignerOutDirRef} //= \${$argHashRef}{scriptParameterHashRef}{alignerOutDir};

    ## Flatten argument(s)
    my $parameterHashRef;
    my $scriptParameterHashRef;
    my $broadcastsArrayRef;

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	broadcastsArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$broadcastsArrayRef},
	alignerOutDirRef => { default => \$$, strict_type => 1},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my %aligner;

    foreach my $aligner (@{${$parameterHashRef}{dynamicParameters}{aligner}}) {
	
	if (${$scriptParameterHashRef}{$aligner} > 0) {  #Active aligner    
	    
	    $aligner{totalActiveAlignerCount}++;
	    push(@{$aligner{activeAligners}}, $aligner);
	    ${$parameterHashRef}{activeAligner} = $aligner;  #Save the active aligner for downstream use
	    
	    if ($$alignerOutDirRef eq "notSetYet") {

		$$alignerOutDirRef = ${$parameterHashRef}{$aligner}{outDirectoryName};  #Set alignerOutDir parameter depending on active aligner

		my $info = "Set alignerOutDir to: ".$$alignerOutDirRef;
		push(@{$broadcastsArrayRef}, $info);  #Add info to broadcasts
	    }
	}
    }
    if ($aligner{totalActiveAlignerCount} > 1) {

	$logger->fatal($USAGE, "\n");
	$logger->fatal("You have activate more than 1 aligner: ".join(", ", @{$aligner{activeAligners}}).". MIP currently only supports 1 aligner per analysis.", "\n");
	exit 1;
    } 
}


sub CNVnatorHis {

##CNVnatorHis

##Function : Generates a histogram
##Returns  : ""
##Arguments: $rootFile, $contigRef, $cnvBinSizeRef, $chromosomeReference, $FILEHANDLE, $stdoutfile , $stderrFile
##         : $rootFile            => The root file
##         : $contigRef           => Contig to analyze {REF}
##         : $cnvBinSizeRef       => The cnvnator bin size {REF}
##         : $chromosomeReference => The chrmosome reference X.fa file
##         : $FILEHANDLE          => Filehandle to write to
##         : $stdoutfile          => The stdout output file
##         : $stderrFile          => The stderr output file
  
    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $rootFile = ${$argHashRef}{rootFile};
    my $contigRef = ${$argHashRef}{contigRef};
    my $cnvBinSizeRef = ${$argHashRef}{cnvBinSizeRef};
    my $chromosomeReference = ${$argHashRef}{chromosomeReference};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $stdoutfile = ${$argHashRef}{stdoutfile};
    my $stderrFile = ${$argHashRef}{stderrFile};

    ## Mandatory arguments
    my %mandatoryArgument = (rootFile => $rootFile,
			     contigRef => $$contigRef,
			     cnvBinSizeRef => $$cnvBinSizeRef,
			     chromosomeReference => $chromosomeReference,
			     FILEHANDLE => $FILEHANDLE,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "CNVnatorHis");
    
    print $FILEHANDLE "cnvnator "; 
    print $FILEHANDLE "-root ".$rootFile." ";  #ROOT file
    print $FILEHANDLE "-chrom ".$$contigRef." ";  #chromosome name
    print $FILEHANDLE "-his ".$$cnvBinSizeRef." ";
    print $FILEHANDLE "-d ".$chromosomeReference." ";
    
    if (defined($stdoutfile)) {
	
	print $FILEHANDLE "1>> ".$stdoutfile." ";
    }
    if (defined($stderrFile)) {
	
	print $FILEHANDLE "2>> ".$stderrFile." ";
    }
    print $FILEHANDLE "; ";
    
}

sub CNVnatorStat {

##CNVnatorStat

##Function : Calculates statistics
##Returns  : ""
##Arguments: $rootFile, $contigRef, $cnvBinSizeRef, $chromosomeReference, $FILEHANDLE, $stdoutfile, $stderrFile
##         : $rootFile      => The root file
##         : $contigRef     => Contig to analyze {REF}
##         : $cnvBinSizeRef => The cnvnator bin size {REF}
##         : $FILEHANDLE    => Filehandle to write to
##         : $stdoutfile    => The stdout output file
##         : $stderrFile    => The stderr output file

    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $rootFile = ${$argHashRef}{rootFile};
    my $contigRef = ${$argHashRef}{contigRef};
    my $cnvBinSizeRef = ${$argHashRef}{cnvBinSizeRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $stdoutfile = ${$argHashRef}{stdoutfile};
    my $stderrFile = ${$argHashRef}{stderrFile};
    
    ## Mandatory arguments
    my %mandatoryArgument = (rootFile => $rootFile,
			     contigRef => $$contigRef,
			     cnvBinSizeRef => $$cnvBinSizeRef,
			     FILEHANDLE => $FILEHANDLE,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "CNVnatorStat");

    print $FILEHANDLE "cnvnator "; 
    print $FILEHANDLE "-root ".$rootFile." ";  #ROOT file
    print $FILEHANDLE "-chrom ".$$contigRef." ";  #chromosome name
    print $FILEHANDLE "-stat ".$$cnvBinSizeRef." ";
    
    if (defined($stdoutfile)) {
	
	print $FILEHANDLE "1>> ".$stdoutfile." ";
    }
    if (defined($stderrFile)) {
	
	print $FILEHANDLE "2> ".$stderrFile." ";
    }
    print $FILEHANDLE "; ";
}

sub CNVnatorPartition {

##CNVnatorPartition

##Function : Read depth signal partioning
##Returns  : ""
##Arguments: $rootFile, $contigRef, $cnvBinSizeRef, $chromosomeReference, $FILEHANDLE, $stdoutfile, $stderrFile
##         : $rootFile      => The root file
##         : $contigRef     => Contig to analyze {REF}
##         : $cnvBinSizeRef => The cnvnator bin size {REF}
##         : $FILEHANDLE    => Filehandle to write to
##         : $stdoutfile    => The stdout output file
##         : $stderrFile    => The stderr output file
    
    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $rootFile = ${$argHashRef}{rootFile};
    my $contigRef = ${$argHashRef}{contigRef};
    my $cnvBinSizeRef = ${$argHashRef}{cnvBinSizeRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $stdoutfile = ${$argHashRef}{stdoutfile};
    my $stderrFile = ${$argHashRef}{stderrFile};
    
    ## Mandatory arguments
    my %mandatoryArgument = (rootFile => $rootFile,
			     contigRef => $$contigRef,
			     cnvBinSizeRef => $$cnvBinSizeRef,
			     FILEHANDLE => $FILEHANDLE,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "CNVnatorPartition");

    print $FILEHANDLE "cnvnator "; 
    print $FILEHANDLE "-root ".$rootFile." ";  #ROOT file
    print $FILEHANDLE "-chrom ".$$contigRef." ";  #chromosome name
    print $FILEHANDLE "-partition ".$$cnvBinSizeRef." ";
    
    if (defined($stdoutfile)) {
	
	print $FILEHANDLE "1>> ".$stdoutfile." ";
    }
    if (defined($stderrFile)) {
	
	print $FILEHANDLE "2>> ".$stderrFile." ";
    }
    print $FILEHANDLE "; ";
}

sub CNVnatorCalling {

##CNVnatorCalling

##Function : CNV Calling
##Returns  : ""
##Arguments: $rootFile, $contigRef, $cnvBinSizeRef, $chromosomeReference, $FILEHANDLE, $stderrFile
##         : $rootFile            => The root file
##         : $contigRef           => Contig to analyze {REF}
##         : $cnvBinSizeRef       => The cnvnator bin size {REF}
##         : $chromosomeReference => The chrmosome reference X.fa file
##         : $FILEHANDLE          => Filehandle to write to
##         : $stderrFile          => The stderr output file
##         : $outfile             => The outfile
   
    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $rootFile = ${$argHashRef}{rootFile};
    my $contigRef = ${$argHashRef}{contigRef};
    my $cnvBinSizeRef = ${$argHashRef}{cnvBinSizeRef};
    my $chromosomeReference = ${$argHashRef}{chromosomeReference};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $stderrFile = ${$argHashRef}{stderrFile};
    my $outfile = ${$argHashRef}{outfile};

    ## Mandatory arguments
    my %mandatoryArgument = (rootFile => $rootFile,
			     contigRef => $$contigRef,
			     cnvBinSizeRef => $$cnvBinSizeRef,
			     chromosomeReference => $chromosomeReference,
			     FILEHANDLE => $FILEHANDLE,
			     outfile => $outfile,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "CNVnatorCalling");
    
    print $FILEHANDLE "cnvnator "; 
    print $FILEHANDLE "-root ".$rootFile." ";  #ROOT file
    print $FILEHANDLE "-chrom ".$$contigRef." ";  #chromosome name
    print $FILEHANDLE "-call ".$$cnvBinSizeRef." ";
    
    if (defined($stderrFile)) {
	
	print $FILEHANDLE "2> ".$stderrFile." ";
    }
    print $FILEHANDLE "> ".$outfile.".tmp ";
    print $FILEHANDLE "; ";
    
    ## Convert to vcf
    print $FILEHANDLE "cnvnator2VCF.pl ";
    print $FILEHANDLE $outfile.".tmp ";  #Infile
    print $FILEHANDLE $chromosomeReference." ";
    print $FILEHANDLE "> ".$outfile;
}


sub RenameVCFSamples {

##RenameVCFSamples

##Function : Rename vcf samples. The samples array will replace the sample names in the same order as supplied.
##Returns  : ""
##Arguments: $sampleIDArrayRef, $tempDirectoryRef, $infile, $outfile, $FILEHANDLE
##         : $sampleIDArrayRef => Samples to rename in the same order as in the vcf {REF}
##         : $tempDirectoryRef => Temporary directory {REF}
##         : $infile           => The vcf infile to rename samples for
##         : $outfile          => Output vcf with samples renamed
##         : $FILEHANDLE       => Filehandle to write to

     my ($argHashRef) = @_;

     my $sampleIDArrayRef = ${$argHashRef}{sampleIDArrayRef};
     my $tempDirectoryRef =  ${$argHashRef}{tempDirectoryRef};
     my $infile = ${$argHashRef}{infile};
     my $outfile = ${$argHashRef}{outfile};
     my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

     ## Mandatory arguments
     my %mandatoryArgument = (sampleIDArrayRef => ${$sampleIDArrayRef}[0],
			      tempDirectoryRef => $$tempDirectoryRef,
			      infile => $infile,
			      outfile => $outfile,
			      $FILEHANDLE => $FILEHANDLE,
	 );
     &CheckMandatoryArguments(\%mandatoryArgument, "RenameVCFSamples");

     ## Create new sample names file
     say $FILEHANDLE "## Create new sample(s) names file";
     print $FILEHANDLE q?printf "?;

     foreach my $sampleID (@{$sampleIDArrayRef}) {

	 print $FILEHANDLE $sampleID.q?\n?;
     }
     print $FILEHANDLE q?" ?;
     say $FILEHANDLE "> ".catfile($$tempDirectoryRef, "sample_name.txt")." ";
     
     ## Rename samples in VCF
     say $FILEHANDLE "## Rename sample(s) names ion VCF file";
     print $FILEHANDLE "bcftools ";
     print $FILEHANDLE "reheader ";  #Modify header of VCF/BCF files, change sample names.
     print $FILEHANDLE "-s ";  #New sample names
     print $FILEHANDLE catfile($$tempDirectoryRef, "sample_name.txt")." ";
     print $FILEHANDLE " ".$infile." ";  #Infile
     say $FILEHANDLE "> ".$outfile." ";
     say $FILEHANDLE "\n";
}


sub RemoveElementFromArray {

##RemoveElementFromArray
    
##Function : Removes an element from array and return new array while leaving orginal arrayRef untouched. 
##Returns  : "Array"
##Tags     : helper, remove, ARRAY, contigs
##Arguments: $arrayRef, $element, $contigSwitch
##         : $arrayRef => Array to remove an element from {REF}
##         : $element  => Element to remove
##         : $contigSwitch => Expect contigs in arrayRef

    my ($argHashRef) = @_;

    my $arrayRef = ${$argHashRef}{arrayRef};
    my $element = ${$argHashRef}{element};
    my $contigSwitch = ${$argHashRef}{contigSwitch};

    my @array = @{$arrayRef};  #Make local copy

    for (my $index=0;$index<scalar(@array);$index++) {

	if($contigSwitch) {  #Make sure that contig is removed independent of genome source
	    
	    if( (${$arrayRef}[$index] eq $element) || (${$arrayRef}[$index] eq "chr".$element) ) {
		
		splice(@array, $index, 1);  #Remove $element from array
	    }
	}
	elsif( (${$arrayRef}[$index] eq $element) ) {  #Arbitrary element from array
	    
	    splice(@array, $index, 1);  #Remove $element from array
	}
    }
    return @array
}


sub CollectReadLength {

##CollectReadLength
    
##Function : Collect read length from an infile
##Returns  : "readLength"
##Arguments: $directory, $readFile, $file
##         : $directory => Directory of file
##         : $readFile  => Command used to read file
##         : $file      => File to parse

    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $directory;
    my $readFileCommand;
    my $file;
    
    my $tmpl = { 
	directory => { required => 1, defined => 1, strict_type => 1, store => \$directory},
	readFileCommand => { required => 1, defined => 1, strict_type => 1, store => \$readFileCommand},
	file => { required => 1, defined => 1, strict_type => 1, store => \$file},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my $seqLengthRegExp = q?perl -ne 'if ($_!~/@/) {chomp($_);my $seqLength = length($_);print $seqLength;last;}' ?;  #Prints sequence length and exits
    
    my $pwd = cwd();  #Save current direcory
    chdir($directory);  #Move to sampleID infile directory

    my $ret = `$readFileCommand $file | $seqLengthRegExp;`;  #Collect sequence length
    return $ret;
}


sub TrackProgress {

##TrackProgress
    
##Function : Output SLURM info on each job via Sacct command and write to MIP Log file(.status)
##Returns  : ""
##Arguments: $jobIDHashRef, $FILEHANDLE, $logFileRef
##         : $jobIDHashRef => The jobID hash {REF}
##         : $FILEHANDLE   => Sbatch filehandle to write to
##         : $logFileRef   => The log file {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $jobIDHashRef = ${$argHashRef}{jobIDHashRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $logFileRef = ${$argHashRef}{logFileRef};

    if (keys %{$jobIDHashRef}) {
	
	print $FILEHANDLE "\t".q?sacct --format=jobid,jobname%50,account,partition,alloccpus,TotalCPU,elapsed,start,end,state,exitcode -j ?;
	print $FILEHANDLE join(',', @{${$jobIDHashRef}{Pan}{Pan}}), " ";
	print $FILEHANDLE q?| ?;
	print $FILEHANDLE q?perl -nae 'my @headers=(jobid,jobname,account,partition,alloccpus,TotalCPU,elapsed,start,end,state,exitcode); if($. == 1) {print "#".join("\t", @headers), "\n"} if ($.>=3 && $F[0]!~/.batch/) {print join("\t", @F), "\n"}' ?;
	say $FILEHANDLE q?> ?.$$logFileRef.".status";
    }
}

sub PrintProgram {

##PrintProgram

##Function : Print all supported programs in '-ppm' mode
##Returns  : ""
##Arguments: $parameterHashRef, $printProgramMode
##         : $parameterHashRef => The parameter hash {REF}
##         : $printProgramMode => Mode to run modules in

    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $parameterHashRef;
    my $printProgramMode = ${$argHashRef}{printProgramMode} //= 2;

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	printProgramMode => { strict_type => 1, allow => [0, 1, 2]},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];    

    &AddToParameter({parameterHashRef => $parameterHashRef,
		     aggregateArrayRef => ["type:program"],
		    });

    my @orderParameters;

    ## Adds the order of first level keys from yaml file to array
    &OrderParameterNames({orderParametersArrayRef => \@orderParameters,
			  filePath => catfile($Bin, "definitions", "defineParameters.yaml"),
			 });

    foreach my $orderParameterElement (@orderParameters) {
	
	if ( ( any {$_ eq $orderParameterElement} @{${$parameterHashRef}{dynamicParameters}{program}} ) ) { #Only process programs
	    
	    unless ($orderParameterElement=~/pMadeline|pMosaik|pBwaSampe|pBwaAln|pPicardToolsMergeRapidReads|pBAMCalibrationBlock|pVariantAnnotationBlock|pAnnovar/) {

		print STDOUT "--".$orderParameterElement." ".$printProgramMode." ";
	    }
	}
    }
    print STDOUT "\n";
}


sub CheckProgramMode {

##CheckProgramMode

##Function : Check correct value for program mode in MIP.
##Returns  : ""
##Arguments: $parameterHashRef, $scriptParameterHashRef
##         : $parameterHashRef       => The parameter hash {REF}
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $parameterHashRef = ${$argHashRef}{parameterHashRef};
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};

    my $tmpl = { 
	parameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$parameterHashRef},
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my @allowedValues = (0, 1, 2);

    foreach my $program (@{${$parameterHashRef}{dynamicParameters}{program}}) {

	if (! ( any {$_ eq ${$scriptParameterHashRef}{$program}} @allowedValues ) ) { #If element is not part of array
	    
	    $logger->fatal("'".${$scriptParameterHashRef}{$program}."' Is not an allowed mode for program '--".$program."'. Set to: ".join("|", @allowedValues));
	    exit 1;
	}
    }
}


sub Help {

##Help
    
##Function : Print help text and exit with supplied exit code
##Returns  : ""
##Arguments: $USAGE, $exitCode
##         : $USAGE    => Help text
##         : $exitCode => Exit code

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $USAGE;
    my $exitCode;

    my $tmpl = { 
	USAGE => {required => 1, defined => 1, strict_type => 1, store => \$USAGE},
	exitCode => { default => 0, strict_type => 1, store => \$exitCode},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];    
    
    say STDOUT $USAGE;
    exit $exitCode;
}


sub SelectBwaMemBinary {
    
##SelectBwaMemBinary
    
##Function : Detect version and source of the humanGenomeReference: Source (hg19 or GRCh) and return the correct BwaMem binary
##Returns  : ""
##Arguments: $humanGenomeReferenceSource, $humanGenomeReferenceVersion
##         : $humanGenomeReferenceSource  => Human genome reference source {REF}
##         : $humanGenomeReferenceVersion => Human genome reference version {REF}
    
    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $humanGenomeReferenceSourceRef = ${$argHashRef}{humanGenomeReferenceSourceRef};
    my $humanGenomeReferenceVersionRef = ${$argHashRef}{humanGenomeReferenceVersionRef};
    
    if($humanGenomeReferenceSourceRef eq "GRCh") {
	
	if ($humanGenomeReferenceVersionRef > 37) {
	    
	    return "run-bwamem";
	}
	else {  #HumanGenome version lesser than GrCh37
			
	    return "bwa mem";
	}
    }
    else {  #hgXX build
	
	if ($humanGenomeReferenceVersionRef > 19) {
	    
	    return "run-bwamem";
	}
	else {  #HumanGenome version lesser than hg19
	    
	    return "bwa mem";
	}
    }    
}


sub UpdateExomeTargetBed {

##UpdateExomeTargetBed
    
##Function : Update exomeTargetBed files with humanGenomeReferenceSourceRef and humanGenomeReferenceVersionRef
##Returns  : "" 
##Arguments: $exomeTargetBedFileHashRef, $humanGenomeReferenceSourceRef, humanGenomeReferenceVersionRef
##         : $exomeTargetBedFileHashRef     => ExomeTargetBedTestFile hash {REF}
##         : humanGenomeReferenceSourceRef  => The human genome reference source {REF}
##         : humanGenomeReferenceVersionRef => The human genome reference version {REF}

    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $exomeTargetBedFileHashRef;
    my $humanGenomeReferenceSourceRef;
    my $humanGenomeReferenceVersionRef;
    
    my $tmpl = { 
	exomeTargetBedFileHashRef => { required => 1, store => \$exomeTargetBedFileHashRef},
	humanGenomeReferenceSourceRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$humanGenomeReferenceSourceRef},
	humanGenomeReferenceVersionRef => { required => 1, defined => 1, default => \$$, strict_type => 1, store => \$humanGenomeReferenceVersionRef},
    };
    
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    foreach my $exomeTargetBedFile (keys %{$exomeTargetBedFileHashRef}) {
	
	my $originalFileName = $exomeTargetBedFile;

	if ( ($exomeTargetBedFile =~ s/GenomeReferenceSource/$$humanGenomeReferenceSourceRef/) && ($exomeTargetBedFile =~ s/Version/$$humanGenomeReferenceVersionRef/) ){  #Replace with actual version 
	    
	    ${$exomeTargetBedFileHashRef}{$exomeTargetBedFile} = delete(${$exomeTargetBedFileHashRef}{$originalFileName});  #The delete operator returns the value being deleted i.e. updating hash key while preserving original info
	}
    }
}


sub CheckSampleIDInExomeTargetBed {

##CheckSampleIDInExomeTargetBed
    
##Function : Check sampleID provided in exomeTargetBed is included in the analysis and only represented once
##Returns  : "" 
##Tags     : check, sampleids, capturekit
##Arguments: $scriptParameterHashRef, $sampleIdArrayRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $sampleIDArrayRef       => Array to loop in for parameter {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef;
    my $sampleIdArrayRef;
    
    my $tmpl = { 
	scriptParameterHashRef => { required => 1, defined => 1, default => {}, strict_type => 1, store => \$scriptParameterHashRef},
	sampleIdArrayRef => { required => 1, defined => 1, default => [], strict_type => 1, store => \$sampleIdArrayRef},
    };
        
    check($tmpl, $argHashRef, 1) or die qw[Could not parse arguments!];

    my %seen;  #Hash to test duplicate sampleIDs later

    foreach my $exomeTargetBedFile (keys %{${$scriptParameterHashRef}{exomeTargetBed}} ) {

	my @captureKitSamples = split(",", ${$scriptParameterHashRef}{exomeTargetBed}{$exomeTargetBedFile});

	foreach my $sampleID (@captureKitSamples) {

	    $seen{ $sampleID }++;  #Increment instance to check duplicates later

	    if ( ! (any {$_ eq $sampleID} @{$sampleIdArrayRef}) ) {  #If captureKit sampleID supplied is not part of sampleID array
		
		$logger->fatal("Could not detect ".$sampleID." from '-exomeTargetBed' in provided sampleIDs: ".join(", ", @{$sampleIdArrayRef}), "\n");
		exit 1;
	    }
	    if ($seen{ $sampleID } > 1) {  #Check sampleID are unique
		
		$logger->fatal("SampleID: ".$sampleID." is not uniqe in '-exomeTargetBed '".$exomeTargetBedFile."=".join(",", @captureKitSamples),"\n");
		exit 1;
	    }
	}
    }
    foreach my $sampleID (@{$sampleIdArrayRef}) {

	if ( ! (any {$_ eq $sampleID} (keys %seen)) ) {  #If sampleID is not present in exomeTargetBed
	    
	    $logger->fatal("Could not detect ".$sampleID." for '-exomeTargetBed'. Provided sampleIDs are: ".join(", ", (keys %seen)), "\n");
	    exit 1;
	}
    }
}


sub GetExomTargetBEDFile {

##GetExomTargetBEDFile
    
##Function : Get exomeTargetBed file for specfic sampleID and add fileEnding from fileInfoHash if supplied
##Returns  : "exomeTargetBedFile(fileEnding)" 
##Tags     : get, capturekit, sampleids
##Arguments: $scriptParameterHashRef, $sampleIDRef, $fileEndingRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $sampleIDRef            => The sampleID {REF}
##         : $fileEndingRef          => File ending to add to file {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $sampleIDRef = ${$argHashRef}{sampleIDRef};
    my $fileEndingRef = ${$argHashRef}{fileEndingRef};

    my %seen;

    foreach my $exomeTargetBedFile (keys %{${$scriptParameterHashRef}{exomeTargetBed}}) {
	
	my @captureKitSamples = split(",", ${$scriptParameterHashRef}{exomeTargetBed}{$exomeTargetBedFile});

	map { $seen{$_}++ } (@captureKitSamples);  #Count number of times sampleID has been seen

	if (any {$_ eq $$sampleIDRef} @captureKitSamples) {  #If captureKit sampleID is associated with exomeTargetBedFile
	    
	    if (defined($$fileEndingRef)) {

		$exomeTargetBedFile .= $$fileEndingRef;
	    }
	    return $exomeTargetBedFile;
	}
    }
    if ( ! defined($seen{$$sampleIDRef})) {

	$logger->fatal("Could not detect ".$sampleIDRef." in '-exomeTargetBed' associated files in sub routine GetExomTargetBEDFile", "\n");
	exit 1;
    }
}


sub SambambaFlagStat {

##SambambaFlagStat
    
##Function : Process BAM with sambamba flagstat to produce metric file for downstream analysis
##Returns  : "|$xargsFileCounter"
##Arguments: $infilePath, $outfilePath, $stderrFilePath, $FILEHANDLE
##         : $FILEHANDLE => Sbatch filehandle to write to
##         : $infilePath     => Infile path
##         : $outfilePath    => outfile path 
##         : $stderrFilePath => Stderr file path to write to 

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $infilePath = ${$argHashRef}{infilePath};
    my $outfilePath = ${$argHashRef}{outfilePath};
    my $stderrFilePath = ${$argHashRef}{stderrFilePath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    ## Mandatory arguments
    my %mandatoryArgument = (infilePath => $infilePath,
			     outfilePath => $outfilePath,
			     stderrFilePath => $stderrFilePath,
			     FILEHANDLE => $FILEHANDLE,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "SambambaFlagStat");

    print $FILEHANDLE "sambamba ";  #Program
    print $FILEHANDLE "flagstat ";
    print $FILEHANDLE catfile($infilePath)." ";  #OutFile
    print $FILEHANDLE "> ".catfile($outfilePath)." ";  #Metric file 
    say $FILEHANDLE "2>> ".$stderrFilePath, "\n";  #Redirect xargs output to program specific stderr file
}


sub AliasAssemblyVersion {
    
##AliasAssemblyVersion
    
##Function : Alias genome source and version to be compatible with VEP
##Returns  : "$$assemblyVersionRef"
##Arguments: $assemblyVersionRef
##         : $assemblyVersionRef => The genome source and version to be checked
    
    my ($argHashRef) = @_;
    
    ## Flatten argument(s)
    my $assemblyVersionRef = ${$argHashRef}{assemblyVersion};
    
    if ($$assemblyVersionRef=~/hg(\d+)/) {
	
	my $versionNumber = $1;
	if ($versionNumber > 20) {
	    
	    $$assemblyVersionRef = "GRCh".$versionNumber;
	}
    }
}


sub GenerateContigSpecificTargetBedFile {
    
##GenerateContigSpecificTargetBedFile
    
##Function : Generate contig specific interval_list
##Returns  : ""
##Arguments: $scriptParameterHashRef, $fileInfoHashRef, $FILEHANDLE, $exomeTargetBedFile
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $fileInfoHashRef        => The fileInfo hash {REF}
##         : $FILEHANDLE             => Filehandle to write to
##         : $exomeTargetBedFile     => Target file to split
##         : $fileEnding      => File ending to add
    
    my ($argHashRef) = @_;
    
    ## Default(s)
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};
    
    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $fileInfoHashRef = ${$argHashRef}{fileInfoHashRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $exomeTargetBedFileRef = ${$argHashRef}{exomeTargetBedFileRef};
    my $fileEnding = ${$argHashRef}{fileEnding};
    
    my $nrCores = ${$scriptParameterHashRef}{maximumCores};
    my $coreCounter = 1;
    say $FILEHANDLE "## Generate contig specific interval_list\n"; 
    for (my $contigsCounter=0;$contigsCounter<scalar(@{${$fileInfoHashRef}{contigsSizeOrdered}});$contigsCounter++) {
	
	my $contigRef = \${$fileInfoHashRef}{contigsSizeOrdered}[$contigsCounter];
	
	&PrintWait({counterRef => \$contigsCounter,
		    nrCoresRef => \$nrCores,
		    coreCounterRef => \$coreCounter,
		    FILEHANDLE => $FILEHANDLE,
		   });
	
	## Splits a target file into new contig specific target file
	&SplitTargetFile({FILEHANDLE => $FILEHANDLE,
			  inDirectoryRef => $referencesDirRef,
			  outDirectoryRef => $tempDirectoryRef,
			  infileRef => $exomeTargetBedFileRef,
			  contigRef => $contigRef,
			  fileEnding => $fileEnding,
			 });
    }
    say $FILEHANDLE "wait", "\n";
}


sub ReplaceIUPAC {

##ReplaceIUPAC
    
##Function : Replace the IUPAC code in alternative allels with N for input stream and writes to stream.
##Returns  : ""
##Arguments: $stderrPath, $FILEHANDLE, $xargs
##         : $stderrPath => Stderr path to errors write to
##         : $FILEHANDLE => Sbatch filehandle to write to
##         : $xargs      => Write on xargs format

    my ($argHashRef) = @_;

    ## Default(s)
    my $xargs = ${$argHashRef}{xargs} //= 1;

    ## Flatten argument(s)
    my $stderrPath = ${$argHashRef}{stderrPath};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};

    ## Mandatory arguments
    my %mandatoryArgument = (FILEHANDLE => $FILEHANDLE,
	);
    &CheckMandatoryArguments(\%mandatoryArgument, "ReplaceIUPAC");

    print $FILEHANDLE "| ";  #Pipe
    print $FILEHANDLE "perl -nae ";

    if ($xargs == 1) {  #Add escape char

	print $FILEHANDLE q?\'if($_=~/^#/) {print $_;} else { @F[4] =~ s/W|K|Y|R|S|M/N/g; print join(\"\\\t\", @F), \"\\\n\"; }\' ?;  #substitute IUPAC code with N to not break vcf specifications (GRCh38)
    }
    else {

	print $FILEHANDLE q?'if($_=~/^#/) {print $_;} else { @F[4] =~ s/W|K|Y|R|S|M/N/g; print join("\t", @F), "\n"; }' ?;  #substitute IUPAC code with N to not break vcf specifications (GRCh38)
    }
    if ($stderrPath) {

	print $FILEHANDLE "2>> ".$stderrPath." ";  #Redirect output to program specific stderr file
    }
}


##Investigate potential autodie error
if ($@ and $@->isa("autodie::exception")) {
    
    if ($@->matches("default")) {
	
	say "Not an autodie error at all";
    }
    if ($@->matches("open")) { 

	say "Error from open";
    }
    if ($@->matches(":io" )) {

	say "Non-open, IO error.\n";
    }
}
elsif ($@) {

    say "A non-autodie exception.";
}

####
#Decommissioned
####


sub MergeTargetListFlag {

##MergeTargetListFlag
    
##Function : Detects if there are different capture kits across sampleIDs. Creates a temporary merged interval_list for all interval_list that have been supplied and returns temporary list.
##Returns  : "Filepath"
##Arguments: $scriptParameterHashRef, $FILEHANDLE, $contigRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $FILEHANDLE             => FILEHANDLE to write to
##         : $contigRef              => The contig to extract {REF}

    my ($argHashRef) = @_;

    ## Default(s)
    my $tempDirectoryRef = ${$argHashRef}{tempDirectoryRef} //= \${$argHashRef}{scriptParameterHashRef}{tempDirectory};
    my $referencesDirRef = ${$argHashRef}{referencesDirRef} //= \${$argHashRef}{scriptParameterHashRef}{referencesDir};

    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    
    ##Determine file to print to module (untouched/merged and/or splited)
    my $outDirectory = ${$scriptParameterHashRef}{tempDirectory};  #For merged and/or splitet

    if (scalar(keys %{${$scriptParameterHashRef}{exomeTargetBed}}) > 1) {  #Merge files
	
	say $FILEHANDLE "\n## Generate merged interval_list\n";
	
	&JavaCore({FILEHANDLE => $FILEHANDLE,
		   memoryAllocation => "Xmx2g",
		   javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		   javaTemporaryDirectory => $$tempDirectoryRef,
		   javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
		  });
	
	print $FILEHANDLE "IntervalListTools ";
	print $FILEHANDLE "UNIQUE=TRUE ";  #Merge overlapping and adjacent intervals to create a list of unique intervals
	
	foreach my $targetFile (keys %{${$scriptParameterHashRef}{exomeTargetBed}}) {
	    
	    print $FILEHANDLE "INPUT=".catfile($$referencesDirRef, $targetFile)." ";
	}
	say $FILEHANDLE "OUTPUT=".catfile($$tempDirectoryRef, "merged.interval_list"), "\n";  #Merged outfile
    }
}


sub GATKTargetListFlag {

##GATKTargetListFlag
    
##Function : Detects if there are different capture kits across sampleIDs. Creates a temporary merged interval_list for all interval_list that have been supplied and returns temporary list. Will also extract specific contigs if requested and return that list if enabled.
##Returns  : "Filepath"
##Arguments: $scriptParameterHashRef, $FILEHANDLE, $contigRef
##         : $scriptParameterHashRef => The active parameters for this analysis hash {REF}
##         : $FILEHANDLE             => FILEHANDLE to write to
##         : $contigRef              => The contig to extract {REF}

    my ($argHashRef) = @_;

    ## Flatten argument(s)
    my $scriptParameterHashRef = ${$argHashRef}{scriptParameterHashRef};
    my $FILEHANDLE = ${$argHashRef}{FILEHANDLE};
    my $contigRef = ${$argHashRef}{contigRef};

    my %GATKTargetPaddedBedIntervalListTracker;
    my @GATKTargetPaddedBedIntervalListFiles;

    for (my $sampleIDCounter=0;$sampleIDCounter<scalar(@{${$scriptParameterHashRef}{sampleIDs}});$sampleIDCounter++) {  #Collect infiles for all sampleIDs
	
	if (defined(${$scriptParameterHashRef}{ ${$scriptParameterHashRef}{familyID} }{ ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter] }{GATKTargetPaddedBedIntervalLists})) {

	    ${$scriptParameterHashRef}{GATKTargetPaddedBedIntervalLists} = catfile(${$scriptParameterHashRef}{referencesDir}, ${$scriptParameterHashRef}{ ${$scriptParameterHashRef}{familyID} }{ ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter] }{GATKTargetPaddedBedIntervalLists});  #Transfer to scriptParameter top level
       
	    $GATKTargetPaddedBedIntervalListTracker{ ${$scriptParameterHashRef}{GATKTargetPaddedBedIntervalLists} }++;  #Increment to track file record
	    
	    if ($GATKTargetPaddedBedIntervalListTracker{ ${$scriptParameterHashRef}{GATKTargetPaddedBedIntervalLists} } == 1) {  #Not detected previously
		
		push(@GATKTargetPaddedBedIntervalListFiles, ${$scriptParameterHashRef}{ ${$scriptParameterHashRef}{familyID} }{ ${$scriptParameterHashRef}{sampleIDs}[$sampleIDCounter] }{GATKTargetPaddedBedIntervalLists});
	    }
	}
    }
    
    ##Determine file to print to module (untouched/merged and/or splited)
    my $outDirectory = ${$scriptParameterHashRef}{tempDirectory};  #For merged and/or splitet

    if (scalar(@GATKTargetPaddedBedIntervalListFiles) > 1) {  #Merge files
      
	say $FILEHANDLE "\n## Generate merged interval_list\n";

	&JavaCore({FILEHANDLE => $FILEHANDLE,
		   memoryAllocation => "Xmx2g",
		   javaUseLargePagesRef => \${$scriptParameterHashRef}{javaUseLargePages},
		   javaTemporaryDirectory => ${$scriptParameterHashRef}{tempDirectory},
		   javaJar => catfile(${$scriptParameterHashRef}{picardToolsPath}, "picard.jar"),
		  });

	print $FILEHANDLE "IntervalListTools ";
	print $FILEHANDLE "UNIQUE=TRUE ";  #Merge overlapping and adjacent intervals to create a list of unique intervals
    
	for (my $fileCounter=0;$fileCounter<scalar(@GATKTargetPaddedBedIntervalListFiles);$fileCounter++) {
	
	    print $FILEHANDLE "INPUT=".catfile(${$scriptParameterHashRef}{referencesDir}, $GATKTargetPaddedBedIntervalListFiles[$fileCounter])." ";
	}
	say $FILEHANDLE "OUTPUT=".catfile($outDirectory, "merged.interval_list"), "\n";  #Merged outfile

	if (defined($$contigRef)) {
	    
	    my $inDirectory = ${$scriptParameterHashRef}{tempDirectory};
	    my $infile = "merged.interval_list";
	    return &SplitTargetFile({FILEHANDLE => $FILEHANDLE,
				     inDirectoryRef => \$inDirectory,
				     outDirectoryRef => \$outDirectory,
				     infileRef => \$infile,
				     contigRef => $contigRef,
				    });
	}
        return catfile($outDirectory, "merged.interval_list");  #No split
    }
    elsif (defined($$contigRef)) {  #Supply original file but create splitted temp file

	return &SplitTargetFile({FILEHANDLE => $FILEHANDLE,
				 inDirectoryRef => \${$scriptParameterHashRef}{referencesDir},
				 outDirectoryRef => \$outDirectory,
				 infileRef => \$GATKTargetPaddedBedIntervalListFiles[0],
				 contigRef => $contigRef,
				});
    }
    else {#No merge and no split. return original and only file

	return  catfile(${$scriptParameterHashRef}{referencesDir}, $GATKTargetPaddedBedIntervalListFiles[0]);
    }
}


sub CheckTemplateFilesPaths {

##CheckTemplateFilesPaths
    
##Function : Checks that file paths in template files exist
##Returns  : "" 
##Arguments: $fileNameRef, $parameterName
##         : $fileNameRef   => File name {REF}
##         : $parameterName => MIP parameter name

    my $fileNameRef = $_[0];
    my $parameterName = $_[1];

    open(my $TF, "<", $$fileNameRef) or $logger->logdie("Can't open '".$$fileNameRef."':".$!."\n");  

    while (<TF>) {

	chomp $_;

	if (m/^\s+$/) {	 # Avoid blank lines
            next;
        }
	if (m/^\#/) {  # Avoid "#"
            next;
        }	
	if ($_ =~/(\S+)/) {	
	    
	    my $filePath = $_;

	    if ($filePath=~/^(RD!)/) {  #intersectCollect file
		
		my @filePath = split('\t', $filePath);
		$filePath[0] =~ s/^RD!/$scriptParameter{referencesDir}/g;

		&CheckExistance(\%parameter, \%scriptParameter, \$filePath[0], \$parameterName, "file");  #Only check paths that pointing to reference directory
	    }
	    if ($parameterName eq "GATKHaploTypeCallerRefBAMInfile") {  #Only Paths should be present i.e. check all lines
	       
		&CheckExistance(\%parameter, \%scriptParameter, \$filePath, \$parameterName, "file");
	    }
	}
    }
    close(TF);
}


sub PrintToFileHandles {

##PrintToFileHandles
    
##Function : Prints statement to all open FILEHANDLES 
##Returns  : ""
##Arguments: $arrayRef, $statement
##         : $arrayRef   => Array holding FILEHANDLES to print to {REF}. 
##         : $statement  => Statement to be printed

    my $arrayRef = $_[0];
    my $statement = $_[1];
   
    for (my $filehandleCounter=0;$filehandleCounter<scalar(@{$arrayRef});$filehandleCounter++) {
	 
	print {${$arrayRef}[$filehandleCounter]} $statement;
    }
}
